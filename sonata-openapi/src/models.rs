#![allow(unused_qualifications)]

use http::HeaderValue;
use validator::Validate;

#[cfg(feature = "server")]
use crate::header;
use crate::{models, types::*};

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StreamQueryParams {
    /// A string which uniquely identifies the file to stream. Obtained by calls to getMusicDirectory.
    #[serde(rename = "id")]
    pub id: String,
    /// (Since 1.2.0) If specified, the server will attempt to limit the bitrate to this value, in kilobits per second. If set to zero, no limit is imposed.
    #[serde(rename = "maxBitRate")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_bit_rate: Option<i32>,
    /// (Since 1.6.0) Specifies the preferred target format (e.g., “mp3” or “flv”) in case there are multiple applicable transcodings. Starting with 1.9.0 you can use the special value “raw” to disable transcoding.
    #[serde(rename = "format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub format: Option<String>,
    /// By default only applicable to video streaming. If specified, start streaming at the given offset (in seconds) into the media. The `Transcode Offset` extension enables the parameter to music too.
    #[serde(rename = "timeOffset")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time_offset: Option<i32>,
    /// (Since 1.6.0) Only applicable to video streaming. Requested video size specified as WxH, for instance “640x480”.
    #[serde(rename = "size")]
    #[validate(
                          regex(path = *RE_STREAMQUERYPARAMS_SIZE),
                    )]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<String>,
    /// (Since 1.8.0). If set to “true”, the Content-Length HTTP header will be set to an estimated value for transcoded or downsampled media.
    #[serde(rename = "estimateContentLength")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub estimate_content_length: Option<bool>,
    /// (Since 1.14.0) Only applicable to video streaming. Servers can optimize videos for streaming by converting them to MP4. If a conversion exists for the video in question, then setting this parameter to “true” will cause the converted video to be returned instead of the original.
    #[serde(rename = "converted")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub converted: Option<bool>,
}

lazy_static::lazy_static! {
    static ref RE_STREAMQUERYPARAMS_SIZE: regex::Regex = regex::Regex::new(r"^[0-9]+x[0-9]+$").unwrap();
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateBookmarkQueryParams {
    /// ID of the media file to bookmark. If a bookmark already exists for this file it will be overwritten.
    #[serde(rename = "id")]
    pub id: String,
    /// The position (in milliseconds) within the media file.
    #[serde(rename = "position")]
    pub position: i32,
    /// A user-defined comment.
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteBookmarkQueryParams {
    /// ID of the media file for which to delete the bookmark. Other users’ bookmarks are not affected.
    #[serde(rename = "id")]
    pub id: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SavePlayQueueQueryParams {
    /// ID of a song in the play queue. Use one id parameter for each song in the play queue.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The ID of the current playing song.
    #[serde(rename = "current")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub current: Option<String>,
    /// The position in milliseconds within the currently playing song.
    #[serde(rename = "position")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub position: Option<i32>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SavePlayQueueByIndexQueryParams {
    /// ID of a song in the play queue. Use one id parameter for each song in the play queue.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// The index of the current playing song.
    #[serde(rename = "currentIndex")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub current_index: Option<i32>,
    /// The position in milliseconds within the currently playing song.
    #[serde(rename = "position")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub position: Option<i32>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetAlbumQueryParams {
    /// The album ID.
    #[serde(rename = "id")]
    pub id: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetAlbumInfoQueryParams {
    /// The album ID or song ID.
    #[serde(rename = "id")]
    pub id: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetAlbumInfo2QueryParams {
    /// The album ID or song ID.
    #[serde(rename = "id")]
    pub id: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetArtistQueryParams {
    /// The artist ID.
    #[serde(rename = "id")]
    pub id: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetArtistInfoQueryParams {
    /// The artist, album or song ID.
    #[serde(rename = "id")]
    pub id: String,
    /// Max number of similar artists to return.
    #[serde(rename = "count")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<i32>,
    /// Whether to return artists that are not present in the media library.
    #[serde(rename = "includeNotPresent")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub include_not_present: Option<bool>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetArtistInfo2QueryParams {
    /// The artist, album or song ID.
    #[serde(rename = "id")]
    pub id: String,
    /// Max number of similar artists to return.
    #[serde(rename = "count")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<i32>,
    /// Whether to return artists that are not present in the media library.
    #[serde(rename = "includeNotPresent")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub include_not_present: Option<bool>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetArtistsQueryParams {
    /// If specified, only return artists in the music folder with the given ID. See `getMusicFolders`.
    #[serde(rename = "musicFolderId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_folder_id: Option<String>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetIndexesQueryParams {
    /// If specified, only return artists in the music folder with the given ID. See `getMusicFolders`.
    #[serde(rename = "musicFolderId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_folder_id: Option<String>,
    /// If specified, only return a result if the artist collection has changed since the given time (in milliseconds since 1 Jan 1970).
    #[serde(rename = "ifModifiedSince")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub if_modified_since: Option<i32>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetMusicDirectoryQueryParams {
    /// A string which uniquely identifies the music folder. Obtained by calls to `getIndexes` or `getMusicDirectory`.
    #[serde(rename = "id")]
    pub id: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetSimilarSongsQueryParams {
    /// The artist, album or song ID.
    #[serde(rename = "id")]
    pub id: String,
    /// Max number of songs to return.
    #[serde(rename = "count")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<i32>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetSimilarSongs2QueryParams {
    /// The artist, album or song ID.
    #[serde(rename = "id")]
    pub id: String,
    /// Max number of songs to return.
    #[serde(rename = "count")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<i32>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetSongQueryParams {
    /// The song ID.
    #[serde(rename = "id")]
    pub id: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetTopSongsQueryParams {
    /// The artist name.
    #[serde(rename = "id")]
    pub id: String,
    /// The maximum number of songs to return.
    #[serde(rename = "count")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<i32>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetVideoInfoQueryParams {
    /// The video ID.
    #[serde(rename = "id")]
    pub id: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetAddChatMessageQueryParams {
    /// The chat message.
    #[serde(rename = "message")]
    pub message: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Search3QueryParams {
    /// Search query. Servers must support an empty query and return all the data to allow clients to properly access all the media information for offline sync.
    #[serde(rename = "query")]
    pub query: String,
    /// Maximum number of artists to return.
    #[serde(rename = "artistCount")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist_count: Option<i32>,
    /// Search result offset for artists. Used for paging.
    #[serde(rename = "artistOffset")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist_offset: Option<i32>,
    /// Maximum number of albums to return.
    #[serde(rename = "albumCount")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album_count: Option<i32>,
    /// Search result offset for albums. Used for paging.
    #[serde(rename = "albumOffset")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album_offset: Option<i32>,
    /// Maximum number of songs to return.
    #[serde(rename = "songCount")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub song_count: Option<i32>,
    /// Search result offset for songs. Used for paging.
    #[serde(rename = "songOffset")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub song_offset: Option<i32>,
    /// (Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
    #[serde(rename = "musicFolderId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_folder_id: Option<String>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetLyricsBySongIdQueryParams {
    /// The track ID.
    #[serde(rename = "id")]
    pub id: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPodcastEpisodeQueryParams {
    /// The podcast episode ID.
    #[serde(rename = "id")]
    pub id: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateInternetRadioStationQueryParams {
    /// The stream URL for the station.
    #[serde(rename = "streamUrl")]
    pub stream_url: String,
    /// The station name.
    #[serde(rename = "name")]
    pub name: String,
    /// The home page URL for the station.
    #[serde(rename = "homepageUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub homepage_url: Option<String>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteInternetRadioStationQueryParams {
    /// The ID for the station.
    #[serde(rename = "id")]
    pub id: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateInternetRadioStationQueryParams {
    /// The ID of the station.
    #[serde(rename = "id")]
    pub id: String,
    /// The stream URL for the station.
    #[serde(rename = "streamUrl")]
    pub stream_url: String,
    /// The user-defined name for the station.
    #[serde(rename = "name")]
    pub name: String,
    /// The home page URL for the station.
    #[serde(rename = "homepageUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub homepage_url: Option<String>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct JukeboxControlQueryParams {
    /// The operation to perform. Must be one of: get, status (since 1.7.0), set (since 1.7.0), start, stop, skip, add, clear, remove, shuffle, setGain
    #[serde(rename = "action")]
    pub action: models::JukeboxAction,
    /// Used by `skip` and `remove`. Zero-based index of the song to skip to or remove.
    #[serde(rename = "index")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index: Option<i32>,
    /// (Since 1.7.0) Used by `skip`. Start playing this many seconds into the track.
    #[serde(rename = "offset")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub offset: Option<i32>,
    /// Used by `add` and `set`. ID of song to add to the jukebox playlist. Use multiple id parameters to add many songs in the same request. (set is similar to a clear followed by a add, but will not change the currently playing track.)
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: Vec<String>,
    /// Used by `setGain` to control the playback volume. A float value between 0.0 and 1.0.
    #[serde(rename = "gain")]
    #[validate(range(min = 0f32, max = 1f32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gain: Option<f32>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetAlbumListQueryParams {
    #[serde(rename = "type")]
    pub r#type: models::AlbumListType,
    /// The number of albums to return. Max 500.
    #[serde(rename = "size")]
    #[validate(range(min = 1i32, max = 500i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<i32>,
    /// The list offset. Useful if you for example want to page through the list of newest albums.
    #[serde(rename = "offset")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub offset: Option<i32>,
    /// Required if `type=='byYear'`. The first year in the range. If `fromYear` > `toYear` a reverse chronological list is returned.
    #[serde(rename = "fromYear")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub from_year: Option<i32>,
    /// Required if `type=='byYear'`. The last year in the range.
    #[serde(rename = "toYear")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub to_year: Option<i32>,
    /// Required if `type=='byGenre'`. The name of the genre, e.g., “Rock”.
    #[serde(rename = "genre")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub genre: Option<String>,
    /// (Since 1.11.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
    #[serde(rename = "musicFolderId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_folder_id: Option<String>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetAlbumList2QueryParams {
    #[serde(rename = "type")]
    pub r#type: models::AlbumListType,
    /// The number of albums to return. Max 500.
    #[serde(rename = "size")]
    #[validate(range(min = 1i32, max = 500i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<i32>,
    /// The list offset. Useful if you for example want to page through the list of newest albums.
    #[serde(rename = "offset")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub offset: Option<i32>,
    /// Required if `type=='byYear'`. The first year in the range. If `fromYear` > `toYear` a reverse chronological list is returned.
    #[serde(rename = "fromYear")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub from_year: Option<i32>,
    /// Required if `type=='byYear'`. The last year in the range.
    #[serde(rename = "toYear")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub to_year: Option<i32>,
    /// Required if `type=='byGenre'`. The name of the genre, e.g., “Rock”.
    #[serde(rename = "genre")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub genre: Option<String>,
    /// (Since 1.11.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
    #[serde(rename = "musicFolderId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_folder_id: Option<String>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetRandomSongsQueryParams {
    /// The maximum number of songs to return. Max 500.
    #[serde(rename = "size")]
    #[validate(range(min = 0i32, max = 500i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<i32>,
    /// Only returns songs belonging to this genre.
    #[serde(rename = "genre")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub genre: Option<String>,
    /// (Since 1.9.0) Only return songs from this year or later.
    #[serde(rename = "fromYear")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub from_year: Option<i32>,
    /// Only return songs published before or in this year.
    #[serde(rename = "toYear")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub to_year: Option<i32>,
    /// Only return songs in the music folder with the given ID. See `getMusicFolders`.
    #[serde(rename = "musicFolderId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_folder_id: Option<String>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetSongsByGenreQueryParams {
    /// The genre, as returned by `getGenres`.
    #[serde(rename = "genre")]
    pub genre: String,
    /// The maximum number of songs to return. Max 500.
    #[serde(rename = "count")]
    #[validate(range(min = 0i32, max = 500i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<i32>,
    /// The offset. Useful if you want to page through the songs in a genre.
    #[serde(rename = "offset")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub offset: Option<i32>,
    /// (Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
    #[serde(rename = "musicFolderId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_folder_id: Option<String>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetStarredQueryParams {
    /// (Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
    #[serde(rename = "musicFolderId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_folder_id: Option<String>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetStarred2QueryParams {
    /// (Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
    #[serde(rename = "musicFolderId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_folder_id: Option<String>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ScrobbleQueryParams {
    /// A string which uniquely identifies the file to scrobble.
    #[serde(rename = "id")]
    pub id: String,
    /// (Since 1.8.0) The time (in milliseconds since 1 Jan 1970) at which the song was listened to.
    #[serde(rename = "time")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time: Option<i32>,
    /// Whether this is a “submission” or a “now playing” notification.
    #[serde(rename = "submission")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub submission: Option<bool>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SetRatingQueryParams {
    /// A string which uniquely identifies the file (song) or folder (album/artist) to rate.
    #[serde(rename = "id")]
    pub id: String,
    /// The rating between 1 and 5 (inclusive), or 0 to remove the rating.
    #[serde(rename = "rating")]
    #[validate(range(min = 0i32, max = 5i32))]
    pub rating: i32,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StarQueryParams {
    /// The ID of the file (song) or folder (album/artist) to star. Multiple parameters allowed.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: Vec<String>,
    /// The ID of an album to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.
    #[serde(rename = "albumId")]
    #[serde(default)]
    pub album_id: Vec<String>,
    /// The ID of an artist to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.
    #[serde(rename = "artistId")]
    #[serde(default)]
    pub artist_id: Vec<String>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UnstarQueryParams {
    /// The ID of the file (song) or folder (album/artist) to star. Multiple parameters allowed.
    #[serde(rename = "id")]
    #[serde(default)]
    pub id: Vec<String>,
    /// The ID of an album to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.
    #[serde(rename = "albumId")]
    #[serde(default)]
    pub album_id: Vec<String>,
    /// The ID of an artist to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.
    #[serde(rename = "artistId")]
    #[serde(default)]
    pub artist_id: Vec<String>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DownloadQueryParams {
    /// A string which uniquely identifies the file to stream. Obtained by calls to getMusicDirectory.
    #[serde(rename = "id")]
    pub id: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetAvatarQueryParams {
    #[serde(rename = "username")]
    pub username: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetCaptionsQueryParams {
    /// The ID of the video.
    #[serde(rename = "id")]
    pub id: String,
    /// Preferred captions format (“srt” or “vtt”).
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub format: Option<String>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetCoverArtQueryParams {
    /// The coverArt ID. Returned by most entities likes `Child` or `AlbumID3`
    #[serde(rename = "id")]
    pub id: String,
    /// If specified, scale image to this size.
    #[serde(rename = "size")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<i32>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetLyricsQueryParams {
    /// The artist name.
    #[serde(rename = "artist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist: Option<String>,
    /// The song title.
    #[serde(rename = "title")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HlsPeriodM3u8QueryParams {
    /// A string which uniquely identifies the media file to stream.
    #[serde(rename = "id")]
    pub id: String,
    /// If specified, the server will attempt to limit the bitrate to this value, in kilobits per second. If this parameter is specified more than once, the server will create a variant playlist, suitable for adaptive bitrate streaming. The playlist will support streaming at all the specified bitrates. The server will automatically choose video dimensions that are suitable for the given bitrates. Since 1.9.0 you may explicitly request a certain width (480) and height (360) like so: bitRate=1000@480x360
    #[serde(rename = "bitRate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bit_rate: Option<i32>,
    /// The ID of the audio track to use. See `getVideoInfo` for how to get the list of available audio tracks for a video.
    #[serde(rename = "audioTrack")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audio_track: Option<String>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreatePlaylistQueryParams {
    /// The playlist ID. Required if updating an existing playlist.
    #[serde(rename = "playlistId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub playlist_id: Option<String>,
    /// The human-readable name of the playlist. Required if creating a new playlist.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// ID of a song in the playlist. Use one `songId` parameter for each song in the playlist.
    #[serde(rename = "songId")]
    #[serde(default)]
    pub song_id: Vec<String>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeletePlaylistQueryParams {
    /// ID of the playlist to delete, as obtained by `getPlaylists`.
    #[serde(rename = "id")]
    pub id: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPlaylistQueryParams {
    /// ID of the playlist to return, as obtained by `getPlaylists`.
    #[serde(rename = "id")]
    pub id: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPlaylistsQueryParams {
    /// (Since 1.8.0) If specified, return playlists for this user rather than for the authenticated user. The authenticated user must have admin role if this parameter is used.
    #[serde(rename = "username")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdatePlaylistQueryParams {
    /// The playlist ID.
    #[serde(rename = "playlistId")]
    pub playlist_id: String,
    /// The human-readable name of the playlist.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The playlist comment.
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    /// `true` if the playlist should be visible to all users, `false` otherwise.
    #[serde(rename = "public")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub public: Option<bool>,
    /// Add this song with this ID to the playlist. Multiple parameters allowed.
    #[serde(rename = "songIdToAdd")]
    #[serde(default)]
    pub song_id_to_add: Vec<String>,
    /// Remove the song at this position in the playlist. Multiple parameters allowed.
    #[serde(rename = "songIndexToRemove")]
    #[serde(default)]
    pub song_index_to_remove: Vec<i32>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreatePodcastChannelQueryParams {
    /// The URL of the Podcast to add.
    #[serde(rename = "url")]
    pub url: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeletePodcastChannelQueryParams {
    /// The ID of the Podcast channel to delete.
    #[serde(rename = "id")]
    pub id: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeletePodcastEpisodeQueryParams {
    /// The ID of the Podcast episode to delete.
    #[serde(rename = "id")]
    pub id: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DownloadPodcastEpisodeQueryParams {
    /// The ID of the Podcast episode to download
    #[serde(rename = "id")]
    pub id: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetNewestPodcastsQueryParams {
    /// The maximum number of episodes to return.
    #[serde(rename = "count")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<i32>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPodcastsQueryParams {
    /// (Since 1.9.0) If specified, only return the Podcast channel with this ID.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// (Since 1.9.0) Whether to include Podcast episodes in the returned result.
    #[serde(rename = "includeEpisodes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub include_episodes: Option<bool>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SearchQueryParams {
    /// Artist to search for.
    #[serde(rename = "artist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist: Option<String>,
    /// Album to search for.
    #[serde(rename = "album")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album: Option<String>,
    /// Song title to search for.
    #[serde(rename = "title")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    /// Searches all fields.
    #[serde(rename = "any")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub any: Option<bool>,
    /// Maximum number of results to return.
    #[serde(rename = "count")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<i32>,
    /// Search result offset. Used for paging.
    #[serde(rename = "offset")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub offset: Option<i32>,
    /// Only return matches that are newer than this. Given as milliseconds since 1970.
    #[serde(rename = "newerThan")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub newer_than: Option<i32>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Search2QueryParams {
    /// Search query.
    #[serde(rename = "query")]
    pub query: String,
    /// Maximum number of artists to return.
    #[serde(rename = "artistCount")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist_count: Option<i32>,
    /// Search result offset for artists. Used for paging.
    #[serde(rename = "artistOffset")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist_offset: Option<i32>,
    /// Maximum number of albums to return.
    #[serde(rename = "albumCount")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album_count: Option<i32>,
    /// Search result offset for albums. Used for paging.
    #[serde(rename = "albumOffset")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album_offset: Option<i32>,
    /// Maximum number of songs to return.
    #[serde(rename = "songCount")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub song_count: Option<i32>,
    /// Search result offset for songs. Used for paging.
    #[serde(rename = "songOffset")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub song_offset: Option<i32>,
    /// (Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
    #[serde(rename = "musicFolderId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_folder_id: Option<String>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateShareQueryParams {
    /// ID of a song, album or video to share. Use one id parameter for each entry to share.
    #[serde(rename = "id")]
    pub id: Vec<String>,
    /// A user-defined description that will be displayed to people visiting the shared media.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The time at which the share expires. Given as milliseconds since 1970.
    #[serde(rename = "expires")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires: Option<i32>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteShareQueryParams {
    /// ID of the share to delete.
    #[serde(rename = "id")]
    pub id: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateShareQueryParams {
    /// ID of the share to update.
    #[serde(rename = "id")]
    pub id: String,
    /// A user-defined description that will be displayed to people visiting the shared media.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The time at which the share expires. Given as milliseconds since 1970, or zero to remove the expiration.
    #[serde(rename = "expires")]
    #[validate(range(min = 0i32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires: Option<i32>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChangePasswordQueryParams {
    /// The name of the user which should change its password.
    #[serde(rename = "username")]
    pub username: String,
    /// The new password of the new user, either in clear text of hex-encoded (see above).
    #[serde(rename = "password")]
    pub password: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateUserQueryParams {
    /// The name of the new user.
    #[serde(rename = "username")]
    pub username: String,
    /// The password of the new user, either in clear text of hex-encoded (see above).
    #[serde(rename = "password")]
    pub password: String,
    /// The email address of the new user.
    #[serde(rename = "email")]
    pub email: String,
    /// Whether the user is authenticated in LDAP.
    #[serde(rename = "ldapAuthenticated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ldap_authenticated: Option<bool>,
    /// Whether the user is administrator.
    #[serde(rename = "adminRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub admin_role: Option<bool>,
    /// Whether the user is allowed to change personal settings and password.
    #[serde(rename = "settingsRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub settings_role: Option<bool>,
    /// Whether the user is allowed to play files.
    #[serde(rename = "streamRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_role: Option<bool>,
    /// Whether the user is allowed to play files in jukebox mode.
    #[serde(rename = "jukeboxRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub jukebox_role: Option<bool>,
    /// Whether the user is allowed to download files.
    #[serde(rename = "downloadRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub download_role: Option<bool>,
    /// Whether the user is allowed to upload files.
    #[serde(rename = "uploadRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub upload_role: Option<bool>,
    /// Whether the user is allowed to create and delete playlists. Since 1.8.0, changing this role has no effect.
    #[serde(rename = "playlistRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub playlist_role: Option<bool>,
    /// Whether the user is allowed to change cover art and tags.
    #[serde(rename = "coverArtRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cover_art_role: Option<bool>,
    /// Whether the user is allowed to create and edit comments and ratings.
    #[serde(rename = "commentRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment_role: Option<bool>,
    /// Whether the user is allowed to administrate Podcasts.
    #[serde(rename = "podcastRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub podcast_role: Option<bool>,
    /// (Since 1.8.0) Whether the user is allowed to share files with anyone.
    #[serde(rename = "shareRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub share_role: Option<bool>,
    /// (Since 1.15.0) Whether the user is allowed to start video conversions.
    #[serde(rename = "videoConversionRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub video_conversion_role: Option<bool>,
    /// (Since 1.12.0) IDs of the music folders the user is allowed access to. Include the parameter once for each folder. Default all folders.
    #[serde(rename = "musicFolderId")]
    #[serde(default)]
    pub music_folder_id: Vec<String>,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteUserQueryParams {
    /// The name of the user to delete.
    #[serde(rename = "username")]
    pub username: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetUserQueryParams {
    /// The name of the user to retrieve. You can only retrieve your own user unless you have admin privileges.
    #[serde(rename = "username")]
    pub username: String,
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateUserQueryParams {
    /// The name of the user.
    #[serde(rename = "username")]
    pub username: String,
    /// The password of the user, either in clear text of hex-encoded (see above).
    #[serde(rename = "password")]
    pub password: String,
    /// The email address of the user.
    #[serde(rename = "email")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,
    /// Whether the user is authenicated in LDAP.
    #[serde(rename = "ldapAuthenticated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ldap_authenticated: Option<bool>,
    /// Whether the user is administrator.
    #[serde(rename = "adminRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub admin_role: Option<bool>,
    /// Whether the user is allowed to change personal settings and password.
    #[serde(rename = "settingsRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub settings_role: Option<bool>,
    /// Whether the user is allowed to play files.
    #[serde(rename = "streamRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_role: Option<bool>,
    /// Whether the user is allowed to play files in jukebox mode.
    #[serde(rename = "jukeboxRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub jukebox_role: Option<bool>,
    /// Whether the user is allowed to download files.
    #[serde(rename = "downloadRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub download_role: Option<bool>,
    /// Whether the user is allowed to upload files.
    #[serde(rename = "uploadRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub upload_role: Option<bool>,
    /// Whether the user is allowed to change cover art and tags.
    #[serde(rename = "coverArtRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cover_art_role: Option<bool>,
    /// Whether the user is allowed to create and edit comments and ratings.
    #[serde(rename = "commentRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment_role: Option<bool>,
    /// Whether the user is allowed to administrate Podcasts.
    #[serde(rename = "podcastRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub podcast_role: Option<bool>,
    /// Whether the user is allowed to share files with anyone.
    #[serde(rename = "shareRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub share_role: Option<bool>,
    /// (Since 1.15.0) Whether the user is allowed to start video conversions.
    #[serde(rename = "videoConversionRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub video_conversion_role: Option<bool>,
    /// (Since 1.12.0) IDs of the music folders the user is allowed access to. Include the parameter once for each folder.
    #[serde(rename = "musicFolderId")]
    #[serde(default)]
    pub music_folder_id: Vec<String>,
    /// (Since 1.13.0) The maximum bit rate (in Kbps) for the user. Audio streams of higher bit rates are automatically downsampled to this bit rate. Legal values: 0 (no limit), 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "maxBitRate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_bit_rate: Option<i32>,
}

/// Album with songs.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AlbumId3 {
    /// The id of the album
    #[serde(rename = "id")]
    pub id: String,

    /// The album name.
    #[serde(rename = "name")]
    pub name: String,

    /// The album version name (Remastered, Anniversary Box Set, …).
    #[serde(rename = "version")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,

    /// Artist name.
    #[serde(rename = "artist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist: Option<String>,

    /// The id of the artist
    #[serde(rename = "artistId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist_id: Option<String>,

    /// A covertArt id.
    #[serde(rename = "coverArt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cover_art: Option<String>,

    /// Number of songs
    #[serde(rename = "songCount")]
    pub song_count: i32,

    /// Total duration of the album in seconds
    #[serde(rename = "duration")]
    pub duration: i32,

    /// Number of play of the album
    #[serde(rename = "playCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub play_count: Option<i32>,

    /// Date the album was added. [ISO 8601]
    #[serde(rename = "created")]
    pub created: chrono::DateTime<chrono::Utc>,

    /// Date the album was added. [ISO 8601]
    #[serde(rename = "starred")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub starred: Option<chrono::DateTime<chrono::Utc>>,

    /// The album year
    #[serde(rename = "year")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub year: Option<i32>,

    /// The album genre
    #[serde(rename = "genre")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub genre: Option<String>,

    /// Date the album was last played. [ISO 8601]
    #[serde(rename = "played")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub played: Option<chrono::DateTime<chrono::Utc>>,

    /// The user rating of the album. [1-5]
    #[serde(rename = "userRating")]
    #[validate(range(min = 1u8, max = 5u8))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_rating: Option<u8>,

    /// The labels producing the album.
    #[serde(rename = "recordLabels")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub record_labels: Option<Vec<models::RecordLabel>>,

    /// The album MusicBrainzID.
    #[serde(rename = "musicBrainzId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_brainz_id: Option<String>,

    /// The list of all genres of the album.
    #[serde(rename = "genres")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub genres: Option<Vec<models::ItemGenre>>,

    /// The list of all album artists of the album.
    #[serde(rename = "artists")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artists: Option<Vec<models::ArtistId3>>,

    /// The single value display artist.
    #[serde(rename = "displayArtist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display_artist: Option<String>,

    /// The types of this album release. (Album, Compilation, EP, Remix, …).
    #[serde(rename = "releaseTypes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub release_types: Option<Vec<String>>,

    /// The list of all moods of the album.
    #[serde(rename = "moods")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moods: Option<Vec<String>>,

    /// The album sort name.
    #[serde(rename = "sortName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sort_name: Option<String>,

    /// Date the album was originally released.
    #[serde(rename = "originalReleaseDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub original_release_date: Option<models::ItemDate>,

    /// Date the specific edition of the album was released. Note: for files using ID3 tags, releaseDate should generally be read from the TDRL tag. Servers that use a different source for this field should document the behavior.
    #[serde(rename = "releaseDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub release_date: Option<models::ItemDate>,

    /// True if the album is a compilation.
    #[serde(rename = "isCompilation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_compilation: Option<bool>,

    #[serde(rename = "explicitStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub explicit_status: Option<models::ExplicitStatus>,

    /// The list of all disc titles of the album.
    #[serde(rename = "discTitles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disc_titles: Option<Vec<models::DiscTitle>>,

    /// The list of songs
    #[serde(rename = "song")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub song: Option<Vec<models::Child>>,
}

impl AlbumId3 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        id: String,
        name: String,
        song_count: i32,
        duration: i32,
        created: chrono::DateTime<chrono::Utc>,
    ) -> AlbumId3 {
        AlbumId3 {
            id,
            name,
            version: None,
            artist: None,
            artist_id: None,
            cover_art: None,
            song_count,
            duration,
            play_count: None,
            created,
            starred: None,
            year: None,
            genre: None,
            played: None,
            user_rating: None,
            record_labels: None,
            music_brainz_id: None,
            genres: None,
            artists: None,
            display_artist: None,
            release_types: None,
            moods: None,
            sort_name: None,
            original_release_date: None,
            release_date: None,
            is_compilation: None,
            explicit_status: None,
            disc_titles: None,
            song: None,
        }
    }
}

/// Converts the AlbumId3 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AlbumId3 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            Some("name".to_string()),
            Some(self.name.to_string()),
            self.version
                .as_ref()
                .map(|version| ["version".to_string(), version.to_string()].join(",")),
            self.artist
                .as_ref()
                .map(|artist| ["artist".to_string(), artist.to_string()].join(",")),
            self.artist_id
                .as_ref()
                .map(|artist_id| ["artistId".to_string(), artist_id.to_string()].join(",")),
            self.cover_art
                .as_ref()
                .map(|cover_art| ["coverArt".to_string(), cover_art.to_string()].join(",")),
            Some("songCount".to_string()),
            Some(self.song_count.to_string()),
            Some("duration".to_string()),
            Some(self.duration.to_string()),
            self.play_count
                .as_ref()
                .map(|play_count| ["playCount".to_string(), play_count.to_string()].join(",")),
            // Skipping created in query parameter serialization

            // Skipping starred in query parameter serialization
            self.year
                .as_ref()
                .map(|year| ["year".to_string(), year.to_string()].join(",")),
            self.genre
                .as_ref()
                .map(|genre| ["genre".to_string(), genre.to_string()].join(",")),
            // Skipping played in query parameter serialization
            self.user_rating
                .as_ref()
                .map(|user_rating| ["userRating".to_string(), user_rating.to_string()].join(",")),
            // Skipping recordLabels in query parameter serialization
            self.music_brainz_id.as_ref().map(|music_brainz_id| {
                ["musicBrainzId".to_string(), music_brainz_id.to_string()].join(",")
            }),
            // Skipping genres in query parameter serialization

            // Skipping artists in query parameter serialization
            self.display_artist.as_ref().map(|display_artist| {
                ["displayArtist".to_string(), display_artist.to_string()].join(",")
            }),
            self.release_types.as_ref().map(|release_types| {
                [
                    "releaseTypes".to_string(),
                    release_types
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.moods.as_ref().map(|moods| {
                [
                    "moods".to_string(),
                    moods
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.sort_name
                .as_ref()
                .map(|sort_name| ["sortName".to_string(), sort_name.to_string()].join(",")),
            // Skipping originalReleaseDate in query parameter serialization

            // Skipping releaseDate in query parameter serialization
            self.is_compilation.as_ref().map(|is_compilation| {
                ["isCompilation".to_string(), is_compilation.to_string()].join(",")
            }),
            // Skipping explicitStatus in query parameter serialization

            // Skipping discTitles in query parameter serialization

            // Skipping song in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AlbumId3 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AlbumId3 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub version: Vec<String>,
            pub artist: Vec<String>,
            pub artist_id: Vec<String>,
            pub cover_art: Vec<String>,
            pub song_count: Vec<i32>,
            pub duration: Vec<i32>,
            pub play_count: Vec<i32>,
            pub created: Vec<chrono::DateTime<chrono::Utc>>,
            pub starred: Vec<chrono::DateTime<chrono::Utc>>,
            pub year: Vec<i32>,
            pub genre: Vec<String>,
            pub played: Vec<chrono::DateTime<chrono::Utc>>,
            pub user_rating: Vec<u8>,
            pub record_labels: Vec<Vec<models::RecordLabel>>,
            pub music_brainz_id: Vec<String>,
            pub genres: Vec<Vec<models::ItemGenre>>,
            pub artists: Vec<Vec<models::ArtistId3>>,
            pub display_artist: Vec<String>,
            pub release_types: Vec<Vec<String>>,
            pub moods: Vec<Vec<String>>,
            pub sort_name: Vec<String>,
            pub original_release_date: Vec<models::ItemDate>,
            pub release_date: Vec<models::ItemDate>,
            pub is_compilation: Vec<bool>,
            pub explicit_status: Vec<models::ExplicitStatus>,
            pub disc_titles: Vec<Vec<models::DiscTitle>>,
            pub song: Vec<Vec<models::Child>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AlbumId3".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artist" => intermediate_rep.artist.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artistId" => intermediate_rep.artist_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "coverArt" => intermediate_rep.cover_art.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "songCount" => intermediate_rep.song_count.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "duration" => intermediate_rep.duration.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "playCount" => intermediate_rep.play_count.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "starred" => intermediate_rep.starred.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "year" => intermediate_rep.year.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "genre" => intermediate_rep.genre.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "played" => intermediate_rep.played.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "userRating" => intermediate_rep
                        .user_rating
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "recordLabels" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AlbumId3"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "musicBrainzId" => intermediate_rep.music_brainz_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "genres" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AlbumId3"
                                .to_string(),
                        )
                    }
                    "artists" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AlbumId3"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "displayArtist" => intermediate_rep.display_artist.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "releaseTypes" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AlbumId3"
                                .to_string(),
                        )
                    }
                    "moods" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AlbumId3"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "sortName" => intermediate_rep.sort_name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "originalReleaseDate" => intermediate_rep.original_release_date.push(
                        <models::ItemDate as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "releaseDate" => intermediate_rep.release_date.push(
                        <models::ItemDate as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "isCompilation" => intermediate_rep.is_compilation.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "explicitStatus" => intermediate_rep.explicit_status.push(
                        <models::ExplicitStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "discTitles" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AlbumId3"
                                .to_string(),
                        )
                    }
                    "song" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AlbumId3"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AlbumId3".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AlbumId3 {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in AlbumId3".to_string())?,
            name: intermediate_rep
                .name
                .into_iter()
                .next()
                .ok_or_else(|| "name missing in AlbumId3".to_string())?,
            version: intermediate_rep.version.into_iter().next(),
            artist: intermediate_rep.artist.into_iter().next(),
            artist_id: intermediate_rep.artist_id.into_iter().next(),
            cover_art: intermediate_rep.cover_art.into_iter().next(),
            song_count: intermediate_rep
                .song_count
                .into_iter()
                .next()
                .ok_or_else(|| "songCount missing in AlbumId3".to_string())?,
            duration: intermediate_rep
                .duration
                .into_iter()
                .next()
                .ok_or_else(|| "duration missing in AlbumId3".to_string())?,
            play_count: intermediate_rep.play_count.into_iter().next(),
            created: intermediate_rep
                .created
                .into_iter()
                .next()
                .ok_or_else(|| "created missing in AlbumId3".to_string())?,
            starred: intermediate_rep.starred.into_iter().next(),
            year: intermediate_rep.year.into_iter().next(),
            genre: intermediate_rep.genre.into_iter().next(),
            played: intermediate_rep.played.into_iter().next(),
            user_rating: intermediate_rep.user_rating.into_iter().next(),
            record_labels: intermediate_rep.record_labels.into_iter().next(),
            music_brainz_id: intermediate_rep.music_brainz_id.into_iter().next(),
            genres: intermediate_rep.genres.into_iter().next(),
            artists: intermediate_rep.artists.into_iter().next(),
            display_artist: intermediate_rep.display_artist.into_iter().next(),
            release_types: intermediate_rep.release_types.into_iter().next(),
            moods: intermediate_rep.moods.into_iter().next(),
            sort_name: intermediate_rep.sort_name.into_iter().next(),
            original_release_date: intermediate_rep.original_release_date.into_iter().next(),
            release_date: intermediate_rep.release_date.into_iter().next(),
            is_compilation: intermediate_rep.is_compilation.into_iter().next(),
            explicit_status: intermediate_rep.explicit_status.into_iter().next(),
            disc_titles: intermediate_rep.disc_titles.into_iter().next(),
            song: intermediate_rep.song.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AlbumId3> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AlbumId3>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AlbumId3>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AlbumId3 - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AlbumId3> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AlbumId3 as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AlbumId3 - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AlbumId3WithSongs {
    /// The id of the album
    #[serde(rename = "id")]
    pub id: String,

    /// The album name.
    #[serde(rename = "name")]
    pub name: String,

    /// The album version name (Remastered, Anniversary Box Set, …).
    #[serde(rename = "version")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,

    /// Artist name.
    #[serde(rename = "artist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist: Option<String>,

    /// The id of the artist
    #[serde(rename = "artistId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist_id: Option<String>,

    /// A covertArt id.
    #[serde(rename = "coverArt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cover_art: Option<String>,

    /// Number of songs
    #[serde(rename = "songCount")]
    pub song_count: i32,

    /// Total duration of the album in seconds
    #[serde(rename = "duration")]
    pub duration: i32,

    /// Number of play of the album
    #[serde(rename = "playCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub play_count: Option<i32>,

    /// Date the album was added. [ISO 8601]
    #[serde(rename = "created")]
    pub created: chrono::DateTime<chrono::Utc>,

    /// Date the album was added. [ISO 8601]
    #[serde(rename = "starred")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub starred: Option<chrono::DateTime<chrono::Utc>>,

    /// The album year
    #[serde(rename = "year")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub year: Option<i32>,

    /// The album genre
    #[serde(rename = "genre")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub genre: Option<String>,

    /// Date the album was last played. [ISO 8601]
    #[serde(rename = "played")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub played: Option<chrono::DateTime<chrono::Utc>>,

    /// The user rating of the album. [1-5]
    #[serde(rename = "userRating")]
    #[validate(range(min = 1u8, max = 5u8))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_rating: Option<u8>,

    /// The labels producing the album.
    #[serde(rename = "recordLabels")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub record_labels: Option<Vec<models::RecordLabel>>,

    /// The album MusicBrainzID.
    #[serde(rename = "musicBrainzId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_brainz_id: Option<String>,

    /// The list of all genres of the album.
    #[serde(rename = "genres")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub genres: Option<Vec<models::ItemGenre>>,

    /// The list of all album artists of the album.
    #[serde(rename = "artists")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artists: Option<Vec<models::ArtistId3>>,

    /// The single value display artist.
    #[serde(rename = "displayArtist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display_artist: Option<String>,

    /// The types of this album release. (Album, Compilation, EP, Remix, …).
    #[serde(rename = "releaseTypes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub release_types: Option<Vec<String>>,

    /// The list of all moods of the album.
    #[serde(rename = "moods")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moods: Option<Vec<String>>,

    /// The album sort name.
    #[serde(rename = "sortName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sort_name: Option<String>,

    /// Date the album was originally released.
    #[serde(rename = "originalReleaseDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub original_release_date: Option<models::ItemDate>,

    /// Date the specific edition of the album was released. Note: for files using ID3 tags, releaseDate should generally be read from the TDRL tag. Servers that use a different source for this field should document the behavior.
    #[serde(rename = "releaseDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub release_date: Option<models::ItemDate>,

    /// True if the album is a compilation.
    #[serde(rename = "isCompilation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_compilation: Option<bool>,

    #[serde(rename = "explicitStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub explicit_status: Option<models::ExplicitStatus>,

    /// The list of all disc titles of the album.
    #[serde(rename = "discTitles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disc_titles: Option<Vec<models::DiscTitle>>,

    /// The list of songs
    #[serde(rename = "song")]
    pub song: Vec<models::Child>,
}

impl AlbumId3WithSongs {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        id: String,
        name: String,
        song_count: i32,
        duration: i32,
        created: chrono::DateTime<chrono::Utc>,
        song: Vec<models::Child>,
    ) -> AlbumId3WithSongs {
        AlbumId3WithSongs {
            id,
            name,
            version: None,
            artist: None,
            artist_id: None,
            cover_art: None,
            song_count,
            duration,
            play_count: None,
            created,
            starred: None,
            year: None,
            genre: None,
            played: None,
            user_rating: None,
            record_labels: None,
            music_brainz_id: None,
            genres: None,
            artists: None,
            display_artist: None,
            release_types: None,
            moods: None,
            sort_name: None,
            original_release_date: None,
            release_date: None,
            is_compilation: None,
            explicit_status: None,
            disc_titles: None,
            song,
        }
    }
}

/// Converts the AlbumId3WithSongs value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AlbumId3WithSongs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            Some("name".to_string()),
            Some(self.name.to_string()),
            self.version
                .as_ref()
                .map(|version| ["version".to_string(), version.to_string()].join(",")),
            self.artist
                .as_ref()
                .map(|artist| ["artist".to_string(), artist.to_string()].join(",")),
            self.artist_id
                .as_ref()
                .map(|artist_id| ["artistId".to_string(), artist_id.to_string()].join(",")),
            self.cover_art
                .as_ref()
                .map(|cover_art| ["coverArt".to_string(), cover_art.to_string()].join(",")),
            Some("songCount".to_string()),
            Some(self.song_count.to_string()),
            Some("duration".to_string()),
            Some(self.duration.to_string()),
            self.play_count
                .as_ref()
                .map(|play_count| ["playCount".to_string(), play_count.to_string()].join(",")),
            // Skipping created in query parameter serialization

            // Skipping starred in query parameter serialization
            self.year
                .as_ref()
                .map(|year| ["year".to_string(), year.to_string()].join(",")),
            self.genre
                .as_ref()
                .map(|genre| ["genre".to_string(), genre.to_string()].join(",")),
            // Skipping played in query parameter serialization
            self.user_rating
                .as_ref()
                .map(|user_rating| ["userRating".to_string(), user_rating.to_string()].join(",")),
            // Skipping recordLabels in query parameter serialization
            self.music_brainz_id.as_ref().map(|music_brainz_id| {
                ["musicBrainzId".to_string(), music_brainz_id.to_string()].join(",")
            }),
            // Skipping genres in query parameter serialization

            // Skipping artists in query parameter serialization
            self.display_artist.as_ref().map(|display_artist| {
                ["displayArtist".to_string(), display_artist.to_string()].join(",")
            }),
            self.release_types.as_ref().map(|release_types| {
                [
                    "releaseTypes".to_string(),
                    release_types
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.moods.as_ref().map(|moods| {
                [
                    "moods".to_string(),
                    moods
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.sort_name
                .as_ref()
                .map(|sort_name| ["sortName".to_string(), sort_name.to_string()].join(",")),
            // Skipping originalReleaseDate in query parameter serialization

            // Skipping releaseDate in query parameter serialization
            self.is_compilation.as_ref().map(|is_compilation| {
                ["isCompilation".to_string(), is_compilation.to_string()].join(",")
            }),
            // Skipping explicitStatus in query parameter serialization

            // Skipping discTitles in query parameter serialization

            // Skipping song in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AlbumId3WithSongs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AlbumId3WithSongs {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub version: Vec<String>,
            pub artist: Vec<String>,
            pub artist_id: Vec<String>,
            pub cover_art: Vec<String>,
            pub song_count: Vec<i32>,
            pub duration: Vec<i32>,
            pub play_count: Vec<i32>,
            pub created: Vec<chrono::DateTime<chrono::Utc>>,
            pub starred: Vec<chrono::DateTime<chrono::Utc>>,
            pub year: Vec<i32>,
            pub genre: Vec<String>,
            pub played: Vec<chrono::DateTime<chrono::Utc>>,
            pub user_rating: Vec<u8>,
            pub record_labels: Vec<Vec<models::RecordLabel>>,
            pub music_brainz_id: Vec<String>,
            pub genres: Vec<Vec<models::ItemGenre>>,
            pub artists: Vec<Vec<models::ArtistId3>>,
            pub display_artist: Vec<String>,
            pub release_types: Vec<Vec<String>>,
            pub moods: Vec<Vec<String>>,
            pub sort_name: Vec<String>,
            pub original_release_date: Vec<models::ItemDate>,
            pub release_date: Vec<models::ItemDate>,
            pub is_compilation: Vec<bool>,
            pub explicit_status: Vec<models::ExplicitStatus>,
            pub disc_titles: Vec<Vec<models::DiscTitle>>,
            pub song: Vec<Vec<models::Child>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AlbumId3WithSongs".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artist" => intermediate_rep.artist.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artistId" => intermediate_rep.artist_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "coverArt" => intermediate_rep.cover_art.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "songCount" => intermediate_rep.song_count.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "duration" => intermediate_rep.duration.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "playCount" => intermediate_rep.play_count.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "starred" => intermediate_rep.starred.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "year" => intermediate_rep.year.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "genre" => intermediate_rep.genre.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "played" => intermediate_rep.played.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "userRating" => intermediate_rep
                        .user_rating
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "recordLabels" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in AlbumId3WithSongs"
                            .to_string(),
                    ),
                    #[allow(clippy::redundant_clone)]
                    "musicBrainzId" => intermediate_rep.music_brainz_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "genres" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in AlbumId3WithSongs"
                            .to_string(),
                    ),
                    "artists" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in AlbumId3WithSongs"
                            .to_string(),
                    ),
                    #[allow(clippy::redundant_clone)]
                    "displayArtist" => intermediate_rep.display_artist.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "releaseTypes" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in AlbumId3WithSongs"
                            .to_string(),
                    ),
                    "moods" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in AlbumId3WithSongs"
                            .to_string(),
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sortName" => intermediate_rep.sort_name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "originalReleaseDate" => intermediate_rep.original_release_date.push(
                        <models::ItemDate as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "releaseDate" => intermediate_rep.release_date.push(
                        <models::ItemDate as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "isCompilation" => intermediate_rep.is_compilation.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "explicitStatus" => intermediate_rep.explicit_status.push(
                        <models::ExplicitStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "discTitles" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in AlbumId3WithSongs"
                            .to_string(),
                    ),
                    "song" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in AlbumId3WithSongs"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AlbumId3WithSongs".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AlbumId3WithSongs {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in AlbumId3WithSongs".to_string())?,
            name: intermediate_rep
                .name
                .into_iter()
                .next()
                .ok_or_else(|| "name missing in AlbumId3WithSongs".to_string())?,
            version: intermediate_rep.version.into_iter().next(),
            artist: intermediate_rep.artist.into_iter().next(),
            artist_id: intermediate_rep.artist_id.into_iter().next(),
            cover_art: intermediate_rep.cover_art.into_iter().next(),
            song_count: intermediate_rep
                .song_count
                .into_iter()
                .next()
                .ok_or_else(|| "songCount missing in AlbumId3WithSongs".to_string())?,
            duration: intermediate_rep
                .duration
                .into_iter()
                .next()
                .ok_or_else(|| "duration missing in AlbumId3WithSongs".to_string())?,
            play_count: intermediate_rep.play_count.into_iter().next(),
            created: intermediate_rep
                .created
                .into_iter()
                .next()
                .ok_or_else(|| "created missing in AlbumId3WithSongs".to_string())?,
            starred: intermediate_rep.starred.into_iter().next(),
            year: intermediate_rep.year.into_iter().next(),
            genre: intermediate_rep.genre.into_iter().next(),
            played: intermediate_rep.played.into_iter().next(),
            user_rating: intermediate_rep.user_rating.into_iter().next(),
            record_labels: intermediate_rep.record_labels.into_iter().next(),
            music_brainz_id: intermediate_rep.music_brainz_id.into_iter().next(),
            genres: intermediate_rep.genres.into_iter().next(),
            artists: intermediate_rep.artists.into_iter().next(),
            display_artist: intermediate_rep.display_artist.into_iter().next(),
            release_types: intermediate_rep.release_types.into_iter().next(),
            moods: intermediate_rep.moods.into_iter().next(),
            sort_name: intermediate_rep.sort_name.into_iter().next(),
            original_release_date: intermediate_rep.original_release_date.into_iter().next(),
            release_date: intermediate_rep.release_date.into_iter().next(),
            is_compilation: intermediate_rep.is_compilation.into_iter().next(),
            explicit_status: intermediate_rep.explicit_status.into_iter().next(),
            disc_titles: intermediate_rep.disc_titles.into_iter().next(),
            song: intermediate_rep
                .song
                .into_iter()
                .next()
                .ok_or_else(|| "song missing in AlbumId3WithSongs".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AlbumId3WithSongs> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AlbumId3WithSongs>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AlbumId3WithSongs>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AlbumId3WithSongs - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AlbumId3WithSongs> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AlbumId3WithSongs as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AlbumId3WithSongs - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Album info.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AlbumInfo {
    /// Album notes
    #[serde(rename = "notes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notes: Option<String>,

    /// Album musicBrainzId
    #[serde(rename = "musicBrainzId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_brainz_id: Option<String>,

    /// Album lastFmUrl
    #[serde(rename = "lastFmUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_fm_url: Option<String>,

    /// Album smallImageUrl
    #[serde(rename = "smallImageUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub small_image_url: Option<String>,

    /// Album mediumImageUrl
    #[serde(rename = "mediumImageUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub medium_image_url: Option<String>,

    /// Album largeImageUrl
    #[serde(rename = "largeImageUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub large_image_url: Option<String>,
}

impl AlbumInfo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AlbumInfo {
        AlbumInfo {
            notes: None,
            music_brainz_id: None,
            last_fm_url: None,
            small_image_url: None,
            medium_image_url: None,
            large_image_url: None,
        }
    }
}

/// Converts the AlbumInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AlbumInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            self.notes
                .as_ref()
                .map(|notes| ["notes".to_string(), notes.to_string()].join(",")),
            self.music_brainz_id.as_ref().map(|music_brainz_id| {
                ["musicBrainzId".to_string(), music_brainz_id.to_string()].join(",")
            }),
            self.last_fm_url
                .as_ref()
                .map(|last_fm_url| ["lastFmUrl".to_string(), last_fm_url.to_string()].join(",")),
            self.small_image_url.as_ref().map(|small_image_url| {
                ["smallImageUrl".to_string(), small_image_url.to_string()].join(",")
            }),
            self.medium_image_url.as_ref().map(|medium_image_url| {
                ["mediumImageUrl".to_string(), medium_image_url.to_string()].join(",")
            }),
            self.large_image_url.as_ref().map(|large_image_url| {
                ["largeImageUrl".to_string(), large_image_url.to_string()].join(",")
            }),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AlbumInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AlbumInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub notes: Vec<String>,
            pub music_brainz_id: Vec<String>,
            pub last_fm_url: Vec<String>,
            pub small_image_url: Vec<String>,
            pub medium_image_url: Vec<String>,
            pub large_image_url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AlbumInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "notes" => intermediate_rep.notes.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "musicBrainzId" => intermediate_rep.music_brainz_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "lastFmUrl" => intermediate_rep.last_fm_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "smallImageUrl" => intermediate_rep.small_image_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "mediumImageUrl" => intermediate_rep.medium_image_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "largeImageUrl" => intermediate_rep.large_image_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AlbumInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AlbumInfo {
            notes: intermediate_rep.notes.into_iter().next(),
            music_brainz_id: intermediate_rep.music_brainz_id.into_iter().next(),
            last_fm_url: intermediate_rep.last_fm_url.into_iter().next(),
            small_image_url: intermediate_rep.small_image_url.into_iter().next(),
            medium_image_url: intermediate_rep.medium_image_url.into_iter().next(),
            large_image_url: intermediate_rep.large_image_url.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AlbumInfo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AlbumInfo>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AlbumInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AlbumInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AlbumInfo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AlbumInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AlbumInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Album list.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AlbumList {
    /// Artist albums
    #[serde(rename = "album")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album: Option<Vec<models::Child>>,
}

impl AlbumList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AlbumList {
        AlbumList { album: None }
    }
}

/// Converts the AlbumList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AlbumList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping album in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AlbumList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AlbumList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub album: Vec<Vec<models::Child>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AlbumList".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "album" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AlbumList"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AlbumList".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AlbumList {
            album: intermediate_rep.album.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AlbumList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AlbumList>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AlbumList>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AlbumList - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AlbumList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AlbumList as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AlbumList - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AlbumList2 {
    /// Artist albums
    #[serde(rename = "album")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album: Option<Vec<models::AlbumId3>>,
}

impl AlbumList2 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AlbumList2 {
        AlbumList2 { album: None }
    }
}

/// Converts the AlbumList2 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AlbumList2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping album in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AlbumList2 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AlbumList2 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub album: Vec<Vec<models::AlbumId3>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AlbumList2".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "album" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AlbumList2"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AlbumList2".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AlbumList2 {
            album: intermediate_rep.album.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AlbumList2> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AlbumList2>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AlbumList2>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AlbumList2 - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AlbumList2> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AlbumList2 as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AlbumList2 - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// The list type. Must be one of the following: random, newest, highest, frequent, recent. Since 1.8.0 you can also use alphabeticalByName or alphabeticalByArtist to page through all albums alphabetically, and starred to retrieve starred albums. Since 1.10.1 you can use byYear and byGenre to list albums in a given year range or genre.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AlbumListType {
    #[serde(rename = "random")]
    Random,
    #[serde(rename = "newest")]
    Newest,
    #[serde(rename = "highest")]
    Highest,
    #[serde(rename = "frequent")]
    Frequent,
    #[serde(rename = "recent")]
    Recent,
    #[serde(rename = "alphabeticalByName")]
    AlphabeticalByName,
    #[serde(rename = "alphabeticalByArtist")]
    AlphabeticalByArtist,
    #[serde(rename = "starred")]
    Starred,
    #[serde(rename = "byYear")]
    ByYear,
    #[serde(rename = "byGenre")]
    ByGenre,
}

impl std::fmt::Display for AlbumListType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AlbumListType::Random => write!(f, "random"),
            AlbumListType::Newest => write!(f, "newest"),
            AlbumListType::Highest => write!(f, "highest"),
            AlbumListType::Frequent => write!(f, "frequent"),
            AlbumListType::Recent => write!(f, "recent"),
            AlbumListType::AlphabeticalByName => write!(f, "alphabeticalByName"),
            AlbumListType::AlphabeticalByArtist => write!(f, "alphabeticalByArtist"),
            AlbumListType::Starred => write!(f, "starred"),
            AlbumListType::ByYear => write!(f, "byYear"),
            AlbumListType::ByGenre => write!(f, "byGenre"),
        }
    }
}

impl std::str::FromStr for AlbumListType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "random" => std::result::Result::Ok(AlbumListType::Random),
            "newest" => std::result::Result::Ok(AlbumListType::Newest),
            "highest" => std::result::Result::Ok(AlbumListType::Highest),
            "frequent" => std::result::Result::Ok(AlbumListType::Frequent),
            "recent" => std::result::Result::Ok(AlbumListType::Recent),
            "alphabeticalByName" => std::result::Result::Ok(AlbumListType::AlphabeticalByName),
            "alphabeticalByArtist" => std::result::Result::Ok(AlbumListType::AlphabeticalByArtist),
            "starred" => std::result::Result::Ok(AlbumListType::Starred),
            "byYear" => std::result::Result::Ok(AlbumListType::ByYear),
            "byGenre" => std::result::Result::Ok(AlbumListType::ByGenre),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Artist details.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Artist {
    /// Artist id
    #[serde(rename = "id")]
    pub id: String,

    /// Artist name
    #[serde(rename = "name")]
    pub name: String,

    /// Artist image url
    #[serde(rename = "artistImageUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist_image_url: Option<String>,

    /// Artist starred date [ISO 8601]
    #[serde(rename = "starred")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub starred: Option<chrono::DateTime<chrono::Utc>>,

    /// Artist rating [1-5]
    #[serde(rename = "userRating")]
    #[validate(range(min = 1u8, max = 5u8))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_rating: Option<u8>,

    /// Artist average rating [1.0-5.0]
    #[serde(rename = "averageRating")]
    #[validate(range(min = 1f64, max = 5f64))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub average_rating: Option<f64>,
}

impl Artist {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, name: String) -> Artist {
        Artist {
            id,
            name,
            artist_image_url: None,
            starred: None,
            user_rating: None,
            average_rating: None,
        }
    }
}

/// Converts the Artist value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Artist {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            Some("name".to_string()),
            Some(self.name.to_string()),
            self.artist_image_url.as_ref().map(|artist_image_url| {
                ["artistImageUrl".to_string(), artist_image_url.to_string()].join(",")
            }),
            // Skipping starred in query parameter serialization
            self.user_rating
                .as_ref()
                .map(|user_rating| ["userRating".to_string(), user_rating.to_string()].join(",")),
            self.average_rating.as_ref().map(|average_rating| {
                ["averageRating".to_string(), average_rating.to_string()].join(",")
            }),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Artist value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Artist {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub artist_image_url: Vec<String>,
            pub starred: Vec<chrono::DateTime<chrono::Utc>>,
            pub user_rating: Vec<u8>,
            pub average_rating: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Artist".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artistImageUrl" => intermediate_rep.artist_image_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "starred" => intermediate_rep.starred.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "userRating" => intermediate_rep
                        .user_rating
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "averageRating" => intermediate_rep.average_rating.push(
                        <f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Artist".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Artist {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in Artist".to_string())?,
            name: intermediate_rep
                .name
                .into_iter()
                .next()
                .ok_or_else(|| "name missing in Artist".to_string())?,
            artist_image_url: intermediate_rep.artist_image_url.into_iter().next(),
            starred: intermediate_rep.starred.into_iter().next(),
            user_rating: intermediate_rep.user_rating.into_iter().next(),
            average_rating: intermediate_rep.average_rating.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Artist> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Artist>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Artist>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Artist - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Artist> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Artist as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Artist - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// An artist from ID3 tags.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ArtistId3 {
    /// The id of the artist
    #[serde(rename = "id")]
    pub id: String,

    /// The artist name.
    #[serde(rename = "name")]
    pub name: String,

    /// A covertArt id.
    #[serde(rename = "coverArt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cover_art: Option<String>,

    /// An url to an external image source.
    #[serde(rename = "artistImageUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist_image_url: Option<String>,

    /// Artist album count.
    #[serde(rename = "albumCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album_count: Option<i32>,

    /// Date the artist was starred. [ISO 8601]
    #[serde(rename = "starred")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub starred: Option<chrono::DateTime<chrono::Utc>>,

    /// The artist MusicBrainzID.
    #[serde(rename = "musicBrainzId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_brainz_id: Option<String>,

    /// The artist sort name.
    #[serde(rename = "sortName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sort_name: Option<String>,

    /// The list of all roles this artist has in the library.
    #[serde(rename = "roles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub roles: Option<Vec<String>>,
}

impl ArtistId3 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, name: String) -> ArtistId3 {
        ArtistId3 {
            id,
            name,
            cover_art: None,
            artist_image_url: None,
            album_count: None,
            starred: None,
            music_brainz_id: None,
            sort_name: None,
            roles: None,
        }
    }
}

/// Converts the ArtistId3 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ArtistId3 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            Some("name".to_string()),
            Some(self.name.to_string()),
            self.cover_art
                .as_ref()
                .map(|cover_art| ["coverArt".to_string(), cover_art.to_string()].join(",")),
            self.artist_image_url.as_ref().map(|artist_image_url| {
                ["artistImageUrl".to_string(), artist_image_url.to_string()].join(",")
            }),
            self.album_count
                .as_ref()
                .map(|album_count| ["albumCount".to_string(), album_count.to_string()].join(",")),
            // Skipping starred in query parameter serialization
            self.music_brainz_id.as_ref().map(|music_brainz_id| {
                ["musicBrainzId".to_string(), music_brainz_id.to_string()].join(",")
            }),
            self.sort_name
                .as_ref()
                .map(|sort_name| ["sortName".to_string(), sort_name.to_string()].join(",")),
            self.roles.as_ref().map(|roles| {
                [
                    "roles".to_string(),
                    roles
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ArtistId3 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ArtistId3 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub cover_art: Vec<String>,
            pub artist_image_url: Vec<String>,
            pub album_count: Vec<i32>,
            pub starred: Vec<chrono::DateTime<chrono::Utc>>,
            pub music_brainz_id: Vec<String>,
            pub sort_name: Vec<String>,
            pub roles: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ArtistId3".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "coverArt" => intermediate_rep.cover_art.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artistImageUrl" => intermediate_rep.artist_image_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "albumCount" => intermediate_rep.album_count.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "starred" => intermediate_rep.starred.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "musicBrainzId" => intermediate_rep.music_brainz_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sortName" => intermediate_rep.sort_name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "roles" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ArtistId3"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ArtistId3".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ArtistId3 {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in ArtistId3".to_string())?,
            name: intermediate_rep
                .name
                .into_iter()
                .next()
                .ok_or_else(|| "name missing in ArtistId3".to_string())?,
            cover_art: intermediate_rep.cover_art.into_iter().next(),
            artist_image_url: intermediate_rep.artist_image_url.into_iter().next(),
            album_count: intermediate_rep.album_count.into_iter().next(),
            starred: intermediate_rep.starred.into_iter().next(),
            music_brainz_id: intermediate_rep.music_brainz_id.into_iter().next(),
            sort_name: intermediate_rep.sort_name.into_iter().next(),
            roles: intermediate_rep.roles.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ArtistId3> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ArtistId3>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ArtistId3>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ArtistId3 - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ArtistId3> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ArtistId3 as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ArtistId3 - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Artist info.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ArtistInfo {
    /// Artist biography
    #[serde(rename = "biography")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub biography: Option<String>,

    /// Artist musicBrainzId
    #[serde(rename = "musicBrainzId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_brainz_id: Option<String>,

    /// Artist lastFmUrl
    #[serde(rename = "lastFmUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_fm_url: Option<String>,

    /// Artist smallImageUrl
    #[serde(rename = "smallImageUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub small_image_url: Option<String>,

    /// Artist mediumImageUrl
    #[serde(rename = "mediumImageUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub medium_image_url: Option<String>,

    /// Artist largeImageUrl
    #[serde(rename = "largeImageUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub large_image_url: Option<String>,

    /// Similar artists
    #[serde(rename = "similarArtist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub similar_artist: Option<Vec<models::Artist>>,
}

impl ArtistInfo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ArtistInfo {
        ArtistInfo {
            biography: None,
            music_brainz_id: None,
            last_fm_url: None,
            small_image_url: None,
            medium_image_url: None,
            large_image_url: None,
            similar_artist: None,
        }
    }
}

/// Converts the ArtistInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ArtistInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            self.biography
                .as_ref()
                .map(|biography| ["biography".to_string(), biography.to_string()].join(",")),
            self.music_brainz_id.as_ref().map(|music_brainz_id| {
                ["musicBrainzId".to_string(), music_brainz_id.to_string()].join(",")
            }),
            self.last_fm_url
                .as_ref()
                .map(|last_fm_url| ["lastFmUrl".to_string(), last_fm_url.to_string()].join(",")),
            self.small_image_url.as_ref().map(|small_image_url| {
                ["smallImageUrl".to_string(), small_image_url.to_string()].join(",")
            }),
            self.medium_image_url.as_ref().map(|medium_image_url| {
                ["mediumImageUrl".to_string(), medium_image_url.to_string()].join(",")
            }),
            self.large_image_url.as_ref().map(|large_image_url| {
                ["largeImageUrl".to_string(), large_image_url.to_string()].join(",")
            }),
            // Skipping similarArtist in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ArtistInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ArtistInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub biography: Vec<String>,
            pub music_brainz_id: Vec<String>,
            pub last_fm_url: Vec<String>,
            pub small_image_url: Vec<String>,
            pub medium_image_url: Vec<String>,
            pub large_image_url: Vec<String>,
            pub similar_artist: Vec<Vec<models::Artist>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ArtistInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "biography" => intermediate_rep.biography.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "musicBrainzId" => intermediate_rep.music_brainz_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "lastFmUrl" => intermediate_rep.last_fm_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "smallImageUrl" => intermediate_rep.small_image_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "mediumImageUrl" => intermediate_rep.medium_image_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "largeImageUrl" => intermediate_rep.large_image_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "similarArtist" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ArtistInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ArtistInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ArtistInfo {
            biography: intermediate_rep.biography.into_iter().next(),
            music_brainz_id: intermediate_rep.music_brainz_id.into_iter().next(),
            last_fm_url: intermediate_rep.last_fm_url.into_iter().next(),
            small_image_url: intermediate_rep.small_image_url.into_iter().next(),
            medium_image_url: intermediate_rep.medium_image_url.into_iter().next(),
            large_image_url: intermediate_rep.large_image_url.into_iter().next(),
            similar_artist: intermediate_rep.similar_artist.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ArtistInfo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ArtistInfo>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ArtistInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ArtistInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ArtistInfo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ArtistInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ArtistInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Artist info.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ArtistInfo2 {
    /// Artist biography
    #[serde(rename = "biography")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub biography: Option<String>,

    /// Artist musicBrainzId
    #[serde(rename = "musicBrainzId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_brainz_id: Option<String>,

    /// Artist lastFmUrl
    #[serde(rename = "lastFmUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_fm_url: Option<String>,

    /// Artist smallImageUrl
    #[serde(rename = "smallImageUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub small_image_url: Option<String>,

    /// Artist mediumImageUrl
    #[serde(rename = "mediumImageUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub medium_image_url: Option<String>,

    /// Artist largeImageUrl
    #[serde(rename = "largeImageUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub large_image_url: Option<String>,

    /// Similar artists
    #[serde(rename = "similarArtist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub similar_artist: Option<Vec<models::ArtistId3>>,
}

impl ArtistInfo2 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ArtistInfo2 {
        ArtistInfo2 {
            biography: None,
            music_brainz_id: None,
            last_fm_url: None,
            small_image_url: None,
            medium_image_url: None,
            large_image_url: None,
            similar_artist: None,
        }
    }
}

/// Converts the ArtistInfo2 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ArtistInfo2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            self.biography
                .as_ref()
                .map(|biography| ["biography".to_string(), biography.to_string()].join(",")),
            self.music_brainz_id.as_ref().map(|music_brainz_id| {
                ["musicBrainzId".to_string(), music_brainz_id.to_string()].join(",")
            }),
            self.last_fm_url
                .as_ref()
                .map(|last_fm_url| ["lastFmUrl".to_string(), last_fm_url.to_string()].join(",")),
            self.small_image_url.as_ref().map(|small_image_url| {
                ["smallImageUrl".to_string(), small_image_url.to_string()].join(",")
            }),
            self.medium_image_url.as_ref().map(|medium_image_url| {
                ["mediumImageUrl".to_string(), medium_image_url.to_string()].join(",")
            }),
            self.large_image_url.as_ref().map(|large_image_url| {
                ["largeImageUrl".to_string(), large_image_url.to_string()].join(",")
            }),
            // Skipping similarArtist in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ArtistInfo2 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ArtistInfo2 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub biography: Vec<String>,
            pub music_brainz_id: Vec<String>,
            pub last_fm_url: Vec<String>,
            pub small_image_url: Vec<String>,
            pub medium_image_url: Vec<String>,
            pub large_image_url: Vec<String>,
            pub similar_artist: Vec<Vec<models::ArtistId3>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ArtistInfo2".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "biography" => intermediate_rep.biography.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "musicBrainzId" => intermediate_rep.music_brainz_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "lastFmUrl" => intermediate_rep.last_fm_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "smallImageUrl" => intermediate_rep.small_image_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "mediumImageUrl" => intermediate_rep.medium_image_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "largeImageUrl" => intermediate_rep.large_image_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "similarArtist" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ArtistInfo2"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ArtistInfo2".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ArtistInfo2 {
            biography: intermediate_rep.biography.into_iter().next(),
            music_brainz_id: intermediate_rep.music_brainz_id.into_iter().next(),
            last_fm_url: intermediate_rep.last_fm_url.into_iter().next(),
            small_image_url: intermediate_rep.small_image_url.into_iter().next(),
            medium_image_url: intermediate_rep.medium_image_url.into_iter().next(),
            large_image_url: intermediate_rep.large_image_url.into_iter().next(),
            similar_artist: intermediate_rep.similar_artist.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ArtistInfo2> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ArtistInfo2>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ArtistInfo2>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ArtistInfo2 - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ArtistInfo2> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ArtistInfo2 as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ArtistInfo2 - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ArtistWithAlbumsId3 {
    /// The id of the artist
    #[serde(rename = "id")]
    pub id: String,

    /// The artist name.
    #[serde(rename = "name")]
    pub name: String,

    /// A covertArt id.
    #[serde(rename = "coverArt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cover_art: Option<String>,

    /// An url to an external image source.
    #[serde(rename = "artistImageUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist_image_url: Option<String>,

    /// Artist album count.
    #[serde(rename = "albumCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album_count: Option<i32>,

    /// Date the artist was starred. [ISO 8601]
    #[serde(rename = "starred")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub starred: Option<chrono::DateTime<chrono::Utc>>,

    /// The artist MusicBrainzID.
    #[serde(rename = "musicBrainzId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_brainz_id: Option<String>,

    /// The artist sort name.
    #[serde(rename = "sortName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sort_name: Option<String>,

    /// The list of all roles this artist has in the library.
    #[serde(rename = "roles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub roles: Option<Vec<String>>,

    /// Artist albums
    #[serde(rename = "album")]
    pub album: Vec<models::AlbumId3>,
}

impl ArtistWithAlbumsId3 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, name: String, album: Vec<models::AlbumId3>) -> ArtistWithAlbumsId3 {
        ArtistWithAlbumsId3 {
            id,
            name,
            cover_art: None,
            artist_image_url: None,
            album_count: None,
            starred: None,
            music_brainz_id: None,
            sort_name: None,
            roles: None,
            album,
        }
    }
}

/// Converts the ArtistWithAlbumsId3 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ArtistWithAlbumsId3 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            Some("name".to_string()),
            Some(self.name.to_string()),
            self.cover_art
                .as_ref()
                .map(|cover_art| ["coverArt".to_string(), cover_art.to_string()].join(",")),
            self.artist_image_url.as_ref().map(|artist_image_url| {
                ["artistImageUrl".to_string(), artist_image_url.to_string()].join(",")
            }),
            self.album_count
                .as_ref()
                .map(|album_count| ["albumCount".to_string(), album_count.to_string()].join(",")),
            // Skipping starred in query parameter serialization
            self.music_brainz_id.as_ref().map(|music_brainz_id| {
                ["musicBrainzId".to_string(), music_brainz_id.to_string()].join(",")
            }),
            self.sort_name
                .as_ref()
                .map(|sort_name| ["sortName".to_string(), sort_name.to_string()].join(",")),
            self.roles.as_ref().map(|roles| {
                [
                    "roles".to_string(),
                    roles
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping album in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ArtistWithAlbumsId3 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ArtistWithAlbumsId3 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub cover_art: Vec<String>,
            pub artist_image_url: Vec<String>,
            pub album_count: Vec<i32>,
            pub starred: Vec<chrono::DateTime<chrono::Utc>>,
            pub music_brainz_id: Vec<String>,
            pub sort_name: Vec<String>,
            pub roles: Vec<Vec<String>>,
            pub album: Vec<Vec<models::AlbumId3>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ArtistWithAlbumsId3".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "coverArt" => intermediate_rep.cover_art.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artistImageUrl" => intermediate_rep.artist_image_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "albumCount" => intermediate_rep.album_count.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "starred" => intermediate_rep.starred.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "musicBrainzId" => intermediate_rep.music_brainz_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sortName" => intermediate_rep.sort_name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "roles" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in ArtistWithAlbumsId3"
                            .to_string(),
                    ),
                    "album" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in ArtistWithAlbumsId3"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ArtistWithAlbumsId3".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ArtistWithAlbumsId3 {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in ArtistWithAlbumsId3".to_string())?,
            name: intermediate_rep
                .name
                .into_iter()
                .next()
                .ok_or_else(|| "name missing in ArtistWithAlbumsId3".to_string())?,
            cover_art: intermediate_rep.cover_art.into_iter().next(),
            artist_image_url: intermediate_rep.artist_image_url.into_iter().next(),
            album_count: intermediate_rep.album_count.into_iter().next(),
            starred: intermediate_rep.starred.into_iter().next(),
            music_brainz_id: intermediate_rep.music_brainz_id.into_iter().next(),
            sort_name: intermediate_rep.sort_name.into_iter().next(),
            roles: intermediate_rep.roles.into_iter().next(),
            album: intermediate_rep
                .album
                .into_iter()
                .next()
                .ok_or_else(|| "album missing in ArtistWithAlbumsId3".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ArtistWithAlbumsId3> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ArtistWithAlbumsId3>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ArtistWithAlbumsId3>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ArtistWithAlbumsId3 - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ArtistWithAlbumsId3> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ArtistWithAlbumsId3 as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ArtistWithAlbumsId3 - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A list of indexed Artists.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ArtistsId3 {
    /// List of ignored articles space separated
    #[serde(rename = "ignoredArticles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ignored_articles: Option<String>,

    /// Index list
    #[serde(rename = "index")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index: Option<Vec<models::ArtistId3>>,
}

impl ArtistsId3 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ArtistsId3 {
        ArtistsId3 {
            ignored_articles: None,
            index: None,
        }
    }
}

/// Converts the ArtistsId3 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ArtistsId3 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            self.ignored_articles.as_ref().map(|ignored_articles| {
                ["ignoredArticles".to_string(), ignored_articles.to_string()].join(",")
            }),
            // Skipping index in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ArtistsId3 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ArtistsId3 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ignored_articles: Vec<String>,
            pub index: Vec<Vec<models::ArtistId3>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ArtistsId3".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ignoredArticles" => intermediate_rep.ignored_articles.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "index" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ArtistsId3"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ArtistsId3".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ArtistsId3 {
            ignored_articles: intermediate_rep.ignored_articles.into_iter().next(),
            index: intermediate_rep.index.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ArtistsId3> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ArtistsId3>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ArtistsId3>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ArtistsId3 - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ArtistsId3> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ArtistsId3 as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ArtistsId3 - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A bookmark.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Bookmark {
    /// Bookmark position in seconds
    #[serde(rename = "position")]
    pub position: i32,

    /// Username
    #[serde(rename = "username")]
    pub username: String,

    /// Bookmark comment
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,

    /// Bookmark creation date [ISO 8601]
    #[serde(rename = "created")]
    pub created: chrono::DateTime<chrono::Utc>,

    /// Bookmark last updated date [ISO 8601]
    #[serde(rename = "changed")]
    pub changed: chrono::DateTime<chrono::Utc>,

    /// The bookmark file
    #[serde(rename = "entry")]
    pub entry: models::Child,
}

impl Bookmark {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        position: i32,
        username: String,
        created: chrono::DateTime<chrono::Utc>,
        changed: chrono::DateTime<chrono::Utc>,
        entry: models::Child,
    ) -> Bookmark {
        Bookmark {
            position,
            username,
            comment: None,
            created,
            changed,
            entry,
        }
    }
}

/// Converts the Bookmark value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Bookmark {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("position".to_string()),
            Some(self.position.to_string()),
            Some("username".to_string()),
            Some(self.username.to_string()),
            self.comment
                .as_ref()
                .map(|comment| ["comment".to_string(), comment.to_string()].join(",")),
            // Skipping created in query parameter serialization

            // Skipping changed in query parameter serialization

            // Skipping entry in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Bookmark value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Bookmark {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub position: Vec<i32>,
            pub username: Vec<String>,
            pub comment: Vec<String>,
            pub created: Vec<chrono::DateTime<chrono::Utc>>,
            pub changed: Vec<chrono::DateTime<chrono::Utc>>,
            pub entry: Vec<models::Child>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Bookmark".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "position" => intermediate_rep.position.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "comment" => intermediate_rep.comment.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "changed" => intermediate_rep.changed.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "entry" => intermediate_rep.entry.push(
                        <models::Child as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Bookmark".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Bookmark {
            position: intermediate_rep
                .position
                .into_iter()
                .next()
                .ok_or_else(|| "position missing in Bookmark".to_string())?,
            username: intermediate_rep
                .username
                .into_iter()
                .next()
                .ok_or_else(|| "username missing in Bookmark".to_string())?,
            comment: intermediate_rep.comment.into_iter().next(),
            created: intermediate_rep
                .created
                .into_iter()
                .next()
                .ok_or_else(|| "created missing in Bookmark".to_string())?,
            changed: intermediate_rep
                .changed
                .into_iter()
                .next()
                .ok_or_else(|| "changed missing in Bookmark".to_string())?,
            entry: intermediate_rep
                .entry
                .into_iter()
                .next()
                .ok_or_else(|| "entry missing in Bookmark".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Bookmark> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Bookmark>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Bookmark>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Bookmark - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Bookmark> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Bookmark as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Bookmark - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Bookmarks list.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Bookmarks {
    /// List of bookmark
    #[serde(rename = "bookmark")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bookmark: Option<Vec<models::Bookmark>>,
}

impl Bookmarks {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Bookmarks {
        Bookmarks { bookmark: None }
    }
}

/// Converts the Bookmarks value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Bookmarks {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping bookmark in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Bookmarks value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Bookmarks {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub bookmark: Vec<Vec<models::Bookmark>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Bookmarks".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "bookmark" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Bookmarks"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Bookmarks".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Bookmarks {
            bookmark: intermediate_rep.bookmark.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Bookmarks> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Bookmarks>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Bookmarks>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Bookmarks - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Bookmarks> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Bookmarks as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Bookmarks - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A chatMessage.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatMessage {
    /// Username
    #[serde(rename = "username")]
    pub username: String,

    /// Time in millis since Jan 1 1970
    #[serde(rename = "time")]
    pub time: i32,

    /// The message
    #[serde(rename = "message")]
    pub message: String,
}

impl ChatMessage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(username: String, time: i32, message: String) -> ChatMessage {
        ChatMessage {
            username,
            time,
            message,
        }
    }
}

/// Converts the ChatMessage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("username".to_string()),
            Some(self.username.to_string()),
            Some("time".to_string()),
            Some(self.time.to_string()),
            Some("message".to_string()),
            Some(self.message.to_string()),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatMessage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatMessage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub username: Vec<String>,
            pub time: Vec<i32>,
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ChatMessage".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "time" => intermediate_rep.time.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ChatMessage".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatMessage {
            username: intermediate_rep
                .username
                .into_iter()
                .next()
                .ok_or_else(|| "username missing in ChatMessage".to_string())?,
            time: intermediate_rep
                .time
                .into_iter()
                .next()
                .ok_or_else(|| "time missing in ChatMessage".to_string())?,
            message: intermediate_rep
                .message
                .into_iter()
                .next()
                .ok_or_else(|| "message missing in ChatMessage".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatMessage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatMessage>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ChatMessage>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ChatMessage - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatMessage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ChatMessage as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ChatMessage - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Chat messages list.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatMessages {
    /// List of chatMessage
    #[serde(rename = "chatMessage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub chat_message: Option<Vec<models::ChatMessage>>,
}

impl ChatMessages {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ChatMessages {
        ChatMessages { chat_message: None }
    }
}

/// Converts the ChatMessages value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatMessages {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping chatMessage in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatMessages value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatMessages {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub chat_message: Vec<Vec<models::ChatMessage>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ChatMessages".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "chatMessage" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ChatMessages"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ChatMessages".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatMessages {
            chat_message: intermediate_rep.chat_message.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatMessages> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatMessages>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ChatMessages>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ChatMessages - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatMessages> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ChatMessages as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ChatMessages - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A media.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Child {
    /// The id of the media.
    #[serde(rename = "id")]
    pub id: String,

    /// The id of the parent (folder/album)
    #[serde(rename = "parent")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent: Option<String>,

    /// The media is a directory
    #[serde(rename = "isDir")]
    pub is_dir: bool,

    /// The media name.
    #[serde(rename = "title")]
    pub title: String,

    /// The album name.
    #[serde(rename = "album")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album: Option<String>,

    /// The artist name.
    #[serde(rename = "artist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist: Option<String>,

    /// The track number.
    #[serde(rename = "track")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub track: Option<i32>,

    /// The media year.
    #[serde(rename = "year")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub year: Option<i32>,

    /// The media genre
    #[serde(rename = "genre")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub genre: Option<String>,

    /// The coverArt id.
    #[serde(rename = "coverArt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cover_art: Option<String>,

    /// A file size of the media.
    #[serde(rename = "size")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<i32>,

    /// The mimeType of the media.
    #[serde(rename = "contentType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content_type: Option<String>,

    /// The file suffix of the media.
    #[serde(rename = "suffix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suffix: Option<String>,

    /// The transcoded mediaType if transcoding should happen.
    #[serde(rename = "transcodedContentType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transcoded_content_type: Option<String>,

    /// The file suffix of the transcoded media.
    #[serde(rename = "transcodedSuffix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transcoded_suffix: Option<String>,

    /// The duration of the media in seconds.
    #[serde(rename = "duration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub duration: Option<i32>,

    /// The bitrate of the media.
    #[serde(rename = "bitRate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bit_rate: Option<i32>,

    /// The bit depth of the media.
    #[serde(rename = "bitDepth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bit_depth: Option<i32>,

    /// The sampling rate of the media.
    #[serde(rename = "samplingRate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sampling_rate: Option<i32>,

    /// The number of channels of the media.
    #[serde(rename = "channelCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel_count: Option<i32>,

    /// The full path of the media.
    #[serde(rename = "path")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,

    /// Media is a video
    #[serde(rename = "isVideo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_video: Option<bool>,

    /// The user rating of the media [1-5]
    #[serde(rename = "userRating")]
    #[validate(range(min = 1u8, max = 5u8))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_rating: Option<u8>,

    /// The average rating of the media [1.0-5.0]
    #[serde(rename = "averageRating")]
    #[validate(range(min = 0f64, max = 5f64))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub average_rating: Option<f64>,

    /// The play count.
    #[serde(rename = "playCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub play_count: Option<i32>,

    /// The disc number.
    #[serde(rename = "discNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disc_number: Option<i32>,

    /// Date the media was created. [ISO 8601]
    #[serde(rename = "created")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created: Option<chrono::DateTime<chrono::Utc>>,

    /// Date the media was starred. [ISO 8601]
    #[serde(rename = "starred")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub starred: Option<chrono::DateTime<chrono::Utc>>,

    /// The corresponding album id
    #[serde(rename = "albumId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album_id: Option<String>,

    /// The corresponding artist id
    #[serde(rename = "artistId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist_id: Option<String>,

    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub r#type: Option<models::GenericMediaType>,

    #[serde(rename = "mediaType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub media_type: Option<models::MediaType>,

    /// The bookmark position in seconds
    #[serde(rename = "bookmarkPosition")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bookmark_position: Option<i32>,

    /// The video original Width
    #[serde(rename = "originalWidth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub original_width: Option<i32>,

    /// The video original Height
    #[serde(rename = "originalHeight")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub original_height: Option<i32>,

    /// Date the album was last played. [ISO 8601]
    #[serde(rename = "played")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub played: Option<chrono::DateTime<chrono::Utc>>,

    /// The BPM of the song.
    #[serde(rename = "bpm")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bpm: Option<i32>,

    /// The comment tag of the song.
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,

    /// The song sort name.
    #[serde(rename = "sortName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sort_name: Option<String>,

    /// The track MusicBrainzID.
    #[serde(rename = "musicBrainzId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_brainz_id: Option<String>,

    /// The track ISRC(s).
    #[serde(rename = "isrc")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub isrc: Option<Vec<String>>,

    /// The list of all genres of the song.
    #[serde(rename = "genres")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub genres: Option<Vec<models::ItemGenre>>,

    /// The list of all song artists of the song. (Note: Only the required `ArtistID3` fields should be returned by default)
    #[serde(rename = "artists")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artists: Option<Vec<models::ArtistId3>>,

    /// The single value display artist.
    #[serde(rename = "displayArtist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display_artist: Option<String>,

    /// The list of all album artists of the song. (Note: Only the required `ArtistID3` fields should be returned by default)
    #[serde(rename = "albumArtists")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album_artists: Option<Vec<models::ArtistId3>>,

    /// The single value display album artist.
    #[serde(rename = "displayAlbumArtist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display_album_artist: Option<String>,

    /// The list of all contributor artists of the song.
    #[serde(rename = "contributors")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contributors: Option<Vec<models::Contributor>>,

    /// The single value display composer.
    #[serde(rename = "displayComposer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display_composer: Option<String>,

    /// The list of all moods of the song.
    #[serde(rename = "moods")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moods: Option<Vec<String>>,

    /// The replay gain data of the song.
    #[serde(rename = "replayGain")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replay_gain: Option<models::ReplayGain>,

    #[serde(rename = "explicitStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub explicit_status: Option<models::ExplicitStatus>,
}

impl Child {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, is_dir: bool, title: String) -> Child {
        Child {
            id,
            parent: None,
            is_dir,
            title,
            album: None,
            artist: None,
            track: None,
            year: None,
            genre: None,
            cover_art: None,
            size: None,
            content_type: None,
            suffix: None,
            transcoded_content_type: None,
            transcoded_suffix: None,
            duration: None,
            bit_rate: None,
            bit_depth: None,
            sampling_rate: None,
            channel_count: None,
            path: None,
            is_video: None,
            user_rating: None,
            average_rating: None,
            play_count: None,
            disc_number: None,
            created: None,
            starred: None,
            album_id: None,
            artist_id: None,
            r#type: None,
            media_type: None,
            bookmark_position: None,
            original_width: None,
            original_height: None,
            played: None,
            bpm: None,
            comment: None,
            sort_name: None,
            music_brainz_id: None,
            isrc: None,
            genres: None,
            artists: None,
            display_artist: None,
            album_artists: None,
            display_album_artist: None,
            contributors: None,
            display_composer: None,
            moods: None,
            replay_gain: None,
            explicit_status: None,
        }
    }
}

/// Converts the Child value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Child {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            self.parent
                .as_ref()
                .map(|parent| ["parent".to_string(), parent.to_string()].join(",")),
            Some("isDir".to_string()),
            Some(self.is_dir.to_string()),
            Some("title".to_string()),
            Some(self.title.to_string()),
            self.album
                .as_ref()
                .map(|album| ["album".to_string(), album.to_string()].join(",")),
            self.artist
                .as_ref()
                .map(|artist| ["artist".to_string(), artist.to_string()].join(",")),
            self.track
                .as_ref()
                .map(|track| ["track".to_string(), track.to_string()].join(",")),
            self.year
                .as_ref()
                .map(|year| ["year".to_string(), year.to_string()].join(",")),
            self.genre
                .as_ref()
                .map(|genre| ["genre".to_string(), genre.to_string()].join(",")),
            self.cover_art
                .as_ref()
                .map(|cover_art| ["coverArt".to_string(), cover_art.to_string()].join(",")),
            self.size
                .as_ref()
                .map(|size| ["size".to_string(), size.to_string()].join(",")),
            self.content_type.as_ref().map(|content_type| {
                ["contentType".to_string(), content_type.to_string()].join(",")
            }),
            self.suffix
                .as_ref()
                .map(|suffix| ["suffix".to_string(), suffix.to_string()].join(",")),
            self.transcoded_content_type
                .as_ref()
                .map(|transcoded_content_type| {
                    [
                        "transcodedContentType".to_string(),
                        transcoded_content_type.to_string(),
                    ]
                    .join(",")
                }),
            self.transcoded_suffix.as_ref().map(|transcoded_suffix| {
                [
                    "transcodedSuffix".to_string(),
                    transcoded_suffix.to_string(),
                ]
                .join(",")
            }),
            self.duration
                .as_ref()
                .map(|duration| ["duration".to_string(), duration.to_string()].join(",")),
            self.bit_rate
                .as_ref()
                .map(|bit_rate| ["bitRate".to_string(), bit_rate.to_string()].join(",")),
            self.bit_depth
                .as_ref()
                .map(|bit_depth| ["bitDepth".to_string(), bit_depth.to_string()].join(",")),
            self.sampling_rate.as_ref().map(|sampling_rate| {
                ["samplingRate".to_string(), sampling_rate.to_string()].join(",")
            }),
            self.channel_count.as_ref().map(|channel_count| {
                ["channelCount".to_string(), channel_count.to_string()].join(",")
            }),
            self.path
                .as_ref()
                .map(|path| ["path".to_string(), path.to_string()].join(",")),
            self.is_video
                .as_ref()
                .map(|is_video| ["isVideo".to_string(), is_video.to_string()].join(",")),
            self.user_rating
                .as_ref()
                .map(|user_rating| ["userRating".to_string(), user_rating.to_string()].join(",")),
            self.average_rating.as_ref().map(|average_rating| {
                ["averageRating".to_string(), average_rating.to_string()].join(",")
            }),
            self.play_count
                .as_ref()
                .map(|play_count| ["playCount".to_string(), play_count.to_string()].join(",")),
            self.disc_number
                .as_ref()
                .map(|disc_number| ["discNumber".to_string(), disc_number.to_string()].join(",")),
            // Skipping created in query parameter serialization

            // Skipping starred in query parameter serialization
            self.album_id
                .as_ref()
                .map(|album_id| ["albumId".to_string(), album_id.to_string()].join(",")),
            self.artist_id
                .as_ref()
                .map(|artist_id| ["artistId".to_string(), artist_id.to_string()].join(",")),
            // Skipping type in query parameter serialization

            // Skipping mediaType in query parameter serialization
            self.bookmark_position.as_ref().map(|bookmark_position| {
                [
                    "bookmarkPosition".to_string(),
                    bookmark_position.to_string(),
                ]
                .join(",")
            }),
            self.original_width.as_ref().map(|original_width| {
                ["originalWidth".to_string(), original_width.to_string()].join(",")
            }),
            self.original_height.as_ref().map(|original_height| {
                ["originalHeight".to_string(), original_height.to_string()].join(",")
            }),
            // Skipping played in query parameter serialization
            self.bpm
                .as_ref()
                .map(|bpm| ["bpm".to_string(), bpm.to_string()].join(",")),
            self.comment
                .as_ref()
                .map(|comment| ["comment".to_string(), comment.to_string()].join(",")),
            self.sort_name
                .as_ref()
                .map(|sort_name| ["sortName".to_string(), sort_name.to_string()].join(",")),
            self.music_brainz_id.as_ref().map(|music_brainz_id| {
                ["musicBrainzId".to_string(), music_brainz_id.to_string()].join(",")
            }),
            self.isrc.as_ref().map(|isrc| {
                [
                    "isrc".to_string(),
                    isrc.iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping genres in query parameter serialization

            // Skipping artists in query parameter serialization
            self.display_artist.as_ref().map(|display_artist| {
                ["displayArtist".to_string(), display_artist.to_string()].join(",")
            }),
            // Skipping albumArtists in query parameter serialization
            self.display_album_artist
                .as_ref()
                .map(|display_album_artist| {
                    [
                        "displayAlbumArtist".to_string(),
                        display_album_artist.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping contributors in query parameter serialization
            self.display_composer.as_ref().map(|display_composer| {
                ["displayComposer".to_string(), display_composer.to_string()].join(",")
            }),
            self.moods.as_ref().map(|moods| {
                [
                    "moods".to_string(),
                    moods
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping replayGain in query parameter serialization

            // Skipping explicitStatus in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Child value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Child {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub parent: Vec<String>,
            pub is_dir: Vec<bool>,
            pub title: Vec<String>,
            pub album: Vec<String>,
            pub artist: Vec<String>,
            pub track: Vec<i32>,
            pub year: Vec<i32>,
            pub genre: Vec<String>,
            pub cover_art: Vec<String>,
            pub size: Vec<i32>,
            pub content_type: Vec<String>,
            pub suffix: Vec<String>,
            pub transcoded_content_type: Vec<String>,
            pub transcoded_suffix: Vec<String>,
            pub duration: Vec<i32>,
            pub bit_rate: Vec<i32>,
            pub bit_depth: Vec<i32>,
            pub sampling_rate: Vec<i32>,
            pub channel_count: Vec<i32>,
            pub path: Vec<String>,
            pub is_video: Vec<bool>,
            pub user_rating: Vec<u8>,
            pub average_rating: Vec<f64>,
            pub play_count: Vec<i32>,
            pub disc_number: Vec<i32>,
            pub created: Vec<chrono::DateTime<chrono::Utc>>,
            pub starred: Vec<chrono::DateTime<chrono::Utc>>,
            pub album_id: Vec<String>,
            pub artist_id: Vec<String>,
            pub r#type: Vec<models::GenericMediaType>,
            pub media_type: Vec<models::MediaType>,
            pub bookmark_position: Vec<i32>,
            pub original_width: Vec<i32>,
            pub original_height: Vec<i32>,
            pub played: Vec<chrono::DateTime<chrono::Utc>>,
            pub bpm: Vec<i32>,
            pub comment: Vec<String>,
            pub sort_name: Vec<String>,
            pub music_brainz_id: Vec<String>,
            pub isrc: Vec<Vec<String>>,
            pub genres: Vec<Vec<models::ItemGenre>>,
            pub artists: Vec<Vec<models::ArtistId3>>,
            pub display_artist: Vec<String>,
            pub album_artists: Vec<Vec<models::ArtistId3>>,
            pub display_album_artist: Vec<String>,
            pub contributors: Vec<Vec<models::Contributor>>,
            pub display_composer: Vec<String>,
            pub moods: Vec<Vec<String>>,
            pub replay_gain: Vec<models::ReplayGain>,
            pub explicit_status: Vec<models::ExplicitStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Child".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "parent" => intermediate_rep.parent.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "isDir" => intermediate_rep.is_dir.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "album" => intermediate_rep.album.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artist" => intermediate_rep.artist.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "track" => intermediate_rep.track.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "year" => intermediate_rep.year.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "genre" => intermediate_rep.genre.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "coverArt" => intermediate_rep.cover_art.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "size" => intermediate_rep.size.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "contentType" => intermediate_rep.content_type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "suffix" => intermediate_rep.suffix.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "transcodedContentType" => intermediate_rep.transcoded_content_type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "transcodedSuffix" => intermediate_rep.transcoded_suffix.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "duration" => intermediate_rep.duration.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "bitRate" => intermediate_rep.bit_rate.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "bitDepth" => intermediate_rep.bit_depth.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "samplingRate" => intermediate_rep.sampling_rate.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "channelCount" => intermediate_rep.channel_count.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "isVideo" => intermediate_rep.is_video.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "userRating" => intermediate_rep
                        .user_rating
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "averageRating" => intermediate_rep.average_rating.push(
                        <f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "playCount" => intermediate_rep.play_count.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "discNumber" => intermediate_rep.disc_number.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "starred" => intermediate_rep.starred.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "albumId" => intermediate_rep.album_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artistId" => intermediate_rep.artist_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <models::GenericMediaType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "mediaType" => intermediate_rep.media_type.push(
                        <models::MediaType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "bookmarkPosition" => intermediate_rep.bookmark_position.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "originalWidth" => intermediate_rep.original_width.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "originalHeight" => intermediate_rep.original_height.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "played" => intermediate_rep.played.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "bpm" => intermediate_rep.bpm.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "comment" => intermediate_rep.comment.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sortName" => intermediate_rep.sort_name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "musicBrainzId" => intermediate_rep.music_brainz_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "isrc" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Child"
                                .to_string(),
                        )
                    }
                    "genres" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Child"
                                .to_string(),
                        )
                    }
                    "artists" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Child"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "displayArtist" => intermediate_rep.display_artist.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "albumArtists" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Child"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "displayAlbumArtist" => intermediate_rep.display_album_artist.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "contributors" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Child"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "displayComposer" => intermediate_rep.display_composer.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "moods" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Child"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "replayGain" => intermediate_rep.replay_gain.push(
                        <models::ReplayGain as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "explicitStatus" => intermediate_rep.explicit_status.push(
                        <models::ExplicitStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Child".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Child {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in Child".to_string())?,
            parent: intermediate_rep.parent.into_iter().next(),
            is_dir: intermediate_rep
                .is_dir
                .into_iter()
                .next()
                .ok_or_else(|| "isDir missing in Child".to_string())?,
            title: intermediate_rep
                .title
                .into_iter()
                .next()
                .ok_or_else(|| "title missing in Child".to_string())?,
            album: intermediate_rep.album.into_iter().next(),
            artist: intermediate_rep.artist.into_iter().next(),
            track: intermediate_rep.track.into_iter().next(),
            year: intermediate_rep.year.into_iter().next(),
            genre: intermediate_rep.genre.into_iter().next(),
            cover_art: intermediate_rep.cover_art.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
            content_type: intermediate_rep.content_type.into_iter().next(),
            suffix: intermediate_rep.suffix.into_iter().next(),
            transcoded_content_type: intermediate_rep.transcoded_content_type.into_iter().next(),
            transcoded_suffix: intermediate_rep.transcoded_suffix.into_iter().next(),
            duration: intermediate_rep.duration.into_iter().next(),
            bit_rate: intermediate_rep.bit_rate.into_iter().next(),
            bit_depth: intermediate_rep.bit_depth.into_iter().next(),
            sampling_rate: intermediate_rep.sampling_rate.into_iter().next(),
            channel_count: intermediate_rep.channel_count.into_iter().next(),
            path: intermediate_rep.path.into_iter().next(),
            is_video: intermediate_rep.is_video.into_iter().next(),
            user_rating: intermediate_rep.user_rating.into_iter().next(),
            average_rating: intermediate_rep.average_rating.into_iter().next(),
            play_count: intermediate_rep.play_count.into_iter().next(),
            disc_number: intermediate_rep.disc_number.into_iter().next(),
            created: intermediate_rep.created.into_iter().next(),
            starred: intermediate_rep.starred.into_iter().next(),
            album_id: intermediate_rep.album_id.into_iter().next(),
            artist_id: intermediate_rep.artist_id.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            media_type: intermediate_rep.media_type.into_iter().next(),
            bookmark_position: intermediate_rep.bookmark_position.into_iter().next(),
            original_width: intermediate_rep.original_width.into_iter().next(),
            original_height: intermediate_rep.original_height.into_iter().next(),
            played: intermediate_rep.played.into_iter().next(),
            bpm: intermediate_rep.bpm.into_iter().next(),
            comment: intermediate_rep.comment.into_iter().next(),
            sort_name: intermediate_rep.sort_name.into_iter().next(),
            music_brainz_id: intermediate_rep.music_brainz_id.into_iter().next(),
            isrc: intermediate_rep.isrc.into_iter().next(),
            genres: intermediate_rep.genres.into_iter().next(),
            artists: intermediate_rep.artists.into_iter().next(),
            display_artist: intermediate_rep.display_artist.into_iter().next(),
            album_artists: intermediate_rep.album_artists.into_iter().next(),
            display_album_artist: intermediate_rep.display_album_artist.into_iter().next(),
            contributors: intermediate_rep.contributors.into_iter().next(),
            display_composer: intermediate_rep.display_composer.into_iter().next(),
            moods: intermediate_rep.moods.into_iter().next(),
            replay_gain: intermediate_rep.replay_gain.into_iter().next(),
            explicit_status: intermediate_rep.explicit_status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Child> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Child>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Child>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Child - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Child> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Child as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Child - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A contributor artist for a song or an album
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Contributor {
    /// The contributor role.
    #[serde(rename = "role")]
    pub role: String,

    /// The subRole for roles that may require it. Ex: The instrument for the performer role (TMCL/performer tags). Note: For consistency between different tag formats, the TIPL sub roles should be directly exposed in the role field.
    #[serde(rename = "subRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sub_role: Option<String>,

    #[serde(rename = "artist")]
    pub artist: models::ArtistId3,
}

impl Contributor {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(role: String, artist: models::ArtistId3) -> Contributor {
        Contributor {
            role,
            sub_role: None,
            artist,
        }
    }
}

/// Converts the Contributor value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Contributor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("role".to_string()),
            Some(self.role.to_string()),
            self.sub_role
                .as_ref()
                .map(|sub_role| ["subRole".to_string(), sub_role.to_string()].join(",")),
            // Skipping artist in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Contributor value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Contributor {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub role: Vec<String>,
            pub sub_role: Vec<String>,
            pub artist: Vec<models::ArtistId3>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Contributor".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "subRole" => intermediate_rep.sub_role.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artist" => intermediate_rep.artist.push(
                        <models::ArtistId3 as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Contributor".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Contributor {
            role: intermediate_rep
                .role
                .into_iter()
                .next()
                .ok_or_else(|| "role missing in Contributor".to_string())?,
            sub_role: intermediate_rep.sub_role.into_iter().next(),
            artist: intermediate_rep
                .artist
                .into_iter()
                .next()
                .ok_or_else(|| "artist missing in Contributor".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Contributor> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Contributor>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Contributor>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Contributor - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Contributor> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Contributor as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Contributor - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested playlist element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreatePlaylistResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::CreatePlaylistResponseSubsonicResponse>,
}

impl CreatePlaylistResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreatePlaylistResponse {
        CreatePlaylistResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the CreatePlaylistResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreatePlaylistResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreatePlaylistResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreatePlaylistResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::CreatePlaylistResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing CreatePlaylistResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::CreatePlaylistResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreatePlaylistResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreatePlaylistResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreatePlaylistResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreatePlaylistResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<CreatePlaylistResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for CreatePlaylistResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreatePlaylistResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <CreatePlaylistResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into CreatePlaylistResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum CreatePlaylistResponseSubsonicResponse {
    CreatePlaylistSuccessResponse(Box<models::CreatePlaylistSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for CreatePlaylistResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::CreatePlaylistSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::CreatePlaylistSuccessResponse> for CreatePlaylistResponseSubsonicResponse {
    fn from(value: models::CreatePlaylistSuccessResponse) -> Self {
        Self::CreatePlaylistSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for CreatePlaylistResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreatePlaylistResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreatePlaylistResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreatePlaylistSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "playlist")]
    pub playlist: models::PlaylistWithSongs,
}

impl CreatePlaylistSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        playlist: models::PlaylistWithSongs,
    ) -> CreatePlaylistSuccessResponse {
        CreatePlaylistSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            playlist,
        }
    }
}

/// Converts the CreatePlaylistSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreatePlaylistSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping playlist in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreatePlaylistSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreatePlaylistSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub playlist: Vec<models::PlaylistWithSongs>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing CreatePlaylistSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "playlist" => intermediate_rep.playlist.push(
                        <models::PlaylistWithSongs as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing CreatePlaylistSuccessResponse"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreatePlaylistSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in CreatePlaylistSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in CreatePlaylistSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in CreatePlaylistSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "openSubsonic missing in CreatePlaylistSuccessResponse".to_string()
                })?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in CreatePlaylistSuccessResponse".to_string())?,
            playlist: intermediate_rep
                .playlist
                .into_iter()
                .next()
                .ok_or_else(|| "playlist missing in CreatePlaylistSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreatePlaylistSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreatePlaylistSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<CreatePlaylistSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for CreatePlaylistSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreatePlaylistSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreatePlaylistSuccessResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreatePlaylistSuccessResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// A subsonic-response element with a nested shares element on success. Which in turns contains a single share element for the newly created share
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateSharesResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::CreateSharesResponseSubsonicResponse>,
}

impl CreateSharesResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateSharesResponse {
        CreateSharesResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the CreateSharesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateSharesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateSharesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateSharesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::CreateSharesResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing CreateSharesResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::CreateSharesResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateSharesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateSharesResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateSharesResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateSharesResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<CreateSharesResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for CreateSharesResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateSharesResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <CreateSharesResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into CreateSharesResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum CreateSharesResponseSubsonicResponse {
    CreateSharesSuccessResponse(Box<models::CreateSharesSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for CreateSharesResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::CreateSharesSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::CreateSharesSuccessResponse> for CreateSharesResponseSubsonicResponse {
    fn from(value: models::CreateSharesSuccessResponse) -> Self {
        Self::CreateSharesSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for CreateSharesResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateSharesResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateSharesResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateSharesSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "shares")]
    pub shares: models::Shares,
}

impl CreateSharesSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        shares: models::Shares,
    ) -> CreateSharesSuccessResponse {
        CreateSharesSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            shares,
        }
    }
}

/// Converts the CreateSharesSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateSharesSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping shares in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateSharesSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateSharesSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub shares: Vec<models::Shares>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing CreateSharesSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "shares" => intermediate_rep.shares.push(
                        <models::Shares as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing CreateSharesSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateSharesSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in CreateSharesSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in CreateSharesSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in CreateSharesSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in CreateSharesSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in CreateSharesSuccessResponse".to_string())?,
            shares: intermediate_rep
                .shares
                .into_iter()
                .next()
                .ok_or_else(|| "shares missing in CreateSharesSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateSharesSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateSharesSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<CreateSharesSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for CreateSharesSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateSharesSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <CreateSharesSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into CreateSharesSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Directory.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Directory {
    /// The id
    #[serde(rename = "id")]
    pub id: String,

    /// Parent item
    #[serde(rename = "parent")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent: Option<String>,

    /// The directory name
    #[serde(rename = "name")]
    pub name: String,

    /// Starred date [ISO 8601]
    #[serde(rename = "starred")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub starred: Option<chrono::DateTime<chrono::Utc>>,

    /// The user rating [1-5]
    #[serde(rename = "userRating")]
    #[validate(range(min = 1u8, max = 5u8))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_rating: Option<u8>,

    /// The average rating [1-5]
    #[serde(rename = "averageRating")]
    #[validate(range(min = 1f64, max = 5f64))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub average_rating: Option<f64>,

    /// The play count
    #[serde(rename = "playCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub play_count: Option<i32>,

    /// The directory content
    #[serde(rename = "child")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub child: Option<Vec<models::Child>>,
}

impl Directory {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, name: String) -> Directory {
        Directory {
            id,
            parent: None,
            name,
            starred: None,
            user_rating: None,
            average_rating: None,
            play_count: None,
            child: None,
        }
    }
}

/// Converts the Directory value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Directory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            self.parent
                .as_ref()
                .map(|parent| ["parent".to_string(), parent.to_string()].join(",")),
            Some("name".to_string()),
            Some(self.name.to_string()),
            // Skipping starred in query parameter serialization
            self.user_rating
                .as_ref()
                .map(|user_rating| ["userRating".to_string(), user_rating.to_string()].join(",")),
            self.average_rating.as_ref().map(|average_rating| {
                ["averageRating".to_string(), average_rating.to_string()].join(",")
            }),
            self.play_count
                .as_ref()
                .map(|play_count| ["playCount".to_string(), play_count.to_string()].join(",")),
            // Skipping child in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Directory value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Directory {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub parent: Vec<String>,
            pub name: Vec<String>,
            pub starred: Vec<chrono::DateTime<chrono::Utc>>,
            pub user_rating: Vec<u8>,
            pub average_rating: Vec<f64>,
            pub play_count: Vec<i32>,
            pub child: Vec<Vec<models::Child>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Directory".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "parent" => intermediate_rep.parent.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "starred" => intermediate_rep.starred.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "userRating" => intermediate_rep
                        .user_rating
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "averageRating" => intermediate_rep.average_rating.push(
                        <f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "playCount" => intermediate_rep.play_count.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "child" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Directory"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Directory".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Directory {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in Directory".to_string())?,
            parent: intermediate_rep.parent.into_iter().next(),
            name: intermediate_rep
                .name
                .into_iter()
                .next()
                .ok_or_else(|| "name missing in Directory".to_string())?,
            starred: intermediate_rep.starred.into_iter().next(),
            user_rating: intermediate_rep.user_rating.into_iter().next(),
            average_rating: intermediate_rep.average_rating.into_iter().next(),
            play_count: intermediate_rep.play_count.into_iter().next(),
            child: intermediate_rep.child.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Directory> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Directory>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Directory>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Directory - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Directory> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Directory as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Directory - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A disc title for an album
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DiscTitle {
    /// The disc number.
    #[serde(rename = "disc")]
    pub disc: i32,

    /// The name of the disc.
    #[serde(rename = "title")]
    pub title: String,
}

impl DiscTitle {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(disc: i32, title: String) -> DiscTitle {
        DiscTitle { disc, title }
    }
}

/// Converts the DiscTitle value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DiscTitle {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("disc".to_string()),
            Some(self.disc.to_string()),
            Some("title".to_string()),
            Some(self.title.to_string()),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DiscTitle value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DiscTitle {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub disc: Vec<i32>,
            pub title: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DiscTitle".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "disc" => intermediate_rep.disc.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing DiscTitle".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DiscTitle {
            disc: intermediate_rep
                .disc
                .into_iter()
                .next()
                .ok_or_else(|| "disc missing in DiscTitle".to_string())?,
            title: intermediate_rep
                .title
                .into_iter()
                .next()
                .ok_or_else(|| "title missing in DiscTitle".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DiscTitle> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DiscTitle>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DiscTitle>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DiscTitle - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DiscTitle> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DiscTitle as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DiscTitle - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Returns “explicit”, “clean” or “”. (For songs extracted from tags “ITUNESADVISORY”: 1 = explicit, 2 = clean, MP4 “rtng”: 1 or 4 = explicit, 2 = clean. See `albumID3` for albums)
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ExplicitStatus {
    #[serde(rename = "clean")]
    Clean,
    #[serde(rename = "explicit")]
    Explicit,
    #[serde(rename = "")]
    Empty,
}

impl std::fmt::Display for ExplicitStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ExplicitStatus::Clean => write!(f, "clean"),
            ExplicitStatus::Explicit => write!(f, "explicit"),
            ExplicitStatus::Empty => write!(f, ""),
        }
    }
}

impl std::str::FromStr for ExplicitStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "clean" => std::result::Result::Ok(ExplicitStatus::Clean),
            "explicit" => std::result::Result::Ok(ExplicitStatus::Explicit),
            "" => std::result::Result::Ok(ExplicitStatus::Empty),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The generic type of media [music/podcast/audiobook/video]
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum GenericMediaType {
    #[serde(rename = "music")]
    Music,
    #[serde(rename = "video")]
    Video,
    #[serde(rename = "podcast")]
    Podcast,
    #[serde(rename = "audiobook")]
    Audiobook,
}

impl std::fmt::Display for GenericMediaType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            GenericMediaType::Music => write!(f, "music"),
            GenericMediaType::Video => write!(f, "video"),
            GenericMediaType::Podcast => write!(f, "podcast"),
            GenericMediaType::Audiobook => write!(f, "audiobook"),
        }
    }
}

impl std::str::FromStr for GenericMediaType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "music" => std::result::Result::Ok(GenericMediaType::Music),
            "video" => std::result::Result::Ok(GenericMediaType::Video),
            "podcast" => std::result::Result::Ok(GenericMediaType::Podcast),
            "audiobook" => std::result::Result::Ok(GenericMediaType::Audiobook),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// A genre.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Genre {
    /// Genre name
    #[serde(rename = "value")]
    pub value: String,

    /// Genre song count
    #[serde(rename = "songCount")]
    pub song_count: i32,

    /// Genre album count
    #[serde(rename = "albumCount")]
    pub album_count: i32,
}

impl Genre {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(value: String, song_count: i32, album_count: i32) -> Genre {
        Genre {
            value,
            song_count,
            album_count,
        }
    }
}

/// Converts the Genre value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Genre {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("value".to_string()),
            Some(self.value.to_string()),
            Some("songCount".to_string()),
            Some(self.song_count.to_string()),
            Some("albumCount".to_string()),
            Some(self.album_count.to_string()),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Genre value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Genre {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub value: Vec<String>,
            pub song_count: Vec<i32>,
            pub album_count: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Genre".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "songCount" => intermediate_rep.song_count.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "albumCount" => intermediate_rep.album_count.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Genre".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Genre {
            value: intermediate_rep
                .value
                .into_iter()
                .next()
                .ok_or_else(|| "value missing in Genre".to_string())?,
            song_count: intermediate_rep
                .song_count
                .into_iter()
                .next()
                .ok_or_else(|| "songCount missing in Genre".to_string())?,
            album_count: intermediate_rep
                .album_count
                .into_iter()
                .next()
                .ok_or_else(|| "albumCount missing in Genre".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Genre> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Genre>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Genre>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Genre - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Genre> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Genre as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Genre - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Genres list.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Genres {
    /// List of genre
    #[serde(rename = "genre")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub genre: Option<Vec<models::Genre>>,
}

impl Genres {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Genres {
        Genres { genre: None }
    }
}

/// Converts the Genres value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Genres {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping genre in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Genres value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Genres {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub genre: Vec<Vec<models::Genre>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Genres".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "genre" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Genres"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Genres".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Genres {
            genre: intermediate_rep.genre.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Genres> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Genres>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Genres>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Genres - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Genres> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Genres as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Genres - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested albumInfo element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetAlbumInfoResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetAlbumInfoResponseSubsonicResponse>,
}

impl GetAlbumInfoResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetAlbumInfoResponse {
        GetAlbumInfoResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetAlbumInfoResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetAlbumInfoResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetAlbumInfoResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetAlbumInfoResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetAlbumInfoResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetAlbumInfoResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetAlbumInfoResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetAlbumInfoResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetAlbumInfoResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetAlbumInfoResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetAlbumInfoResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetAlbumInfoResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetAlbumInfoResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetAlbumInfoResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetAlbumInfoResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetAlbumInfoResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetAlbumInfoResponseSubsonicResponse {
    GetAlbumInfoSuccessResponse(Box<models::GetAlbumInfoSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetAlbumInfoResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetAlbumInfoSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetAlbumInfoSuccessResponse> for GetAlbumInfoResponseSubsonicResponse {
    fn from(value: models::GetAlbumInfoSuccessResponse) -> Self {
        Self::GetAlbumInfoSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetAlbumInfoResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetAlbumInfoResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetAlbumInfoResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetAlbumInfoSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "albumInfo")]
    pub album_info: models::AlbumInfo,
}

impl GetAlbumInfoSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        album_info: models::AlbumInfo,
    ) -> GetAlbumInfoSuccessResponse {
        GetAlbumInfoSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            album_info,
        }
    }
}

/// Converts the GetAlbumInfoSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetAlbumInfoSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping albumInfo in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetAlbumInfoSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetAlbumInfoSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub album_info: Vec<models::AlbumInfo>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetAlbumInfoSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "albumInfo" => intermediate_rep.album_info.push(
                        <models::AlbumInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetAlbumInfoSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetAlbumInfoSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetAlbumInfoSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetAlbumInfoSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetAlbumInfoSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetAlbumInfoSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetAlbumInfoSuccessResponse".to_string())?,
            album_info: intermediate_rep
                .album_info
                .into_iter()
                .next()
                .ok_or_else(|| "albumInfo missing in GetAlbumInfoSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetAlbumInfoSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetAlbumInfoSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetAlbumInfoSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetAlbumInfoSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetAlbumInfoSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetAlbumInfoSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetAlbumInfoSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested albumList2 element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetAlbumList2Response {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetAlbumList2ResponseSubsonicResponse>,
}

impl GetAlbumList2Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetAlbumList2Response {
        GetAlbumList2Response {
            subsonic_response: None,
        }
    }
}

/// Converts the GetAlbumList2Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetAlbumList2Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetAlbumList2Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetAlbumList2Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetAlbumList2ResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetAlbumList2Response".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetAlbumList2ResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetAlbumList2Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetAlbumList2Response {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetAlbumList2Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetAlbumList2Response>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetAlbumList2Response>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetAlbumList2Response - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetAlbumList2Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetAlbumList2Response as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetAlbumList2Response - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetAlbumList2ResponseSubsonicResponse {
    GetAlbumList2SuccessResponse(Box<models::GetAlbumList2SuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetAlbumList2ResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetAlbumList2SuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetAlbumList2SuccessResponse> for GetAlbumList2ResponseSubsonicResponse {
    fn from(value: models::GetAlbumList2SuccessResponse) -> Self {
        Self::GetAlbumList2SuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetAlbumList2ResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetAlbumList2ResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetAlbumList2ResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetAlbumList2SuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "albumList2")]
    pub album_list2: models::AlbumList,
}

impl GetAlbumList2SuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        album_list2: models::AlbumList,
    ) -> GetAlbumList2SuccessResponse {
        GetAlbumList2SuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            album_list2,
        }
    }
}

/// Converts the GetAlbumList2SuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetAlbumList2SuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping albumList2 in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetAlbumList2SuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetAlbumList2SuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub album_list2: Vec<models::AlbumList>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetAlbumList2SuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "albumList2" => intermediate_rep.album_list2.push(
                        <models::AlbumList as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetAlbumList2SuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetAlbumList2SuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetAlbumList2SuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetAlbumList2SuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetAlbumList2SuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "openSubsonic missing in GetAlbumList2SuccessResponse".to_string()
                })?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetAlbumList2SuccessResponse".to_string())?,
            album_list2: intermediate_rep
                .album_list2
                .into_iter()
                .next()
                .ok_or_else(|| "albumList2 missing in GetAlbumList2SuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetAlbumList2SuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetAlbumList2SuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetAlbumList2SuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetAlbumList2SuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetAlbumList2SuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetAlbumList2SuccessResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetAlbumList2SuccessResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// A subsonic-response element with a nested albumList element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetAlbumListResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetAlbumListResponseSubsonicResponse>,
}

impl GetAlbumListResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetAlbumListResponse {
        GetAlbumListResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetAlbumListResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetAlbumListResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetAlbumListResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetAlbumListResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetAlbumListResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetAlbumListResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetAlbumListResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetAlbumListResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetAlbumListResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetAlbumListResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetAlbumListResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetAlbumListResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetAlbumListResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetAlbumListResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetAlbumListResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetAlbumListResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetAlbumListResponseSubsonicResponse {
    GetAlbumListSuccessResponse(Box<models::GetAlbumListSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetAlbumListResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetAlbumListSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetAlbumListSuccessResponse> for GetAlbumListResponseSubsonicResponse {
    fn from(value: models::GetAlbumListSuccessResponse) -> Self {
        Self::GetAlbumListSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetAlbumListResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetAlbumListResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetAlbumListResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetAlbumListSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "albumList")]
    pub album_list: models::AlbumList,
}

impl GetAlbumListSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        album_list: models::AlbumList,
    ) -> GetAlbumListSuccessResponse {
        GetAlbumListSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            album_list,
        }
    }
}

/// Converts the GetAlbumListSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetAlbumListSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping albumList in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetAlbumListSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetAlbumListSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub album_list: Vec<models::AlbumList>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetAlbumListSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "albumList" => intermediate_rep.album_list.push(
                        <models::AlbumList as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetAlbumListSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetAlbumListSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetAlbumListSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetAlbumListSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetAlbumListSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetAlbumListSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetAlbumListSuccessResponse".to_string())?,
            album_list: intermediate_rep
                .album_list
                .into_iter()
                .next()
                .ok_or_else(|| "albumList missing in GetAlbumListSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetAlbumListSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetAlbumListSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetAlbumListSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetAlbumListSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetAlbumListSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetAlbumListSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetAlbumListSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested album element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetAlbumResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetAlbumResponseSubsonicResponse>,
}

impl GetAlbumResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetAlbumResponse {
        GetAlbumResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetAlbumResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetAlbumResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetAlbumResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetAlbumResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetAlbumResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetAlbumResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(
                        <models::GetAlbumResponseSubsonicResponse as std::str::FromStr>::from_str(
                            val,
                        )
                        .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetAlbumResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetAlbumResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetAlbumResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetAlbumResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetAlbumResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetAlbumResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetAlbumResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetAlbumResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetAlbumResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetAlbumResponseSubsonicResponse {
    GetAlbumSuccessResponse(Box<models::GetAlbumSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetAlbumResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetAlbumSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetAlbumSuccessResponse> for GetAlbumResponseSubsonicResponse {
    fn from(value: models::GetAlbumSuccessResponse) -> Self {
        Self::GetAlbumSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetAlbumResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetAlbumResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetAlbumResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetAlbumSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "album")]
    pub album: models::AlbumId3WithSongs,
}

impl GetAlbumSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        album: models::AlbumId3WithSongs,
    ) -> GetAlbumSuccessResponse {
        GetAlbumSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            album,
        }
    }
}

/// Converts the GetAlbumSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetAlbumSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping album in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetAlbumSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetAlbumSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub album: Vec<models::AlbumId3WithSongs>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetAlbumSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "album" => intermediate_rep.album.push(
                        <models::AlbumId3WithSongs as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetAlbumSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetAlbumSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetAlbumSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetAlbumSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in GetAlbumSuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetAlbumSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetAlbumSuccessResponse".to_string())?,
            album: intermediate_rep
                .album
                .into_iter()
                .next()
                .ok_or_else(|| "album missing in GetAlbumSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetAlbumSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetAlbumSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetAlbumSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetAlbumSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetAlbumSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetAlbumSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetAlbumSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested artistInfo2 element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetArtistInfo2Response {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetArtistInfo2ResponseSubsonicResponse>,
}

impl GetArtistInfo2Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetArtistInfo2Response {
        GetArtistInfo2Response {
            subsonic_response: None,
        }
    }
}

/// Converts the GetArtistInfo2Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetArtistInfo2Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetArtistInfo2Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetArtistInfo2Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetArtistInfo2ResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetArtistInfo2Response".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetArtistInfo2ResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetArtistInfo2Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetArtistInfo2Response {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetArtistInfo2Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetArtistInfo2Response>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetArtistInfo2Response>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetArtistInfo2Response - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetArtistInfo2Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetArtistInfo2Response as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetArtistInfo2Response - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetArtistInfo2ResponseSubsonicResponse {
    GetArtistInfo2SuccessResponse(Box<models::GetArtistInfo2SuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetArtistInfo2ResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetArtistInfo2SuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetArtistInfo2SuccessResponse> for GetArtistInfo2ResponseSubsonicResponse {
    fn from(value: models::GetArtistInfo2SuccessResponse) -> Self {
        Self::GetArtistInfo2SuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetArtistInfo2ResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetArtistInfo2ResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetArtistInfo2ResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetArtistInfo2SuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "artistInfo2")]
    pub artist_info2: models::ArtistInfo2,
}

impl GetArtistInfo2SuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        artist_info2: models::ArtistInfo2,
    ) -> GetArtistInfo2SuccessResponse {
        GetArtistInfo2SuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            artist_info2,
        }
    }
}

/// Converts the GetArtistInfo2SuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetArtistInfo2SuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping artistInfo2 in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetArtistInfo2SuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetArtistInfo2SuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub artist_info2: Vec<models::ArtistInfo2>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetArtistInfo2SuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artistInfo2" => intermediate_rep.artist_info2.push(
                        <models::ArtistInfo2 as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetArtistInfo2SuccessResponse"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetArtistInfo2SuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetArtistInfo2SuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetArtistInfo2SuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetArtistInfo2SuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "openSubsonic missing in GetArtistInfo2SuccessResponse".to_string()
                })?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetArtistInfo2SuccessResponse".to_string())?,
            artist_info2: intermediate_rep
                .artist_info2
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "artistInfo2 missing in GetArtistInfo2SuccessResponse".to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetArtistInfo2SuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetArtistInfo2SuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetArtistInfo2SuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetArtistInfo2SuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetArtistInfo2SuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetArtistInfo2SuccessResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetArtistInfo2SuccessResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// A subsonic-response element with a nested artistInfo element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetArtistInfoResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetArtistInfoResponseSubsonicResponse>,
}

impl GetArtistInfoResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetArtistInfoResponse {
        GetArtistInfoResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetArtistInfoResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetArtistInfoResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetArtistInfoResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetArtistInfoResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetArtistInfoResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetArtistInfoResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetArtistInfoResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetArtistInfoResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetArtistInfoResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetArtistInfoResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetArtistInfoResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetArtistInfoResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetArtistInfoResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetArtistInfoResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetArtistInfoResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetArtistInfoResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetArtistInfoResponseSubsonicResponse {
    GetArtistInfoSuccessResponse(Box<models::GetArtistInfoSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetArtistInfoResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetArtistInfoSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetArtistInfoSuccessResponse> for GetArtistInfoResponseSubsonicResponse {
    fn from(value: models::GetArtistInfoSuccessResponse) -> Self {
        Self::GetArtistInfoSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetArtistInfoResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetArtistInfoResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetArtistInfoResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetArtistInfoSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "artistInfo")]
    pub artist_info: models::ArtistInfo,
}

impl GetArtistInfoSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        artist_info: models::ArtistInfo,
    ) -> GetArtistInfoSuccessResponse {
        GetArtistInfoSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            artist_info,
        }
    }
}

/// Converts the GetArtistInfoSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetArtistInfoSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping artistInfo in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetArtistInfoSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetArtistInfoSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub artist_info: Vec<models::ArtistInfo>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetArtistInfoSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artistInfo" => intermediate_rep.artist_info.push(
                        <models::ArtistInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetArtistInfoSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetArtistInfoSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetArtistInfoSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetArtistInfoSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetArtistInfoSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "openSubsonic missing in GetArtistInfoSuccessResponse".to_string()
                })?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetArtistInfoSuccessResponse".to_string())?,
            artist_info: intermediate_rep
                .artist_info
                .into_iter()
                .next()
                .ok_or_else(|| "artistInfo missing in GetArtistInfoSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetArtistInfoSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetArtistInfoSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetArtistInfoSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetArtistInfoSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetArtistInfoSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetArtistInfoSuccessResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetArtistInfoSuccessResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// A subsonic-response element with a nested artist element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetArtistResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetArtistResponseSubsonicResponse>,
}

impl GetArtistResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetArtistResponse {
        GetArtistResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetArtistResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetArtistResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetArtistResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetArtistResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetArtistResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetArtistResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(
                        <models::GetArtistResponseSubsonicResponse as std::str::FromStr>::from_str(
                            val,
                        )
                        .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetArtistResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetArtistResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetArtistResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetArtistResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetArtistResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetArtistResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetArtistResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetArtistResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetArtistResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetArtistResponseSubsonicResponse {
    GetArtistSuccessResponse(Box<models::GetArtistSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetArtistResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetArtistSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetArtistSuccessResponse> for GetArtistResponseSubsonicResponse {
    fn from(value: models::GetArtistSuccessResponse) -> Self {
        Self::GetArtistSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetArtistResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetArtistResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetArtistResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetArtistSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "artist")]
    pub artist: models::ArtistWithAlbumsId3,
}

impl GetArtistSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        artist: models::ArtistWithAlbumsId3,
    ) -> GetArtistSuccessResponse {
        GetArtistSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            artist,
        }
    }
}

/// Converts the GetArtistSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetArtistSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping artist in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetArtistSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetArtistSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub artist: Vec<models::ArtistWithAlbumsId3>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetArtistSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artist" => intermediate_rep.artist.push(
                        <models::ArtistWithAlbumsId3 as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetArtistSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetArtistSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetArtistSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetArtistSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in GetArtistSuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetArtistSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetArtistSuccessResponse".to_string())?,
            artist: intermediate_rep
                .artist
                .into_iter()
                .next()
                .ok_or_else(|| "artist missing in GetArtistSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetArtistSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetArtistSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetArtistSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetArtistSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetArtistSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetArtistSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetArtistSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested artists element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetArtistsResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetArtistsResponseSubsonicResponse>,
}

impl GetArtistsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetArtistsResponse {
        GetArtistsResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetArtistsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetArtistsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetArtistsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetArtistsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetArtistsResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetArtistsResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetArtistsResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetArtistsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetArtistsResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetArtistsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetArtistsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetArtistsResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetArtistsResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetArtistsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetArtistsResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetArtistsResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetArtistsResponseSubsonicResponse {
    GetArtistsSuccessResponse(Box<models::GetArtistsSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetArtistsResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetArtistsSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetArtistsSuccessResponse> for GetArtistsResponseSubsonicResponse {
    fn from(value: models::GetArtistsSuccessResponse) -> Self {
        Self::GetArtistsSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetArtistsResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetArtistsResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetArtistsResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetArtistsSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "artists")]
    pub artists: models::ArtistsId3,
}

impl GetArtistsSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        artists: models::ArtistsId3,
    ) -> GetArtistsSuccessResponse {
        GetArtistsSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            artists,
        }
    }
}

/// Converts the GetArtistsSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetArtistsSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping artists in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetArtistsSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetArtistsSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub artists: Vec<models::ArtistsId3>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetArtistsSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artists" => intermediate_rep.artists.push(
                        <models::ArtistsId3 as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetArtistsSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetArtistsSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetArtistsSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetArtistsSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in GetArtistsSuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetArtistsSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetArtistsSuccessResponse".to_string())?,
            artists: intermediate_rep
                .artists
                .into_iter()
                .next()
                .ok_or_else(|| "artists missing in GetArtistsSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetArtistsSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetArtistsSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetArtistsSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetArtistsSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetArtistsSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetArtistsSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetArtistsSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested bookmarks element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetBookmarksResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetBookmarksResponseSubsonicResponse>,
}

impl GetBookmarksResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetBookmarksResponse {
        GetBookmarksResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetBookmarksResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetBookmarksResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetBookmarksResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetBookmarksResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetBookmarksResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetBookmarksResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetBookmarksResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetBookmarksResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetBookmarksResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetBookmarksResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetBookmarksResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetBookmarksResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetBookmarksResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetBookmarksResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetBookmarksResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetBookmarksResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetBookmarksResponseSubsonicResponse {
    GetBookmarksSuccessResponse(Box<models::GetBookmarksSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetBookmarksResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetBookmarksSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetBookmarksSuccessResponse> for GetBookmarksResponseSubsonicResponse {
    fn from(value: models::GetBookmarksSuccessResponse) -> Self {
        Self::GetBookmarksSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetBookmarksResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetBookmarksResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetBookmarksResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetBookmarksSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "bookmarks")]
    pub bookmarks: models::Bookmarks,
}

impl GetBookmarksSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        bookmarks: models::Bookmarks,
    ) -> GetBookmarksSuccessResponse {
        GetBookmarksSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            bookmarks,
        }
    }
}

/// Converts the GetBookmarksSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetBookmarksSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping bookmarks in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetBookmarksSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetBookmarksSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub bookmarks: Vec<models::Bookmarks>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetBookmarksSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "bookmarks" => intermediate_rep.bookmarks.push(
                        <models::Bookmarks as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetBookmarksSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetBookmarksSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetBookmarksSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetBookmarksSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetBookmarksSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetBookmarksSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetBookmarksSuccessResponse".to_string())?,
            bookmarks: intermediate_rep
                .bookmarks
                .into_iter()
                .next()
                .ok_or_else(|| "bookmarks missing in GetBookmarksSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetBookmarksSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetBookmarksSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetBookmarksSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetBookmarksSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetBookmarksSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetBookmarksSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetBookmarksSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested chatMessages element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetChatMessagesResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetChatMessagesResponseSubsonicResponse>,
}

impl GetChatMessagesResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetChatMessagesResponse {
        GetChatMessagesResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetChatMessagesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetChatMessagesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetChatMessagesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetChatMessagesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetChatMessagesResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetChatMessagesResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetChatMessagesResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetChatMessagesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetChatMessagesResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetChatMessagesResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetChatMessagesResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetChatMessagesResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetChatMessagesResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetChatMessagesResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetChatMessagesResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetChatMessagesResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetChatMessagesResponseSubsonicResponse {
    GetChatMessagesSuccessResponse(Box<models::GetChatMessagesSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetChatMessagesResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetChatMessagesSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetChatMessagesSuccessResponse> for GetChatMessagesResponseSubsonicResponse {
    fn from(value: models::GetChatMessagesSuccessResponse) -> Self {
        Self::GetChatMessagesSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetChatMessagesResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetChatMessagesResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetChatMessagesResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetChatMessagesSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "chatMessages")]
    pub chat_messages: models::ChatMessages,
}

impl GetChatMessagesSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        chat_messages: models::ChatMessages,
    ) -> GetChatMessagesSuccessResponse {
        GetChatMessagesSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            chat_messages,
        }
    }
}

/// Converts the GetChatMessagesSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetChatMessagesSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping chatMessages in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetChatMessagesSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetChatMessagesSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub chat_messages: Vec<models::ChatMessages>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetChatMessagesSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "chatMessages" => intermediate_rep.chat_messages.push(
                        <models::ChatMessages as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetChatMessagesSuccessResponse"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetChatMessagesSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetChatMessagesSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetChatMessagesSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetChatMessagesSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "openSubsonic missing in GetChatMessagesSuccessResponse".to_string()
                })?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetChatMessagesSuccessResponse".to_string())?,
            chat_messages: intermediate_rep
                .chat_messages
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "chatMessages missing in GetChatMessagesSuccessResponse".to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetChatMessagesSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetChatMessagesSuccessResponse>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetChatMessagesSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetChatMessagesSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<GetChatMessagesSuccessResponse>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetChatMessagesSuccessResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetChatMessagesSuccessResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// A subsonic-response element with a nested genres element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetGenresResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetGenresResponseSubsonicResponse>,
}

impl GetGenresResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetGenresResponse {
        GetGenresResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetGenresResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetGenresResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetGenresResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetGenresResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetGenresResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetGenresResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(
                        <models::GetGenresResponseSubsonicResponse as std::str::FromStr>::from_str(
                            val,
                        )
                        .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetGenresResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetGenresResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetGenresResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetGenresResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetGenresResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetGenresResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetGenresResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetGenresResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetGenresResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetGenresResponseSubsonicResponse {
    GetGenresSuccessResponse(Box<models::GetGenresSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetGenresResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetGenresSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetGenresSuccessResponse> for GetGenresResponseSubsonicResponse {
    fn from(value: models::GetGenresSuccessResponse) -> Self {
        Self::GetGenresSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetGenresResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetGenresResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetGenresResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetGenresSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "genres")]
    pub genres: models::Genres,
}

impl GetGenresSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        genres: models::Genres,
    ) -> GetGenresSuccessResponse {
        GetGenresSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            genres,
        }
    }
}

/// Converts the GetGenresSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetGenresSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping genres in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetGenresSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetGenresSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub genres: Vec<models::Genres>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetGenresSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "genres" => intermediate_rep.genres.push(
                        <models::Genres as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetGenresSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetGenresSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetGenresSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetGenresSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in GetGenresSuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetGenresSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetGenresSuccessResponse".to_string())?,
            genres: intermediate_rep
                .genres
                .into_iter()
                .next()
                .ok_or_else(|| "genres missing in GetGenresSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetGenresSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetGenresSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetGenresSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetGenresSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetGenresSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetGenresSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetGenresSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested indexes element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetIndexesResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetIndexesResponseSubsonicResponse>,
}

impl GetIndexesResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetIndexesResponse {
        GetIndexesResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetIndexesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetIndexesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetIndexesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetIndexesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetIndexesResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetIndexesResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetIndexesResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetIndexesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetIndexesResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetIndexesResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetIndexesResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetIndexesResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetIndexesResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetIndexesResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetIndexesResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetIndexesResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetIndexesResponseSubsonicResponse {
    GetIndexesSuccessResponse(Box<models::GetIndexesSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetIndexesResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetIndexesSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetIndexesSuccessResponse> for GetIndexesResponseSubsonicResponse {
    fn from(value: models::GetIndexesSuccessResponse) -> Self {
        Self::GetIndexesSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetIndexesResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetIndexesResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetIndexesResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetIndexesSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "indexes")]
    pub indexes: models::Indexes,
}

impl GetIndexesSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        indexes: models::Indexes,
    ) -> GetIndexesSuccessResponse {
        GetIndexesSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            indexes,
        }
    }
}

/// Converts the GetIndexesSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetIndexesSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping indexes in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetIndexesSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetIndexesSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub indexes: Vec<models::Indexes>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetIndexesSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "indexes" => intermediate_rep.indexes.push(
                        <models::Indexes as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetIndexesSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetIndexesSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetIndexesSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetIndexesSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in GetIndexesSuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetIndexesSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetIndexesSuccessResponse".to_string())?,
            indexes: intermediate_rep
                .indexes
                .into_iter()
                .next()
                .ok_or_else(|| "indexes missing in GetIndexesSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetIndexesSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetIndexesSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetIndexesSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetIndexesSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetIndexesSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetIndexesSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetIndexesSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested internetRadioStations element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetInternetRadioStationsResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetInternetRadioStationsResponseSubsonicResponse>,
}

impl GetInternetRadioStationsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetInternetRadioStationsResponse {
        GetInternetRadioStationsResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetInternetRadioStationsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetInternetRadioStationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetInternetRadioStationsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetInternetRadioStationsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetInternetRadioStationsResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetInternetRadioStationsResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetInternetRadioStationsResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetInternetRadioStationsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetInternetRadioStationsResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetInternetRadioStationsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetInternetRadioStationsResponse>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetInternetRadioStationsResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetInternetRadioStationsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<GetInternetRadioStationsResponse>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetInternetRadioStationsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetInternetRadioStationsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetInternetRadioStationsResponseSubsonicResponse {
    GetInternetRadioStationsSuccessResponse(Box<models::GetInternetRadioStationsSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetInternetRadioStationsResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetInternetRadioStationsSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetInternetRadioStationsSuccessResponse>
    for GetInternetRadioStationsResponseSubsonicResponse
{
    fn from(value: models::GetInternetRadioStationsSuccessResponse) -> Self {
        Self::GetInternetRadioStationsSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetInternetRadioStationsResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetInternetRadioStationsResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetInternetRadioStationsResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetInternetRadioStationsSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "internetRadioStations")]
    pub internet_radio_stations: models::InternetRadioStations,
}

impl GetInternetRadioStationsSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        internet_radio_stations: models::InternetRadioStations,
    ) -> GetInternetRadioStationsSuccessResponse {
        GetInternetRadioStationsSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            internet_radio_stations,
        }
    }
}

/// Converts the GetInternetRadioStationsSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetInternetRadioStationsSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping internetRadioStations in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetInternetRadioStationsSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetInternetRadioStationsSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub internet_radio_stations: Vec<models::InternetRadioStations>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetInternetRadioStationsSuccessResponse"
                            .to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "internetRadioStations" => intermediate_rep.internet_radio_stations.push(
                        <models::InternetRadioStations as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetInternetRadioStationsSuccessResponse"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetInternetRadioStationsSuccessResponse {
            version: intermediate_rep.version.into_iter().next().ok_or_else(|| {
                "version missing in GetInternetRadioStationsSuccessResponse".to_string()
            })?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| {
                "type missing in GetInternetRadioStationsSuccessResponse".to_string()
            })?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetInternetRadioStationsSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "openSubsonic missing in GetInternetRadioStationsSuccessResponse".to_string()
                })?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| {
                "status missing in GetInternetRadioStationsSuccessResponse".to_string()
            })?,
            internet_radio_stations: intermediate_rep
                .internet_radio_stations
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "internetRadioStations missing in GetInternetRadioStationsSuccessResponse"
                        .to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetInternetRadioStationsSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetInternetRadioStationsSuccessResponse>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetInternetRadioStationsSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetInternetRadioStationsSuccessResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<GetInternetRadioStationsSuccessResponse>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetInternetRadioStationsSuccessResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetInternetRadioStationsSuccessResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// A subsonic-response element with a nested license element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetLicenseResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetLicenseResponseSubsonicResponse>,
}

impl GetLicenseResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetLicenseResponse {
        GetLicenseResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetLicenseResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetLicenseResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetLicenseResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetLicenseResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetLicenseResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetLicenseResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetLicenseResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetLicenseResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetLicenseResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetLicenseResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetLicenseResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetLicenseResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetLicenseResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetLicenseResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetLicenseResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetLicenseResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetLicenseResponseSubsonicResponse {
    GetLicenseSuccessResponse(Box<models::GetLicenseSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetLicenseResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetLicenseSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetLicenseSuccessResponse> for GetLicenseResponseSubsonicResponse {
    fn from(value: models::GetLicenseSuccessResponse) -> Self {
        Self::GetLicenseSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetLicenseResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetLicenseResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetLicenseResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetLicenseSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "license")]
    pub license: models::License,
}

impl GetLicenseSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        license: models::License,
    ) -> GetLicenseSuccessResponse {
        GetLicenseSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            license,
        }
    }
}

/// Converts the GetLicenseSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetLicenseSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping license in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetLicenseSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetLicenseSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub license: Vec<models::License>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetLicenseSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "license" => intermediate_rep.license.push(
                        <models::License as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetLicenseSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetLicenseSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetLicenseSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetLicenseSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in GetLicenseSuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetLicenseSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetLicenseSuccessResponse".to_string())?,
            license: intermediate_rep
                .license
                .into_iter()
                .next()
                .ok_or_else(|| "license missing in GetLicenseSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetLicenseSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetLicenseSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetLicenseSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetLicenseSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetLicenseSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetLicenseSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetLicenseSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested lyricsList
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetLyricsBySongIdResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetLyricsBySongIdResponseSubsonicResponse>,
}

impl GetLyricsBySongIdResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetLyricsBySongIdResponse {
        GetLyricsBySongIdResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetLyricsBySongIdResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetLyricsBySongIdResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetLyricsBySongIdResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetLyricsBySongIdResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetLyricsBySongIdResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetLyricsBySongIdResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetLyricsBySongIdResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetLyricsBySongIdResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetLyricsBySongIdResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetLyricsBySongIdResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetLyricsBySongIdResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetLyricsBySongIdResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetLyricsBySongIdResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetLyricsBySongIdResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetLyricsBySongIdResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetLyricsBySongIdResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetLyricsBySongIdResponseSubsonicResponse {
    GetLyricsBySongIdSuccessResponse(Box<models::GetLyricsBySongIdSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetLyricsBySongIdResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetLyricsBySongIdSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetLyricsBySongIdSuccessResponse> for GetLyricsBySongIdResponseSubsonicResponse {
    fn from(value: models::GetLyricsBySongIdSuccessResponse) -> Self {
        Self::GetLyricsBySongIdSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetLyricsBySongIdResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetLyricsBySongIdResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetLyricsBySongIdResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetLyricsBySongIdSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "lyricsList")]
    pub lyrics_list: models::LyricsList,
}

impl GetLyricsBySongIdSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        lyrics_list: models::LyricsList,
    ) -> GetLyricsBySongIdSuccessResponse {
        GetLyricsBySongIdSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            lyrics_list,
        }
    }
}

/// Converts the GetLyricsBySongIdSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetLyricsBySongIdSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping lyricsList in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetLyricsBySongIdSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetLyricsBySongIdSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub lyrics_list: Vec<models::LyricsList>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetLyricsBySongIdSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "lyricsList" => intermediate_rep.lyrics_list.push(
                        <models::LyricsList as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetLyricsBySongIdSuccessResponse"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetLyricsBySongIdSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetLyricsBySongIdSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetLyricsBySongIdSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetLyricsBySongIdSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "openSubsonic missing in GetLyricsBySongIdSuccessResponse".to_string()
                })?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetLyricsBySongIdSuccessResponse".to_string())?,
            lyrics_list: intermediate_rep
                .lyrics_list
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "lyricsList missing in GetLyricsBySongIdSuccessResponse".to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetLyricsBySongIdSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetLyricsBySongIdSuccessResponse>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetLyricsBySongIdSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetLyricsBySongIdSuccessResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<GetLyricsBySongIdSuccessResponse>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetLyricsBySongIdSuccessResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetLyricsBySongIdSuccessResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// A subsonic-response element with a nested lyrics element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetLyricsResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetLyricsResponseSubsonicResponse>,
}

impl GetLyricsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetLyricsResponse {
        GetLyricsResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetLyricsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetLyricsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetLyricsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetLyricsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetLyricsResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetLyricsResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(
                        <models::GetLyricsResponseSubsonicResponse as std::str::FromStr>::from_str(
                            val,
                        )
                        .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetLyricsResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetLyricsResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetLyricsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetLyricsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetLyricsResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetLyricsResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetLyricsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetLyricsResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetLyricsResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetLyricsResponseSubsonicResponse {
    GetLyricsSuccessResponse(Box<models::GetLyricsSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetLyricsResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetLyricsSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetLyricsSuccessResponse> for GetLyricsResponseSubsonicResponse {
    fn from(value: models::GetLyricsSuccessResponse) -> Self {
        Self::GetLyricsSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetLyricsResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetLyricsResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetLyricsResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetLyricsSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "lyrics")]
    pub lyrics: models::Lyrics,
}

impl GetLyricsSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        lyrics: models::Lyrics,
    ) -> GetLyricsSuccessResponse {
        GetLyricsSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            lyrics,
        }
    }
}

/// Converts the GetLyricsSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetLyricsSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping lyrics in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetLyricsSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetLyricsSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub lyrics: Vec<models::Lyrics>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetLyricsSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "lyrics" => intermediate_rep.lyrics.push(
                        <models::Lyrics as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetLyricsSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetLyricsSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetLyricsSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetLyricsSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in GetLyricsSuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetLyricsSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetLyricsSuccessResponse".to_string())?,
            lyrics: intermediate_rep
                .lyrics
                .into_iter()
                .next()
                .ok_or_else(|| "lyrics missing in GetLyricsSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetLyricsSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetLyricsSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetLyricsSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetLyricsSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetLyricsSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetLyricsSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetLyricsSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested directory element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetMusicDirectoryResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetMusicDirectoryResponseSubsonicResponse>,
}

impl GetMusicDirectoryResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetMusicDirectoryResponse {
        GetMusicDirectoryResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetMusicDirectoryResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetMusicDirectoryResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetMusicDirectoryResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetMusicDirectoryResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetMusicDirectoryResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetMusicDirectoryResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetMusicDirectoryResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetMusicDirectoryResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetMusicDirectoryResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetMusicDirectoryResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetMusicDirectoryResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetMusicDirectoryResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetMusicDirectoryResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetMusicDirectoryResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetMusicDirectoryResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetMusicDirectoryResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetMusicDirectoryResponseSubsonicResponse {
    GetMusicDirectorySuccessResponse(Box<models::GetMusicDirectorySuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetMusicDirectoryResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetMusicDirectorySuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetMusicDirectorySuccessResponse> for GetMusicDirectoryResponseSubsonicResponse {
    fn from(value: models::GetMusicDirectorySuccessResponse) -> Self {
        Self::GetMusicDirectorySuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetMusicDirectoryResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetMusicDirectoryResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetMusicDirectoryResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetMusicDirectorySuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "directory")]
    pub directory: models::Directory,
}

impl GetMusicDirectorySuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        directory: models::Directory,
    ) -> GetMusicDirectorySuccessResponse {
        GetMusicDirectorySuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            directory,
        }
    }
}

/// Converts the GetMusicDirectorySuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetMusicDirectorySuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping directory in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetMusicDirectorySuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetMusicDirectorySuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub directory: Vec<models::Directory>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetMusicDirectorySuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "directory" => intermediate_rep.directory.push(
                        <models::Directory as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetMusicDirectorySuccessResponse"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetMusicDirectorySuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetMusicDirectorySuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetMusicDirectorySuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetMusicDirectorySuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "openSubsonic missing in GetMusicDirectorySuccessResponse".to_string()
                })?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetMusicDirectorySuccessResponse".to_string())?,
            directory: intermediate_rep
                .directory
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "directory missing in GetMusicDirectorySuccessResponse".to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetMusicDirectorySuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetMusicDirectorySuccessResponse>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetMusicDirectorySuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetMusicDirectorySuccessResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<GetMusicDirectorySuccessResponse>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetMusicDirectorySuccessResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetMusicDirectorySuccessResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// A subsonic-response element with a nested musicFolders element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetMusicFoldersResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetMusicFoldersResponseSubsonicResponse>,
}

impl GetMusicFoldersResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetMusicFoldersResponse {
        GetMusicFoldersResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetMusicFoldersResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetMusicFoldersResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetMusicFoldersResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetMusicFoldersResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetMusicFoldersResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetMusicFoldersResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetMusicFoldersResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetMusicFoldersResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetMusicFoldersResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetMusicFoldersResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetMusicFoldersResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetMusicFoldersResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetMusicFoldersResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetMusicFoldersResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetMusicFoldersResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetMusicFoldersResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetMusicFoldersResponseSubsonicResponse {
    GetMusicFoldersSuccessResponse(Box<models::GetMusicFoldersSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetMusicFoldersResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetMusicFoldersSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetMusicFoldersSuccessResponse> for GetMusicFoldersResponseSubsonicResponse {
    fn from(value: models::GetMusicFoldersSuccessResponse) -> Self {
        Self::GetMusicFoldersSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetMusicFoldersResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetMusicFoldersResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetMusicFoldersResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetMusicFoldersSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "musicFolders")]
    pub music_folders: models::MusicFolders,
}

impl GetMusicFoldersSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        music_folders: models::MusicFolders,
    ) -> GetMusicFoldersSuccessResponse {
        GetMusicFoldersSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            music_folders,
        }
    }
}

/// Converts the GetMusicFoldersSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetMusicFoldersSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping musicFolders in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetMusicFoldersSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetMusicFoldersSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub music_folders: Vec<models::MusicFolders>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetMusicFoldersSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "musicFolders" => intermediate_rep.music_folders.push(
                        <models::MusicFolders as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetMusicFoldersSuccessResponse"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetMusicFoldersSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetMusicFoldersSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetMusicFoldersSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetMusicFoldersSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "openSubsonic missing in GetMusicFoldersSuccessResponse".to_string()
                })?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetMusicFoldersSuccessResponse".to_string())?,
            music_folders: intermediate_rep
                .music_folders
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "musicFolders missing in GetMusicFoldersSuccessResponse".to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetMusicFoldersSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetMusicFoldersSuccessResponse>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetMusicFoldersSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetMusicFoldersSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<GetMusicFoldersSuccessResponse>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetMusicFoldersSuccessResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetMusicFoldersSuccessResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// A subsonic-response element with a nested `newestPodcasts` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetNewestPodcastsResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetNewestPodcastsResponseSubsonicResponse>,
}

impl GetNewestPodcastsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetNewestPodcastsResponse {
        GetNewestPodcastsResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetNewestPodcastsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetNewestPodcastsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetNewestPodcastsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetNewestPodcastsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetNewestPodcastsResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetNewestPodcastsResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetNewestPodcastsResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetNewestPodcastsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetNewestPodcastsResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetNewestPodcastsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetNewestPodcastsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetNewestPodcastsResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetNewestPodcastsResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetNewestPodcastsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetNewestPodcastsResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetNewestPodcastsResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetNewestPodcastsResponseSubsonicResponse {
    GetNewestPodcastsSuccessResponse(Box<models::GetNewestPodcastsSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetNewestPodcastsResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetNewestPodcastsSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetNewestPodcastsSuccessResponse> for GetNewestPodcastsResponseSubsonicResponse {
    fn from(value: models::GetNewestPodcastsSuccessResponse) -> Self {
        Self::GetNewestPodcastsSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetNewestPodcastsResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetNewestPodcastsResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetNewestPodcastsResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetNewestPodcastsSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "newestPodcasts")]
    pub newest_podcasts: models::NewestPodcasts,
}

impl GetNewestPodcastsSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        newest_podcasts: models::NewestPodcasts,
    ) -> GetNewestPodcastsSuccessResponse {
        GetNewestPodcastsSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            newest_podcasts,
        }
    }
}

/// Converts the GetNewestPodcastsSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetNewestPodcastsSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping newestPodcasts in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetNewestPodcastsSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetNewestPodcastsSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub newest_podcasts: Vec<models::NewestPodcasts>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetNewestPodcastsSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "newestPodcasts" => intermediate_rep.newest_podcasts.push(
                        <models::NewestPodcasts as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetNewestPodcastsSuccessResponse"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetNewestPodcastsSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetNewestPodcastsSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetNewestPodcastsSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetNewestPodcastsSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "openSubsonic missing in GetNewestPodcastsSuccessResponse".to_string()
                })?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetNewestPodcastsSuccessResponse".to_string())?,
            newest_podcasts: intermediate_rep
                .newest_podcasts
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "newestPodcasts missing in GetNewestPodcastsSuccessResponse".to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetNewestPodcastsSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetNewestPodcastsSuccessResponse>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetNewestPodcastsSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetNewestPodcastsSuccessResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<GetNewestPodcastsSuccessResponse>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetNewestPodcastsSuccessResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetNewestPodcastsSuccessResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// A subsonic-response element with a nested `nowPlaying` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetNowPlayingResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetNowPlayingResponseSubsonicResponse>,
}

impl GetNowPlayingResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetNowPlayingResponse {
        GetNowPlayingResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetNowPlayingResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetNowPlayingResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetNowPlayingResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetNowPlayingResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetNowPlayingResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetNowPlayingResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetNowPlayingResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetNowPlayingResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetNowPlayingResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetNowPlayingResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetNowPlayingResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetNowPlayingResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetNowPlayingResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetNowPlayingResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetNowPlayingResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetNowPlayingResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetNowPlayingResponseSubsonicResponse {
    GetNowPlayingSuccessResponse(Box<models::GetNowPlayingSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetNowPlayingResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetNowPlayingSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetNowPlayingSuccessResponse> for GetNowPlayingResponseSubsonicResponse {
    fn from(value: models::GetNowPlayingSuccessResponse) -> Self {
        Self::GetNowPlayingSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetNowPlayingResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetNowPlayingResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetNowPlayingResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetNowPlayingSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "nowPlaying")]
    pub now_playing: models::NowPlaying,
}

impl GetNowPlayingSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        now_playing: models::NowPlaying,
    ) -> GetNowPlayingSuccessResponse {
        GetNowPlayingSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            now_playing,
        }
    }
}

/// Converts the GetNowPlayingSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetNowPlayingSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping nowPlaying in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetNowPlayingSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetNowPlayingSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub now_playing: Vec<models::NowPlaying>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetNowPlayingSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nowPlaying" => intermediate_rep.now_playing.push(
                        <models::NowPlaying as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetNowPlayingSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetNowPlayingSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetNowPlayingSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetNowPlayingSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetNowPlayingSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "openSubsonic missing in GetNowPlayingSuccessResponse".to_string()
                })?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetNowPlayingSuccessResponse".to_string())?,
            now_playing: intermediate_rep
                .now_playing
                .into_iter()
                .next()
                .ok_or_else(|| "nowPlaying missing in GetNowPlayingSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetNowPlayingSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetNowPlayingSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetNowPlayingSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetNowPlayingSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetNowPlayingSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetNowPlayingSuccessResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetNowPlayingSuccessResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// A subsonic-response element with a nested `openSubsonicExtensions` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOpenSubsonicExtensionsResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetOpenSubsonicExtensionsResponseSubsonicResponse>,
}

impl GetOpenSubsonicExtensionsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetOpenSubsonicExtensionsResponse {
        GetOpenSubsonicExtensionsResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetOpenSubsonicExtensionsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetOpenSubsonicExtensionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOpenSubsonicExtensionsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOpenSubsonicExtensionsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetOpenSubsonicExtensionsResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetOpenSubsonicExtensionsResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetOpenSubsonicExtensionsResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOpenSubsonicExtensionsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOpenSubsonicExtensionsResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOpenSubsonicExtensionsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOpenSubsonicExtensionsResponse>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetOpenSubsonicExtensionsResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOpenSubsonicExtensionsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<GetOpenSubsonicExtensionsResponse>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOpenSubsonicExtensionsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOpenSubsonicExtensionsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetOpenSubsonicExtensionsResponseSubsonicResponse {
    GetOpenSubsonicExtensionsSuccessResponse(Box<models::GetOpenSubsonicExtensionsSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetOpenSubsonicExtensionsResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetOpenSubsonicExtensionsSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetOpenSubsonicExtensionsSuccessResponse>
    for GetOpenSubsonicExtensionsResponseSubsonicResponse
{
    fn from(value: models::GetOpenSubsonicExtensionsSuccessResponse) -> Self {
        Self::GetOpenSubsonicExtensionsSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetOpenSubsonicExtensionsResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOpenSubsonicExtensionsResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOpenSubsonicExtensionsResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetOpenSubsonicExtensionsSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "openSubsonicExtensions")]
    pub open_subsonic_extensions: Vec<models::OpenSubsonicExtension>,
}

impl GetOpenSubsonicExtensionsSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        open_subsonic_extensions: Vec<models::OpenSubsonicExtension>,
    ) -> GetOpenSubsonicExtensionsSuccessResponse {
        GetOpenSubsonicExtensionsSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            open_subsonic_extensions,
        }
    }
}

/// Converts the GetOpenSubsonicExtensionsSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetOpenSubsonicExtensionsSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping openSubsonicExtensions in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetOpenSubsonicExtensionsSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetOpenSubsonicExtensionsSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub open_subsonic_extensions: Vec<Vec<models::OpenSubsonicExtension>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetOpenSubsonicExtensionsSuccessResponse"
                            .to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "openSubsonicExtensions" => return std::result::Result::Err("Parsing a container in this style is not supported in GetOpenSubsonicExtensionsSuccessResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetOpenSubsonicExtensionsSuccessResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetOpenSubsonicExtensionsSuccessResponse {
            version: intermediate_rep.version.into_iter().next().ok_or_else(|| {
                "version missing in GetOpenSubsonicExtensionsSuccessResponse".to_string()
            })?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| {
                "type missing in GetOpenSubsonicExtensionsSuccessResponse".to_string()
            })?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetOpenSubsonicExtensionsSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "openSubsonic missing in GetOpenSubsonicExtensionsSuccessResponse".to_string()
                })?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| {
                "status missing in GetOpenSubsonicExtensionsSuccessResponse".to_string()
            })?,
            open_subsonic_extensions: intermediate_rep
                .open_subsonic_extensions
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "openSubsonicExtensions missing in GetOpenSubsonicExtensionsSuccessResponse"
                        .to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetOpenSubsonicExtensionsSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetOpenSubsonicExtensionsSuccessResponse>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetOpenSubsonicExtensionsSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetOpenSubsonicExtensionsSuccessResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<GetOpenSubsonicExtensionsSuccessResponse>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetOpenSubsonicExtensionsSuccessResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetOpenSubsonicExtensionsSuccessResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// A subsonic-response element with a nested `PlayQueueByIndex` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPlayQueueByIndexResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetPlayQueueByIndexResponseSubsonicResponse>,
}

impl GetPlayQueueByIndexResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetPlayQueueByIndexResponse {
        GetPlayQueueByIndexResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetPlayQueueByIndexResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetPlayQueueByIndexResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPlayQueueByIndexResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPlayQueueByIndexResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetPlayQueueByIndexResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetPlayQueueByIndexResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetPlayQueueByIndexResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPlayQueueByIndexResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPlayQueueByIndexResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPlayQueueByIndexResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPlayQueueByIndexResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetPlayQueueByIndexResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetPlayQueueByIndexResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetPlayQueueByIndexResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetPlayQueueByIndexResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetPlayQueueByIndexResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetPlayQueueByIndexResponseSubsonicResponse {
    GetPlayQueueByIndexSuccessResponse(Box<models::GetPlayQueueByIndexSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetPlayQueueByIndexResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetPlayQueueByIndexSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetPlayQueueByIndexSuccessResponse>
    for GetPlayQueueByIndexResponseSubsonicResponse
{
    fn from(value: models::GetPlayQueueByIndexSuccessResponse) -> Self {
        Self::GetPlayQueueByIndexSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetPlayQueueByIndexResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPlayQueueByIndexResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPlayQueueByIndexResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPlayQueueByIndexSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "playQueueByIndex")]
    pub play_queue_by_index: models::PlayQueueByIndex,
}

impl GetPlayQueueByIndexSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        play_queue_by_index: models::PlayQueueByIndex,
    ) -> GetPlayQueueByIndexSuccessResponse {
        GetPlayQueueByIndexSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            play_queue_by_index,
        }
    }
}

/// Converts the GetPlayQueueByIndexSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetPlayQueueByIndexSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping playQueueByIndex in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPlayQueueByIndexSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPlayQueueByIndexSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub play_queue_by_index: Vec<models::PlayQueueByIndex>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetPlayQueueByIndexSuccessResponse"
                            .to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "playQueueByIndex" => intermediate_rep.play_queue_by_index.push(
                        <models::PlayQueueByIndex as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetPlayQueueByIndexSuccessResponse"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPlayQueueByIndexSuccessResponse {
            version: intermediate_rep.version.into_iter().next().ok_or_else(|| {
                "version missing in GetPlayQueueByIndexSuccessResponse".to_string()
            })?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetPlayQueueByIndexSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetPlayQueueByIndexSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "openSubsonic missing in GetPlayQueueByIndexSuccessResponse".to_string()
                })?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| {
                "status missing in GetPlayQueueByIndexSuccessResponse".to_string()
            })?,
            play_queue_by_index: intermediate_rep
                .play_queue_by_index
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "playQueueByIndex missing in GetPlayQueueByIndexSuccessResponse".to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPlayQueueByIndexSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPlayQueueByIndexSuccessResponse>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetPlayQueueByIndexSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetPlayQueueByIndexSuccessResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<GetPlayQueueByIndexSuccessResponse>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetPlayQueueByIndexSuccessResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetPlayQueueByIndexSuccessResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// A subsonic-response element with a nested `playQueue` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPlayQueueResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetPlayQueueResponseSubsonicResponse>,
}

impl GetPlayQueueResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetPlayQueueResponse {
        GetPlayQueueResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetPlayQueueResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetPlayQueueResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPlayQueueResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPlayQueueResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetPlayQueueResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetPlayQueueResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetPlayQueueResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPlayQueueResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPlayQueueResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPlayQueueResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPlayQueueResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetPlayQueueResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetPlayQueueResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetPlayQueueResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetPlayQueueResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetPlayQueueResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetPlayQueueResponseSubsonicResponse {
    GetPlayQueueSuccessResponse(Box<models::GetPlayQueueSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetPlayQueueResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetPlayQueueSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetPlayQueueSuccessResponse> for GetPlayQueueResponseSubsonicResponse {
    fn from(value: models::GetPlayQueueSuccessResponse) -> Self {
        Self::GetPlayQueueSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetPlayQueueResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPlayQueueResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPlayQueueResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPlayQueueSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "playQueue")]
    pub play_queue: models::PlayQueue,
}

impl GetPlayQueueSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        play_queue: models::PlayQueue,
    ) -> GetPlayQueueSuccessResponse {
        GetPlayQueueSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            play_queue,
        }
    }
}

/// Converts the GetPlayQueueSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetPlayQueueSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping playQueue in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPlayQueueSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPlayQueueSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub play_queue: Vec<models::PlayQueue>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetPlayQueueSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "playQueue" => intermediate_rep.play_queue.push(
                        <models::PlayQueue as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetPlayQueueSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPlayQueueSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetPlayQueueSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetPlayQueueSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetPlayQueueSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetPlayQueueSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetPlayQueueSuccessResponse".to_string())?,
            play_queue: intermediate_rep
                .play_queue
                .into_iter()
                .next()
                .ok_or_else(|| "playQueue missing in GetPlayQueueSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPlayQueueSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPlayQueueSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetPlayQueueSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetPlayQueueSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetPlayQueueSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetPlayQueueSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetPlayQueueSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested playlist element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPlaylistResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetPlaylistResponseSubsonicResponse>,
}

impl GetPlaylistResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetPlaylistResponse {
        GetPlaylistResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetPlaylistResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetPlaylistResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPlaylistResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPlaylistResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetPlaylistResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetPlaylistResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetPlaylistResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPlaylistResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPlaylistResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPlaylistResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPlaylistResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetPlaylistResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetPlaylistResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetPlaylistResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetPlaylistResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetPlaylistResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetPlaylistResponseSubsonicResponse {
    GetPlaylistSuccessResponse(Box<models::GetPlaylistSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetPlaylistResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetPlaylistSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetPlaylistSuccessResponse> for GetPlaylistResponseSubsonicResponse {
    fn from(value: models::GetPlaylistSuccessResponse) -> Self {
        Self::GetPlaylistSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetPlaylistResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPlaylistResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPlaylistResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPlaylistSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "playlist")]
    pub playlist: models::PlaylistWithSongs,
}

impl GetPlaylistSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        playlist: models::PlaylistWithSongs,
    ) -> GetPlaylistSuccessResponse {
        GetPlaylistSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            playlist,
        }
    }
}

/// Converts the GetPlaylistSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetPlaylistSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping playlist in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPlaylistSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPlaylistSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub playlist: Vec<models::PlaylistWithSongs>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetPlaylistSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "playlist" => intermediate_rep.playlist.push(
                        <models::PlaylistWithSongs as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetPlaylistSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPlaylistSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetPlaylistSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetPlaylistSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in GetPlaylistSuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetPlaylistSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetPlaylistSuccessResponse".to_string())?,
            playlist: intermediate_rep
                .playlist
                .into_iter()
                .next()
                .ok_or_else(|| "playlist missing in GetPlaylistSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPlaylistSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPlaylistSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetPlaylistSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetPlaylistSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetPlaylistSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetPlaylistSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetPlaylistSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested `playlists` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPlaylistsResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetPlaylistsResponseSubsonicResponse>,
}

impl GetPlaylistsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetPlaylistsResponse {
        GetPlaylistsResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetPlaylistsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetPlaylistsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPlaylistsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPlaylistsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetPlaylistsResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetPlaylistsResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetPlaylistsResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPlaylistsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPlaylistsResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPlaylistsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPlaylistsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetPlaylistsResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetPlaylistsResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetPlaylistsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetPlaylistsResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetPlaylistsResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetPlaylistsResponseSubsonicResponse {
    GetPlaylistsSuccessResponse(Box<models::GetPlaylistsSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetPlaylistsResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetPlaylistsSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetPlaylistsSuccessResponse> for GetPlaylistsResponseSubsonicResponse {
    fn from(value: models::GetPlaylistsSuccessResponse) -> Self {
        Self::GetPlaylistsSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetPlaylistsResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPlaylistsResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPlaylistsResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPlaylistsSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "playlists")]
    pub playlists: models::Playlists,
}

impl GetPlaylistsSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        playlists: models::Playlists,
    ) -> GetPlaylistsSuccessResponse {
        GetPlaylistsSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            playlists,
        }
    }
}

/// Converts the GetPlaylistsSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetPlaylistsSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping playlists in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPlaylistsSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPlaylistsSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub playlists: Vec<models::Playlists>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetPlaylistsSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "playlists" => intermediate_rep.playlists.push(
                        <models::Playlists as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetPlaylistsSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPlaylistsSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetPlaylistsSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetPlaylistsSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetPlaylistsSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetPlaylistsSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetPlaylistsSuccessResponse".to_string())?,
            playlists: intermediate_rep
                .playlists
                .into_iter()
                .next()
                .ok_or_else(|| "playlists missing in GetPlaylistsSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPlaylistsSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPlaylistsSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetPlaylistsSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetPlaylistsSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetPlaylistsSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetPlaylistsSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetPlaylistsSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested `podcastEpisode` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPodcastEpisodeResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetPodcastEpisodeResponseSubsonicResponse>,
}

impl GetPodcastEpisodeResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetPodcastEpisodeResponse {
        GetPodcastEpisodeResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetPodcastEpisodeResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetPodcastEpisodeResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPodcastEpisodeResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPodcastEpisodeResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetPodcastEpisodeResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetPodcastEpisodeResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetPodcastEpisodeResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPodcastEpisodeResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPodcastEpisodeResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPodcastEpisodeResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPodcastEpisodeResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetPodcastEpisodeResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetPodcastEpisodeResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetPodcastEpisodeResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetPodcastEpisodeResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetPodcastEpisodeResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetPodcastEpisodeResponseSubsonicResponse {
    GetPodcastEpisodeSuccessResponse(Box<models::GetPodcastEpisodeSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetPodcastEpisodeResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetPodcastEpisodeSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetPodcastEpisodeSuccessResponse> for GetPodcastEpisodeResponseSubsonicResponse {
    fn from(value: models::GetPodcastEpisodeSuccessResponse) -> Self {
        Self::GetPodcastEpisodeSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetPodcastEpisodeResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPodcastEpisodeResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPodcastEpisodeResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPodcastEpisodeSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "podcastEpisode")]
    pub podcast_episode: models::PodcastEpisode,
}

impl GetPodcastEpisodeSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        podcast_episode: models::PodcastEpisode,
    ) -> GetPodcastEpisodeSuccessResponse {
        GetPodcastEpisodeSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            podcast_episode,
        }
    }
}

/// Converts the GetPodcastEpisodeSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetPodcastEpisodeSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping podcastEpisode in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPodcastEpisodeSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPodcastEpisodeSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub podcast_episode: Vec<models::PodcastEpisode>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetPodcastEpisodeSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "podcastEpisode" => intermediate_rep.podcast_episode.push(
                        <models::PodcastEpisode as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetPodcastEpisodeSuccessResponse"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPodcastEpisodeSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetPodcastEpisodeSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetPodcastEpisodeSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetPodcastEpisodeSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "openSubsonic missing in GetPodcastEpisodeSuccessResponse".to_string()
                })?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetPodcastEpisodeSuccessResponse".to_string())?,
            podcast_episode: intermediate_rep
                .podcast_episode
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "podcastEpisode missing in GetPodcastEpisodeSuccessResponse".to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPodcastEpisodeSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPodcastEpisodeSuccessResponse>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetPodcastEpisodeSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetPodcastEpisodeSuccessResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<GetPodcastEpisodeSuccessResponse>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetPodcastEpisodeSuccessResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetPodcastEpisodeSuccessResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// A subsonic-response element with a nested `podcasts` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPodcastsResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetPodcastsResponseSubsonicResponse>,
}

impl GetPodcastsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetPodcastsResponse {
        GetPodcastsResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetPodcastsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetPodcastsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPodcastsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPodcastsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetPodcastsResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetPodcastsResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetPodcastsResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetPodcastsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPodcastsResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPodcastsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPodcastsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetPodcastsResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetPodcastsResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetPodcastsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetPodcastsResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetPodcastsResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetPodcastsResponseSubsonicResponse {
    GetPodcastsSuccessResponse(Box<models::GetPodcastsSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetPodcastsResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetPodcastsSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetPodcastsSuccessResponse> for GetPodcastsResponseSubsonicResponse {
    fn from(value: models::GetPodcastsSuccessResponse) -> Self {
        Self::GetPodcastsSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetPodcastsResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPodcastsResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPodcastsResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetPodcastsSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "podcasts")]
    pub podcasts: models::Podcasts,
}

impl GetPodcastsSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        podcasts: models::Podcasts,
    ) -> GetPodcastsSuccessResponse {
        GetPodcastsSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            podcasts,
        }
    }
}

/// Converts the GetPodcastsSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetPodcastsSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping podcasts in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetPodcastsSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetPodcastsSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub podcasts: Vec<models::Podcasts>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetPodcastsSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "podcasts" => intermediate_rep.podcasts.push(
                        <models::Podcasts as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetPodcastsSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetPodcastsSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetPodcastsSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetPodcastsSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in GetPodcastsSuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetPodcastsSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetPodcastsSuccessResponse".to_string())?,
            podcasts: intermediate_rep
                .podcasts
                .into_iter()
                .next()
                .ok_or_else(|| "podcasts missing in GetPodcastsSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetPodcastsSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetPodcastsSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetPodcastsSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetPodcastsSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetPodcastsSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetPodcastsSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetPodcastsSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested `randomSongs` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetRandomSongsResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetRandomSongsResponseSubsonicResponse>,
}

impl GetRandomSongsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetRandomSongsResponse {
        GetRandomSongsResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetRandomSongsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetRandomSongsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetRandomSongsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetRandomSongsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetRandomSongsResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetRandomSongsResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetRandomSongsResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetRandomSongsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetRandomSongsResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetRandomSongsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetRandomSongsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetRandomSongsResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetRandomSongsResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetRandomSongsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetRandomSongsResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetRandomSongsResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetRandomSongsResponseSubsonicResponse {
    GetRandomSongsSuccessResponse(Box<models::GetRandomSongsSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetRandomSongsResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetRandomSongsSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetRandomSongsSuccessResponse> for GetRandomSongsResponseSubsonicResponse {
    fn from(value: models::GetRandomSongsSuccessResponse) -> Self {
        Self::GetRandomSongsSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetRandomSongsResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetRandomSongsResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetRandomSongsResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetRandomSongsSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "randomSongs")]
    pub random_songs: models::Songs,
}

impl GetRandomSongsSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        random_songs: models::Songs,
    ) -> GetRandomSongsSuccessResponse {
        GetRandomSongsSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            random_songs,
        }
    }
}

/// Converts the GetRandomSongsSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetRandomSongsSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping randomSongs in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetRandomSongsSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetRandomSongsSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub random_songs: Vec<models::Songs>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetRandomSongsSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "randomSongs" => intermediate_rep.random_songs.push(
                        <models::Songs as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetRandomSongsSuccessResponse"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetRandomSongsSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetRandomSongsSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetRandomSongsSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetRandomSongsSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "openSubsonic missing in GetRandomSongsSuccessResponse".to_string()
                })?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetRandomSongsSuccessResponse".to_string())?,
            random_songs: intermediate_rep
                .random_songs
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "randomSongs missing in GetRandomSongsSuccessResponse".to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetRandomSongsSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetRandomSongsSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetRandomSongsSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetRandomSongsSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetRandomSongsSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetRandomSongsSuccessResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetRandomSongsSuccessResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// A subsonic-response element with a nested `scanStatus` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetScanStatusResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetScanStatusResponseSubsonicResponse>,
}

impl GetScanStatusResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetScanStatusResponse {
        GetScanStatusResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetScanStatusResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetScanStatusResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetScanStatusResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetScanStatusResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetScanStatusResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetScanStatusResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetScanStatusResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetScanStatusResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetScanStatusResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetScanStatusResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetScanStatusResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetScanStatusResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetScanStatusResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetScanStatusResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetScanStatusResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetScanStatusResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetScanStatusResponseSubsonicResponse {
    GetScanStatusSuccessResponse(Box<models::GetScanStatusSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetScanStatusResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetScanStatusSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetScanStatusSuccessResponse> for GetScanStatusResponseSubsonicResponse {
    fn from(value: models::GetScanStatusSuccessResponse) -> Self {
        Self::GetScanStatusSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetScanStatusResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetScanStatusResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetScanStatusResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetScanStatusSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "scanStatus")]
    pub scan_status: models::ScanStatus,
}

impl GetScanStatusSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        scan_status: models::ScanStatus,
    ) -> GetScanStatusSuccessResponse {
        GetScanStatusSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            scan_status,
        }
    }
}

/// Converts the GetScanStatusSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetScanStatusSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping scanStatus in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetScanStatusSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetScanStatusSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub scan_status: Vec<models::ScanStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetScanStatusSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "scanStatus" => intermediate_rep.scan_status.push(
                        <models::ScanStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetScanStatusSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetScanStatusSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetScanStatusSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetScanStatusSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetScanStatusSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "openSubsonic missing in GetScanStatusSuccessResponse".to_string()
                })?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetScanStatusSuccessResponse".to_string())?,
            scan_status: intermediate_rep
                .scan_status
                .into_iter()
                .next()
                .ok_or_else(|| "scanStatus missing in GetScanStatusSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetScanStatusSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetScanStatusSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetScanStatusSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetScanStatusSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetScanStatusSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetScanStatusSuccessResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetScanStatusSuccessResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// A subsonic-response element with a nested `shares` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetSharesResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetSharesResponseSubsonicResponse>,
}

impl GetSharesResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetSharesResponse {
        GetSharesResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetSharesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetSharesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetSharesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetSharesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetSharesResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetSharesResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(
                        <models::GetSharesResponseSubsonicResponse as std::str::FromStr>::from_str(
                            val,
                        )
                        .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetSharesResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetSharesResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetSharesResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetSharesResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetSharesResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetSharesResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetSharesResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetSharesResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetSharesResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetSharesResponseSubsonicResponse {
    GetSharesSuccessResponse(Box<models::GetSharesSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetSharesResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetSharesSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetSharesSuccessResponse> for GetSharesResponseSubsonicResponse {
    fn from(value: models::GetSharesSuccessResponse) -> Self {
        Self::GetSharesSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetSharesResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetSharesResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetSharesResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetSharesSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "shares")]
    pub shares: models::Shares,
}

impl GetSharesSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        shares: models::Shares,
    ) -> GetSharesSuccessResponse {
        GetSharesSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            shares,
        }
    }
}

/// Converts the GetSharesSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetSharesSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping shares in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetSharesSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetSharesSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub shares: Vec<models::Shares>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetSharesSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "shares" => intermediate_rep.shares.push(
                        <models::Shares as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetSharesSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetSharesSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetSharesSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetSharesSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in GetSharesSuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetSharesSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetSharesSuccessResponse".to_string())?,
            shares: intermediate_rep
                .shares
                .into_iter()
                .next()
                .ok_or_else(|| "shares missing in GetSharesSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetSharesSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetSharesSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetSharesSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetSharesSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetSharesSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetSharesSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetSharesSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested `similarSongs2` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetSimilarSongs2Response {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetSimilarSongs2ResponseSubsonicResponse>,
}

impl GetSimilarSongs2Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetSimilarSongs2Response {
        GetSimilarSongs2Response {
            subsonic_response: None,
        }
    }
}

/// Converts the GetSimilarSongs2Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetSimilarSongs2Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetSimilarSongs2Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetSimilarSongs2Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetSimilarSongs2ResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetSimilarSongs2Response".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetSimilarSongs2ResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetSimilarSongs2Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetSimilarSongs2Response {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetSimilarSongs2Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetSimilarSongs2Response>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetSimilarSongs2Response>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetSimilarSongs2Response - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetSimilarSongs2Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetSimilarSongs2Response as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetSimilarSongs2Response - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetSimilarSongs2ResponseSubsonicResponse {
    GetSimilarSongs2SuccessResponse(Box<models::GetSimilarSongs2SuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetSimilarSongs2ResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetSimilarSongs2SuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetSimilarSongs2SuccessResponse> for GetSimilarSongs2ResponseSubsonicResponse {
    fn from(value: models::GetSimilarSongs2SuccessResponse) -> Self {
        Self::GetSimilarSongs2SuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetSimilarSongs2ResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetSimilarSongs2ResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetSimilarSongs2ResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetSimilarSongs2SuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "similarSongs2")]
    pub similar_songs2: models::SimilarSongs2,
}

impl GetSimilarSongs2SuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        similar_songs2: models::SimilarSongs2,
    ) -> GetSimilarSongs2SuccessResponse {
        GetSimilarSongs2SuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            similar_songs2,
        }
    }
}

/// Converts the GetSimilarSongs2SuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetSimilarSongs2SuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping similarSongs2 in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetSimilarSongs2SuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetSimilarSongs2SuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub similar_songs2: Vec<models::SimilarSongs2>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetSimilarSongs2SuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "similarSongs2" => intermediate_rep.similar_songs2.push(
                        <models::SimilarSongs2 as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetSimilarSongs2SuccessResponse"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetSimilarSongs2SuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetSimilarSongs2SuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetSimilarSongs2SuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetSimilarSongs2SuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "openSubsonic missing in GetSimilarSongs2SuccessResponse".to_string()
                })?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetSimilarSongs2SuccessResponse".to_string())?,
            similar_songs2: intermediate_rep
                .similar_songs2
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "similarSongs2 missing in GetSimilarSongs2SuccessResponse".to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetSimilarSongs2SuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetSimilarSongs2SuccessResponse>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetSimilarSongs2SuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GetSimilarSongs2SuccessResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<GetSimilarSongs2SuccessResponse>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetSimilarSongs2SuccessResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetSimilarSongs2SuccessResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// A subsonic-response element with a nested `similarSongs` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetSimilarSongsResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetSimilarSongsResponseSubsonicResponse>,
}

impl GetSimilarSongsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetSimilarSongsResponse {
        GetSimilarSongsResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetSimilarSongsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetSimilarSongsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetSimilarSongsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetSimilarSongsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetSimilarSongsResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetSimilarSongsResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetSimilarSongsResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetSimilarSongsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetSimilarSongsResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetSimilarSongsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetSimilarSongsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetSimilarSongsResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetSimilarSongsResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetSimilarSongsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetSimilarSongsResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetSimilarSongsResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetSimilarSongsResponseSubsonicResponse {
    GetSimilarSongsSuccessResponse(Box<models::GetSimilarSongsSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetSimilarSongsResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetSimilarSongsSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetSimilarSongsSuccessResponse> for GetSimilarSongsResponseSubsonicResponse {
    fn from(value: models::GetSimilarSongsSuccessResponse) -> Self {
        Self::GetSimilarSongsSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetSimilarSongsResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetSimilarSongsResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetSimilarSongsResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetSimilarSongsSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "similarSongs")]
    pub similar_songs: models::SimilarSongs,
}

impl GetSimilarSongsSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        similar_songs: models::SimilarSongs,
    ) -> GetSimilarSongsSuccessResponse {
        GetSimilarSongsSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            similar_songs,
        }
    }
}

/// Converts the GetSimilarSongsSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetSimilarSongsSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping similarSongs in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetSimilarSongsSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetSimilarSongsSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub similar_songs: Vec<models::SimilarSongs>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetSimilarSongsSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "similarSongs" => intermediate_rep.similar_songs.push(
                        <models::SimilarSongs as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetSimilarSongsSuccessResponse"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetSimilarSongsSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetSimilarSongsSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetSimilarSongsSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetSimilarSongsSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "openSubsonic missing in GetSimilarSongsSuccessResponse".to_string()
                })?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetSimilarSongsSuccessResponse".to_string())?,
            similar_songs: intermediate_rep
                .similar_songs
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "similarSongs missing in GetSimilarSongsSuccessResponse".to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetSimilarSongsSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetSimilarSongsSuccessResponse>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetSimilarSongsSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetSimilarSongsSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<GetSimilarSongsSuccessResponse>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetSimilarSongsSuccessResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetSimilarSongsSuccessResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// A subsonic-response element with a nested `song` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetSongResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetSongResponseSubsonicResponse>,
}

impl GetSongResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetSongResponse {
        GetSongResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetSongResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetSongResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetSongResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetSongResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetSongResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetSongResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(
                        <models::GetSongResponseSubsonicResponse as std::str::FromStr>::from_str(
                            val,
                        )
                        .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetSongResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetSongResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetSongResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetSongResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetSongResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetSongResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetSongResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetSongResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetSongResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetSongResponseSubsonicResponse {
    GetSongSuccessResponse(Box<models::GetSongSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetSongResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetSongSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetSongSuccessResponse> for GetSongResponseSubsonicResponse {
    fn from(value: models::GetSongSuccessResponse) -> Self {
        Self::GetSongSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetSongResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetSongResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetSongResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetSongSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "song")]
    pub song: models::Child,
}

impl GetSongSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        song: models::Child,
    ) -> GetSongSuccessResponse {
        GetSongSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            song,
        }
    }
}

/// Converts the GetSongSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetSongSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping song in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetSongSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetSongSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub song: Vec<models::Child>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetSongSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "song" => intermediate_rep.song.push(
                        <models::Child as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetSongSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetSongSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetSongSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetSongSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in GetSongSuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetSongSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetSongSuccessResponse".to_string())?,
            song: intermediate_rep
                .song
                .into_iter()
                .next()
                .ok_or_else(|| "song missing in GetSongSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetSongSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetSongSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetSongSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetSongSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetSongSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetSongSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetSongSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested `songsByGenre` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetSongsByGenreResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetSongsByGenreResponseSubsonicResponse>,
}

impl GetSongsByGenreResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetSongsByGenreResponse {
        GetSongsByGenreResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetSongsByGenreResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetSongsByGenreResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetSongsByGenreResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetSongsByGenreResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetSongsByGenreResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetSongsByGenreResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetSongsByGenreResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetSongsByGenreResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetSongsByGenreResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetSongsByGenreResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetSongsByGenreResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetSongsByGenreResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetSongsByGenreResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetSongsByGenreResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetSongsByGenreResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetSongsByGenreResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetSongsByGenreResponseSubsonicResponse {
    GetSongsByGenreSuccessResponse(Box<models::GetSongsByGenreSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetSongsByGenreResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetSongsByGenreSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetSongsByGenreSuccessResponse> for GetSongsByGenreResponseSubsonicResponse {
    fn from(value: models::GetSongsByGenreSuccessResponse) -> Self {
        Self::GetSongsByGenreSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetSongsByGenreResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetSongsByGenreResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetSongsByGenreResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetSongsByGenreSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "songsByGenre")]
    pub songs_by_genre: models::Songs,
}

impl GetSongsByGenreSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        songs_by_genre: models::Songs,
    ) -> GetSongsByGenreSuccessResponse {
        GetSongsByGenreSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            songs_by_genre,
        }
    }
}

/// Converts the GetSongsByGenreSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetSongsByGenreSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping songsByGenre in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetSongsByGenreSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetSongsByGenreSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub songs_by_genre: Vec<models::Songs>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetSongsByGenreSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "songsByGenre" => intermediate_rep.songs_by_genre.push(
                        <models::Songs as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetSongsByGenreSuccessResponse"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetSongsByGenreSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetSongsByGenreSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetSongsByGenreSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetSongsByGenreSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "openSubsonic missing in GetSongsByGenreSuccessResponse".to_string()
                })?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetSongsByGenreSuccessResponse".to_string())?,
            songs_by_genre: intermediate_rep
                .songs_by_genre
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "songsByGenre missing in GetSongsByGenreSuccessResponse".to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetSongsByGenreSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetSongsByGenreSuccessResponse>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetSongsByGenreSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetSongsByGenreSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<GetSongsByGenreSuccessResponse>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GetSongsByGenreSuccessResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GetSongsByGenreSuccessResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// A subsonic-response element with a nested `starred2` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetStarred2Response {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetStarred2ResponseSubsonicResponse>,
}

impl GetStarred2Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetStarred2Response {
        GetStarred2Response {
            subsonic_response: None,
        }
    }
}

/// Converts the GetStarred2Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetStarred2Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetStarred2Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetStarred2Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetStarred2ResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetStarred2Response".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetStarred2ResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetStarred2Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetStarred2Response {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetStarred2Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetStarred2Response>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetStarred2Response>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetStarred2Response - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetStarred2Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetStarred2Response as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetStarred2Response - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetStarred2ResponseSubsonicResponse {
    GetStarred2SuccessResponse(Box<models::GetStarred2SuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetStarred2ResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetStarred2SuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetStarred2SuccessResponse> for GetStarred2ResponseSubsonicResponse {
    fn from(value: models::GetStarred2SuccessResponse) -> Self {
        Self::GetStarred2SuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetStarred2ResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetStarred2ResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetStarred2ResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetStarred2SuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "starred2")]
    pub starred2: models::Starred2,
}

impl GetStarred2SuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        starred2: models::Starred2,
    ) -> GetStarred2SuccessResponse {
        GetStarred2SuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            starred2,
        }
    }
}

/// Converts the GetStarred2SuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetStarred2SuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping starred2 in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetStarred2SuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetStarred2SuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub starred2: Vec<models::Starred2>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetStarred2SuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "starred2" => intermediate_rep.starred2.push(
                        <models::Starred2 as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetStarred2SuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetStarred2SuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetStarred2SuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetStarred2SuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in GetStarred2SuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetStarred2SuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetStarred2SuccessResponse".to_string())?,
            starred2: intermediate_rep
                .starred2
                .into_iter()
                .next()
                .ok_or_else(|| "starred2 missing in GetStarred2SuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetStarred2SuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetStarred2SuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetStarred2SuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetStarred2SuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetStarred2SuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetStarred2SuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetStarred2SuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested `starred` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetStarredResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetStarredResponseSubsonicResponse>,
}

impl GetStarredResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetStarredResponse {
        GetStarredResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetStarredResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetStarredResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetStarredResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetStarredResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetStarredResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetStarredResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetStarredResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetStarredResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetStarredResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetStarredResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetStarredResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetStarredResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetStarredResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetStarredResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetStarredResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetStarredResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetStarredResponseSubsonicResponse {
    GetStarredSuccessResponse(Box<models::GetStarredSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetStarredResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetStarredSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetStarredSuccessResponse> for GetStarredResponseSubsonicResponse {
    fn from(value: models::GetStarredSuccessResponse) -> Self {
        Self::GetStarredSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetStarredResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetStarredResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetStarredResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetStarredSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "starred")]
    pub starred: models::Starred,
}

impl GetStarredSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        starred: models::Starred,
    ) -> GetStarredSuccessResponse {
        GetStarredSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            starred,
        }
    }
}

/// Converts the GetStarredSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetStarredSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping starred in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetStarredSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetStarredSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub starred: Vec<models::Starred>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetStarredSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "starred" => intermediate_rep.starred.push(
                        <models::Starred as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetStarredSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetStarredSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetStarredSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetStarredSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in GetStarredSuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetStarredSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetStarredSuccessResponse".to_string())?,
            starred: intermediate_rep
                .starred
                .into_iter()
                .next()
                .ok_or_else(|| "starred missing in GetStarredSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetStarredSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetStarredSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetStarredSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetStarredSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetStarredSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetStarredSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetStarredSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested tokenInfo on success, or error 44 on invalid token.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetTokenInfoResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetTokenInfoResponseSubsonicResponse>,
}

impl GetTokenInfoResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetTokenInfoResponse {
        GetTokenInfoResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetTokenInfoResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetTokenInfoResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetTokenInfoResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetTokenInfoResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetTokenInfoResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetTokenInfoResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetTokenInfoResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetTokenInfoResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetTokenInfoResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetTokenInfoResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetTokenInfoResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetTokenInfoResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetTokenInfoResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetTokenInfoResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetTokenInfoResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetTokenInfoResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetTokenInfoResponseSubsonicResponse {
    GetTokenInfoSuccessResponse(Box<models::GetTokenInfoSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetTokenInfoResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetTokenInfoSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetTokenInfoSuccessResponse> for GetTokenInfoResponseSubsonicResponse {
    fn from(value: models::GetTokenInfoSuccessResponse) -> Self {
        Self::GetTokenInfoSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetTokenInfoResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetTokenInfoResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetTokenInfoResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetTokenInfoSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "tokenInfo")]
    pub token_info: models::TokenInfo,
}

impl GetTokenInfoSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        token_info: models::TokenInfo,
    ) -> GetTokenInfoSuccessResponse {
        GetTokenInfoSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            token_info,
        }
    }
}

/// Converts the GetTokenInfoSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetTokenInfoSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping tokenInfo in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetTokenInfoSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetTokenInfoSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub token_info: Vec<models::TokenInfo>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetTokenInfoSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "tokenInfo" => intermediate_rep.token_info.push(
                        <models::TokenInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetTokenInfoSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetTokenInfoSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetTokenInfoSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetTokenInfoSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetTokenInfoSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetTokenInfoSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetTokenInfoSuccessResponse".to_string())?,
            token_info: intermediate_rep
                .token_info
                .into_iter()
                .next()
                .ok_or_else(|| "tokenInfo missing in GetTokenInfoSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetTokenInfoSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetTokenInfoSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetTokenInfoSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetTokenInfoSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetTokenInfoSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetTokenInfoSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetTokenInfoSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested `topSongs` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetTopSongsResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetTopSongsResponseSubsonicResponse>,
}

impl GetTopSongsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetTopSongsResponse {
        GetTopSongsResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetTopSongsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetTopSongsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetTopSongsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetTopSongsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetTopSongsResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetTopSongsResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetTopSongsResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetTopSongsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetTopSongsResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetTopSongsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetTopSongsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetTopSongsResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetTopSongsResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetTopSongsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetTopSongsResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetTopSongsResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetTopSongsResponseSubsonicResponse {
    GetTopSongsSuccessResponse(Box<models::GetTopSongsSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetTopSongsResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetTopSongsSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetTopSongsSuccessResponse> for GetTopSongsResponseSubsonicResponse {
    fn from(value: models::GetTopSongsSuccessResponse) -> Self {
        Self::GetTopSongsSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetTopSongsResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetTopSongsResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetTopSongsResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetTopSongsSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "topSongs")]
    pub top_songs: models::TopSongs,
}

impl GetTopSongsSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        top_songs: models::TopSongs,
    ) -> GetTopSongsSuccessResponse {
        GetTopSongsSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            top_songs,
        }
    }
}

/// Converts the GetTopSongsSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetTopSongsSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping topSongs in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetTopSongsSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetTopSongsSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub top_songs: Vec<models::TopSongs>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetTopSongsSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "topSongs" => intermediate_rep.top_songs.push(
                        <models::TopSongs as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetTopSongsSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetTopSongsSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetTopSongsSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetTopSongsSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in GetTopSongsSuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetTopSongsSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetTopSongsSuccessResponse".to_string())?,
            top_songs: intermediate_rep
                .top_songs
                .into_iter()
                .next()
                .ok_or_else(|| "topSongs missing in GetTopSongsSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetTopSongsSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetTopSongsSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetTopSongsSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetTopSongsSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetTopSongsSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetTopSongsSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetTopSongsSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested `user` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetUserResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetUserResponseSubsonicResponse>,
}

impl GetUserResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetUserResponse {
        GetUserResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetUserResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetUserResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetUserResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetUserResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetUserResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetUserResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(
                        <models::GetUserResponseSubsonicResponse as std::str::FromStr>::from_str(
                            val,
                        )
                        .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetUserResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetUserResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetUserResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetUserResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetUserResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetUserResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetUserResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetUserResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetUserResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetUserResponseSubsonicResponse {
    GetUserSuccessResponse(Box<models::GetUserSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetUserResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetUserSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetUserSuccessResponse> for GetUserResponseSubsonicResponse {
    fn from(value: models::GetUserSuccessResponse) -> Self {
        Self::GetUserSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetUserResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetUserResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetUserResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetUserSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "user")]
    pub user: models::User,
}

impl GetUserSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        user: models::User,
    ) -> GetUserSuccessResponse {
        GetUserSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            user,
        }
    }
}

/// Converts the GetUserSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetUserSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping user in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetUserSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetUserSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub user: Vec<models::User>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetUserSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "user" => intermediate_rep.user.push(
                        <models::User as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetUserSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetUserSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetUserSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetUserSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in GetUserSuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetUserSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetUserSuccessResponse".to_string())?,
            user: intermediate_rep
                .user
                .into_iter()
                .next()
                .ok_or_else(|| "user missing in GetUserSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetUserSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetUserSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetUserSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetUserSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetUserSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetUserSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetUserSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested `user` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetUsersResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetUsersResponseSubsonicResponse>,
}

impl GetUsersResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetUsersResponse {
        GetUsersResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetUsersResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetUsersResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetUsersResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetUsersResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetUsersResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetUsersResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(
                        <models::GetUsersResponseSubsonicResponse as std::str::FromStr>::from_str(
                            val,
                        )
                        .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetUsersResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetUsersResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetUsersResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetUsersResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetUsersResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetUsersResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetUsersResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetUsersResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetUsersResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetUsersResponseSubsonicResponse {
    GetUsersSuccessResponse(Box<models::GetUsersSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetUsersResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetUsersSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetUsersSuccessResponse> for GetUsersResponseSubsonicResponse {
    fn from(value: models::GetUsersSuccessResponse) -> Self {
        Self::GetUsersSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetUsersResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetUsersResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetUsersResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetUsersSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "users")]
    pub users: models::Users,
}

impl GetUsersSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        users: models::Users,
    ) -> GetUsersSuccessResponse {
        GetUsersSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            users,
        }
    }
}

/// Converts the GetUsersSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetUsersSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping users in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetUsersSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetUsersSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub users: Vec<models::Users>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetUsersSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "users" => intermediate_rep.users.push(
                        <models::Users as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetUsersSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetUsersSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetUsersSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetUsersSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in GetUsersSuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetUsersSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetUsersSuccessResponse".to_string())?,
            users: intermediate_rep
                .users
                .into_iter()
                .next()
                .ok_or_else(|| "users missing in GetUsersSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetUsersSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetUsersSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetUsersSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetUsersSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetUsersSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetUsersSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetUsersSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested `videoInfo` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetVideoInfoResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetVideoInfoResponseSubsonicResponse>,
}

impl GetVideoInfoResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetVideoInfoResponse {
        GetVideoInfoResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetVideoInfoResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetVideoInfoResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetVideoInfoResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetVideoInfoResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetVideoInfoResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetVideoInfoResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::GetVideoInfoResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GetVideoInfoResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetVideoInfoResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetVideoInfoResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetVideoInfoResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetVideoInfoResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetVideoInfoResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetVideoInfoResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetVideoInfoResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetVideoInfoResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetVideoInfoResponseSubsonicResponse {
    GetVideoInfoSuccessResponse(Box<models::GetVideoInfoSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetVideoInfoResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetVideoInfoSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetVideoInfoSuccessResponse> for GetVideoInfoResponseSubsonicResponse {
    fn from(value: models::GetVideoInfoSuccessResponse) -> Self {
        Self::GetVideoInfoSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetVideoInfoResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetVideoInfoResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetVideoInfoResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetVideoInfoSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    /// videoInfo. TODO
    #[serde(rename = "videoInfo")]
    pub video_info: crate::types::Object,
}

impl GetVideoInfoSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        video_info: crate::types::Object,
    ) -> GetVideoInfoSuccessResponse {
        GetVideoInfoSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            video_info,
        }
    }
}

/// Converts the GetVideoInfoSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetVideoInfoSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping videoInfo in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetVideoInfoSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetVideoInfoSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub video_info: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetVideoInfoSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "videoInfo" => intermediate_rep.video_info.push(
                        <crate::types::Object as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetVideoInfoSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetVideoInfoSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetVideoInfoSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetVideoInfoSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in GetVideoInfoSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetVideoInfoSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetVideoInfoSuccessResponse".to_string())?,
            video_info: intermediate_rep
                .video_info
                .into_iter()
                .next()
                .ok_or_else(|| "videoInfo missing in GetVideoInfoSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetVideoInfoSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetVideoInfoSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetVideoInfoSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetVideoInfoSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetVideoInfoSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetVideoInfoSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetVideoInfoSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested `videos` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetVideosResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::GetVideosResponseSubsonicResponse>,
}

impl GetVideosResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> GetVideosResponse {
        GetVideosResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the GetVideosResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetVideosResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetVideosResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetVideosResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::GetVideosResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetVideosResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(
                        <models::GetVideosResponseSubsonicResponse as std::str::FromStr>::from_str(
                            val,
                        )
                        .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetVideosResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetVideosResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetVideosResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetVideosResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetVideosResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetVideosResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetVideosResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetVideosResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetVideosResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum GetVideosResponseSubsonicResponse {
    GetVideosSuccessResponse(Box<models::GetVideosSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for GetVideosResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::GetVideosSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::GetVideosSuccessResponse> for GetVideosResponseSubsonicResponse {
    fn from(value: models::GetVideosSuccessResponse) -> Self {
        Self::GetVideosSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for GetVideosResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetVideosResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetVideosResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GetVideosSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    /// videos. TODO
    #[serde(rename = "videos")]
    pub videos: crate::types::Object,
}

impl GetVideosSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        videos: crate::types::Object,
    ) -> GetVideosSuccessResponse {
        GetVideosSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            videos,
        }
    }
}

/// Converts the GetVideosSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GetVideosSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping videos in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GetVideosSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GetVideosSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub videos: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GetVideosSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "videos" => intermediate_rep.videos.push(
                        <crate::types::Object as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GetVideosSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GetVideosSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in GetVideosSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in GetVideosSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in GetVideosSuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in GetVideosSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in GetVideosSuccessResponse".to_string())?,
            videos: intermediate_rep
                .videos
                .into_iter()
                .next()
                .ok_or_else(|| "videos missing in GetVideosSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GetVideosSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GetVideosSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GetVideosSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GetVideosSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GetVideosSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GetVideosSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GetVideosSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// An indexed artist list.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Index {
    /// Index name
    #[serde(rename = "name")]
    pub name: String,

    /// Artist list
    #[serde(rename = "artist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist: Option<Vec<models::Artist>>,
}

impl Index {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String) -> Index {
        Index { name, artist: None }
    }
}

/// Converts the Index value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Index {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("name".to_string()),
            Some(self.name.to_string()),
            // Skipping artist in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Index value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Index {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub artist: Vec<Vec<models::Artist>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Index".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "artist" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Index"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Index".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Index {
            name: intermediate_rep
                .name
                .into_iter()
                .next()
                .ok_or_else(|| "name missing in Index".to_string())?,
            artist: intermediate_rep.artist.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Index> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Index>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Index>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Index - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Index> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Index as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Index - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Artist list.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Indexes {
    /// The ignored articles
    #[serde(rename = "ignoredArticles")]
    pub ignored_articles: String,

    /// Last time the index was modified in milliseconds after January 1, 1970 UTC
    #[serde(rename = "lastModified")]
    pub last_modified: i32,

    /// Shortcut
    #[serde(rename = "shortcut")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shortcut: Option<Vec<models::Artist>>,

    /// Array of children
    #[serde(rename = "child")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub child: Option<Vec<models::Child>>,

    /// Indexed artists
    #[serde(rename = "index")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index: Option<Vec<models::Index>>,
}

impl Indexes {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(ignored_articles: String, last_modified: i32) -> Indexes {
        Indexes {
            ignored_articles,
            last_modified,
            shortcut: None,
            child: None,
            index: None,
        }
    }
}

/// Converts the Indexes value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Indexes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("ignoredArticles".to_string()),
            Some(self.ignored_articles.to_string()),
            Some("lastModified".to_string()),
            Some(self.last_modified.to_string()),
            // Skipping shortcut in query parameter serialization

            // Skipping child in query parameter serialization

            // Skipping index in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Indexes value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Indexes {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ignored_articles: Vec<String>,
            pub last_modified: Vec<i32>,
            pub shortcut: Vec<Vec<models::Artist>>,
            pub child: Vec<Vec<models::Child>>,
            pub index: Vec<Vec<models::Index>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Indexes".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ignoredArticles" => intermediate_rep.ignored_articles.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "lastModified" => intermediate_rep.last_modified.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "shortcut" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Indexes"
                                .to_string(),
                        )
                    }
                    "child" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Indexes"
                                .to_string(),
                        )
                    }
                    "index" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Indexes"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Indexes".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Indexes {
            ignored_articles: intermediate_rep
                .ignored_articles
                .into_iter()
                .next()
                .ok_or_else(|| "ignoredArticles missing in Indexes".to_string())?,
            last_modified: intermediate_rep
                .last_modified
                .into_iter()
                .next()
                .ok_or_else(|| "lastModified missing in Indexes".to_string())?,
            shortcut: intermediate_rep.shortcut.into_iter().next(),
            child: intermediate_rep.child.into_iter().next(),
            index: intermediate_rep.index.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Indexes> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Indexes>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Indexes>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Indexes - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Indexes> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Indexes as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Indexes - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// An internetRadioStation.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InternetRadioStation {
    /// The Id
    #[serde(rename = "id")]
    pub id: String,

    /// The name
    #[serde(rename = "name")]
    pub name: String,

    /// The streamUrl
    #[serde(rename = "streamUrl")]
    pub stream_url: String,

    /// Genre name
    #[serde(rename = "homePageUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub home_page_url: Option<String>,
}

impl InternetRadioStation {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, name: String, stream_url: String) -> InternetRadioStation {
        InternetRadioStation {
            id,
            name,
            stream_url,
            home_page_url: None,
        }
    }
}

/// Converts the InternetRadioStation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InternetRadioStation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            Some("name".to_string()),
            Some(self.name.to_string()),
            Some("streamUrl".to_string()),
            Some(self.stream_url.to_string()),
            self.home_page_url.as_ref().map(|home_page_url| {
                ["homePageUrl".to_string(), home_page_url.to_string()].join(",")
            }),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InternetRadioStation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InternetRadioStation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub stream_url: Vec<String>,
            pub home_page_url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing InternetRadioStation".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "streamUrl" => intermediate_rep.stream_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "homePageUrl" => intermediate_rep.home_page_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing InternetRadioStation".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InternetRadioStation {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in InternetRadioStation".to_string())?,
            name: intermediate_rep
                .name
                .into_iter()
                .next()
                .ok_or_else(|| "name missing in InternetRadioStation".to_string())?,
            stream_url: intermediate_rep
                .stream_url
                .into_iter()
                .next()
                .ok_or_else(|| "streamUrl missing in InternetRadioStation".to_string())?,
            home_page_url: intermediate_rep.home_page_url.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InternetRadioStation> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InternetRadioStation>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<InternetRadioStation>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for InternetRadioStation - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InternetRadioStation> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <InternetRadioStation as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into InternetRadioStation - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// internetRadioStations.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InternetRadioStations {
    /// A list of internetRadioStation
    #[serde(rename = "internetRadioStation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub internet_radio_station: Option<Vec<models::InternetRadioStation>>,
}

impl InternetRadioStations {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InternetRadioStations {
        InternetRadioStations {
            internet_radio_station: None,
        }
    }
}

/// Converts the InternetRadioStations value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InternetRadioStations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping internetRadioStation in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InternetRadioStations value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InternetRadioStations {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub internet_radio_station: Vec<Vec<models::InternetRadioStation>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing InternetRadioStations".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "internetRadioStation" => return std::result::Result::Err("Parsing a container in this style is not supported in InternetRadioStations".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing InternetRadioStations".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InternetRadioStations {
            internet_radio_station: intermediate_rep.internet_radio_station.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InternetRadioStations> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InternetRadioStations>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<InternetRadioStations>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for InternetRadioStations - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InternetRadioStations> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <InternetRadioStations as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into InternetRadioStations - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A date for a media item that may be just a year, or year-month, or full date.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemDate {
    /// The year
    #[serde(rename = "year")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub year: Option<i32>,

    /// The month (1-12)
    #[serde(rename = "month")]
    #[validate(range(min = 1u8, max = 12u8))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub month: Option<u8>,

    /// The day (1-31)
    #[serde(rename = "day")]
    #[validate(range(min = 1u8, max = 31u8))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub day: Option<u8>,
}

impl ItemDate {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ItemDate {
        ItemDate {
            year: None,
            month: None,
            day: None,
        }
    }
}

/// Converts the ItemDate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemDate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            self.year
                .as_ref()
                .map(|year| ["year".to_string(), year.to_string()].join(",")),
            self.month
                .as_ref()
                .map(|month| ["month".to_string(), month.to_string()].join(",")),
            self.day
                .as_ref()
                .map(|day| ["day".to_string(), day.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemDate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemDate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub year: Vec<i32>,
            pub month: Vec<u8>,
            pub day: Vec<u8>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ItemDate".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "year" => intermediate_rep.year.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "month" => intermediate_rep
                        .month
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "day" => intermediate_rep
                        .day
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ItemDate".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemDate {
            year: intermediate_rep.year.into_iter().next(),
            month: intermediate_rep.month.into_iter().next(),
            day: intermediate_rep.day.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemDate> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemDate>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ItemDate>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ItemDate - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemDate> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ItemDate as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ItemDate - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A genre returned in list of genres for an item.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemGenre {
    /// Genre name
    #[serde(rename = "name")]
    pub name: String,
}

impl ItemGenre {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String) -> ItemGenre {
        ItemGenre { name }
    }
}

/// Converts the ItemGenre value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemGenre {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> =
            vec![Some("name".to_string()), Some(self.name.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemGenre value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemGenre {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ItemGenre".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ItemGenre".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemGenre {
            name: intermediate_rep
                .name
                .into_iter()
                .next()
                .ok_or_else(|| "name missing in ItemGenre".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemGenre> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemGenre>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ItemGenre>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ItemGenre - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemGenre> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ItemGenre as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ItemGenre - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// JukeBox action.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum JukeboxAction {
    #[serde(rename = "get")]
    Get,
    #[serde(rename = "status")]
    Status,
    #[serde(rename = "set")]
    Set,
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "stop")]
    Stop,
    #[serde(rename = "skip")]
    Skip,
    #[serde(rename = "add")]
    Add,
    #[serde(rename = "clear")]
    Clear,
    #[serde(rename = "remove")]
    Remove,
    #[serde(rename = "shuffle")]
    Shuffle,
    #[serde(rename = "setGain")]
    SetGain,
}

impl std::fmt::Display for JukeboxAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            JukeboxAction::Get => write!(f, "get"),
            JukeboxAction::Status => write!(f, "status"),
            JukeboxAction::Set => write!(f, "set"),
            JukeboxAction::Start => write!(f, "start"),
            JukeboxAction::Stop => write!(f, "stop"),
            JukeboxAction::Skip => write!(f, "skip"),
            JukeboxAction::Add => write!(f, "add"),
            JukeboxAction::Clear => write!(f, "clear"),
            JukeboxAction::Remove => write!(f, "remove"),
            JukeboxAction::Shuffle => write!(f, "shuffle"),
            JukeboxAction::SetGain => write!(f, "setGain"),
        }
    }
}

impl std::str::FromStr for JukeboxAction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "get" => std::result::Result::Ok(JukeboxAction::Get),
            "status" => std::result::Result::Ok(JukeboxAction::Status),
            "set" => std::result::Result::Ok(JukeboxAction::Set),
            "start" => std::result::Result::Ok(JukeboxAction::Start),
            "stop" => std::result::Result::Ok(JukeboxAction::Stop),
            "skip" => std::result::Result::Ok(JukeboxAction::Skip),
            "add" => std::result::Result::Ok(JukeboxAction::Add),
            "clear" => std::result::Result::Ok(JukeboxAction::Clear),
            "remove" => std::result::Result::Ok(JukeboxAction::Remove),
            "shuffle" => std::result::Result::Ok(JukeboxAction::Shuffle),
            "setGain" => std::result::Result::Ok(JukeboxAction::SetGain),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// A subsonic-response element with a nested :  - jukeboxStatus for all actions but get - jukeboxPlaylist for get action
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct JukeboxControlResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::JukeboxControlResponseSubsonicResponse>,
}

impl JukeboxControlResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> JukeboxControlResponse {
        JukeboxControlResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the JukeboxControlResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for JukeboxControlResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a JukeboxControlResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for JukeboxControlResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::JukeboxControlResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing JukeboxControlResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(<models::JukeboxControlResponseSubsonicResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing JukeboxControlResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(JukeboxControlResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<JukeboxControlResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<JukeboxControlResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<JukeboxControlResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for JukeboxControlResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<JukeboxControlResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <JukeboxControlResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into JukeboxControlResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum JukeboxControlResponseSubsonicResponse {
    JukeboxControlSuccessResponse(Box<models::JukeboxControlSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for JukeboxControlResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::JukeboxControlSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::JukeboxControlSuccessResponse> for JukeboxControlResponseSubsonicResponse {
    fn from(value: models::JukeboxControlSuccessResponse) -> Self {
        Self::JukeboxControlSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for JukeboxControlResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a JukeboxControlResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for JukeboxControlResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct JukeboxControlSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "jukeboxStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub jukebox_status: Option<models::JukeboxStatus>,

    #[serde(rename = "jukeboxPlaylist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub jukebox_playlist: Option<models::JukeboxPlaylist>,
}

impl JukeboxControlSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
    ) -> JukeboxControlSuccessResponse {
        JukeboxControlSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            jukebox_status: None,
            jukebox_playlist: None,
        }
    }
}

/// Converts the JukeboxControlSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for JukeboxControlSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping jukeboxStatus in query parameter serialization

            // Skipping jukeboxPlaylist in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a JukeboxControlSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for JukeboxControlSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub jukebox_status: Vec<models::JukeboxStatus>,
            pub jukebox_playlist: Vec<models::JukeboxPlaylist>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing JukeboxControlSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "jukeboxStatus" => intermediate_rep.jukebox_status.push(
                        <models::JukeboxStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "jukeboxPlaylist" => intermediate_rep.jukebox_playlist.push(
                        <models::JukeboxPlaylist as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing JukeboxControlSuccessResponse"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(JukeboxControlSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in JukeboxControlSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in JukeboxControlSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "serverVersion missing in JukeboxControlSuccessResponse".to_string()
                })?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "openSubsonic missing in JukeboxControlSuccessResponse".to_string()
                })?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in JukeboxControlSuccessResponse".to_string())?,
            jukebox_status: intermediate_rep.jukebox_status.into_iter().next(),
            jukebox_playlist: intermediate_rep.jukebox_playlist.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<JukeboxControlSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<JukeboxControlSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<JukeboxControlSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for JukeboxControlSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<JukeboxControlSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <JukeboxControlSuccessResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into JukeboxControlSuccessResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct JukeboxPlaylist {
    /// The current index of the song being played
    #[serde(rename = "currentIndex")]
    pub current_index: i32,

    /// Whether the queue is currently playing
    #[serde(rename = "playing")]
    pub playing: bool,

    /// Volume, in a range of [0.0, 1.0]
    #[serde(rename = "volume")]
    #[validate(range(min = 0u8, max = 1u8))]
    pub volume: u8,

    /// The current position of the track in seconds
    #[serde(rename = "position")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub position: Option<i32>,

    /// The songs currently enqueued in the jukebox
    #[serde(rename = "entry")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entry: Option<Vec<models::Child>>,
}

impl JukeboxPlaylist {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(current_index: i32, playing: bool, volume: u8) -> JukeboxPlaylist {
        JukeboxPlaylist {
            current_index,
            playing,
            volume,
            position: None,
            entry: None,
        }
    }
}

/// Converts the JukeboxPlaylist value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for JukeboxPlaylist {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("currentIndex".to_string()),
            Some(self.current_index.to_string()),
            Some("playing".to_string()),
            Some(self.playing.to_string()),
            Some("volume".to_string()),
            Some(self.volume.to_string()),
            self.position
                .as_ref()
                .map(|position| ["position".to_string(), position.to_string()].join(",")),
            // Skipping entry in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a JukeboxPlaylist value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for JukeboxPlaylist {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub current_index: Vec<i32>,
            pub playing: Vec<bool>,
            pub volume: Vec<u8>,
            pub position: Vec<i32>,
            pub entry: Vec<Vec<models::Child>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing JukeboxPlaylist".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "currentIndex" => intermediate_rep.current_index.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "playing" => intermediate_rep.playing.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "volume" => intermediate_rep
                        .volume
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "position" => intermediate_rep.position.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "entry" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in JukeboxPlaylist"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing JukeboxPlaylist".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(JukeboxPlaylist {
            current_index: intermediate_rep
                .current_index
                .into_iter()
                .next()
                .ok_or_else(|| "currentIndex missing in JukeboxPlaylist".to_string())?,
            playing: intermediate_rep
                .playing
                .into_iter()
                .next()
                .ok_or_else(|| "playing missing in JukeboxPlaylist".to_string())?,
            volume: intermediate_rep
                .volume
                .into_iter()
                .next()
                .ok_or_else(|| "volume missing in JukeboxPlaylist".to_string())?,
            position: intermediate_rep.position.into_iter().next(),
            entry: intermediate_rep.entry.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<JukeboxPlaylist> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<JukeboxPlaylist>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<JukeboxPlaylist>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for JukeboxPlaylist - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<JukeboxPlaylist> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <JukeboxPlaylist as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into JukeboxPlaylist - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// jukeboxStatus.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct JukeboxStatus {
    /// The current index of the song being played
    #[serde(rename = "currentIndex")]
    pub current_index: i32,

    /// Whether the queue is currently playing
    #[serde(rename = "playing")]
    pub playing: bool,

    /// Volume, in a range of [0.0, 1.0]
    #[serde(rename = "volume")]
    #[validate(range(min = 0u8, max = 1u8))]
    pub volume: u8,

    /// The current position of the track in seconds
    #[serde(rename = "position")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub position: Option<i32>,
}

impl JukeboxStatus {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(current_index: i32, playing: bool, volume: u8) -> JukeboxStatus {
        JukeboxStatus {
            current_index,
            playing,
            volume,
            position: None,
        }
    }
}

/// Converts the JukeboxStatus value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for JukeboxStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("currentIndex".to_string()),
            Some(self.current_index.to_string()),
            Some("playing".to_string()),
            Some(self.playing.to_string()),
            Some("volume".to_string()),
            Some(self.volume.to_string()),
            self.position
                .as_ref()
                .map(|position| ["position".to_string(), position.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a JukeboxStatus value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for JukeboxStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub current_index: Vec<i32>,
            pub playing: Vec<bool>,
            pub volume: Vec<u8>,
            pub position: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing JukeboxStatus".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "currentIndex" => intermediate_rep.current_index.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "playing" => intermediate_rep.playing.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "volume" => intermediate_rep
                        .volume
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "position" => intermediate_rep.position.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing JukeboxStatus".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(JukeboxStatus {
            current_index: intermediate_rep
                .current_index
                .into_iter()
                .next()
                .ok_or_else(|| "currentIndex missing in JukeboxStatus".to_string())?,
            playing: intermediate_rep
                .playing
                .into_iter()
                .next()
                .ok_or_else(|| "playing missing in JukeboxStatus".to_string())?,
            volume: intermediate_rep
                .volume
                .into_iter()
                .next()
                .ok_or_else(|| "volume missing in JukeboxStatus".to_string())?,
            position: intermediate_rep.position.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<JukeboxStatus> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<JukeboxStatus>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<JukeboxStatus>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for JukeboxStatus - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<JukeboxStatus> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <JukeboxStatus as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into JukeboxStatus - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// getLicense result.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct License {
    /// The status of the license
    #[serde(rename = "valid")]
    pub valid: bool,

    /// User email
    #[serde(rename = "email")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,

    /// End of license date. [ISO 8601]
    #[serde(rename = "licenseExpires")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub license_expires: Option<chrono::DateTime<chrono::Utc>>,

    /// End of trial date. [ISO 8601]
    #[serde(rename = "trialExpires")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trial_expires: Option<chrono::DateTime<chrono::Utc>>,
}

impl License {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(valid: bool) -> License {
        License {
            valid,
            email: None,
            license_expires: None,
            trial_expires: None,
        }
    }
}

/// Converts the License value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for License {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("valid".to_string()),
            Some(self.valid.to_string()),
            self.email
                .as_ref()
                .map(|email| ["email".to_string(), email.to_string()].join(",")),
            // Skipping licenseExpires in query parameter serialization

            // Skipping trialExpires in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a License value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for License {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub valid: Vec<bool>,
            pub email: Vec<String>,
            pub license_expires: Vec<chrono::DateTime<chrono::Utc>>,
            pub trial_expires: Vec<chrono::DateTime<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing License".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "valid" => intermediate_rep.valid.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "email" => intermediate_rep.email.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "licenseExpires" => intermediate_rep.license_expires.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "trialExpires" => intermediate_rep.trial_expires.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing License".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(License {
            valid: intermediate_rep
                .valid
                .into_iter()
                .next()
                .ok_or_else(|| "valid missing in License".to_string())?,
            email: intermediate_rep.email.into_iter().next(),
            license_expires: intermediate_rep.license_expires.into_iter().next(),
            trial_expires: intermediate_rep.trial_expires.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<License> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<License>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<License>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for License - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<License> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <License as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into License - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// One line of a song lyric
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Line {
    /// The actual text of this line
    #[serde(rename = "value")]
    pub value: String,

    /// The start time of the lyrics, relative to the start time of the track, in milliseconds. If this is not part of synced lyrics, start __must__ be omitted
    #[serde(rename = "start")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<f64>,
}

impl Line {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(value: String) -> Line {
        Line { value, start: None }
    }
}

/// Converts the Line value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Line {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("value".to_string()),
            Some(self.value.to_string()),
            self.start
                .as_ref()
                .map(|start| ["start".to_string(), start.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Line value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Line {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub value: Vec<String>,
            pub start: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Line".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "start" => intermediate_rep.start.push(
                        <f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Line".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Line {
            value: intermediate_rep
                .value
                .into_iter()
                .next()
                .ok_or_else(|| "value missing in Line".to_string())?,
            start: intermediate_rep.start.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Line> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Line>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Line>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Line - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Line> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Line as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Line - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Lyrics.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Lyrics {
    /// The lyrics
    #[serde(rename = "value")]
    pub value: String,

    /// The artist name
    #[serde(rename = "artist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist: Option<String>,

    /// The song title
    #[serde(rename = "title")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}

impl Lyrics {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(value: String) -> Lyrics {
        Lyrics {
            value,
            artist: None,
            title: None,
        }
    }
}

/// Converts the Lyrics value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Lyrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("value".to_string()),
            Some(self.value.to_string()),
            self.artist
                .as_ref()
                .map(|artist| ["artist".to_string(), artist.to_string()].join(",")),
            self.title
                .as_ref()
                .map(|title| ["title".to_string(), title.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Lyrics value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Lyrics {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub value: Vec<String>,
            pub artist: Vec<String>,
            pub title: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Lyrics".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artist" => intermediate_rep.artist.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Lyrics".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Lyrics {
            value: intermediate_rep
                .value
                .into_iter()
                .next()
                .ok_or_else(|| "value missing in Lyrics".to_string())?,
            artist: intermediate_rep.artist.into_iter().next(),
            title: intermediate_rep.title.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Lyrics> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Lyrics>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Lyrics>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Lyrics - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Lyrics> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Lyrics as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Lyrics - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// List of structured lyrics
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LyricsList {
    /// Structured lyrics. There can be multiple lyrics of the same type with the same language
    #[serde(rename = "structuredLyrics")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub structured_lyrics: Option<Vec<models::StructuredLyrics>>,
}

impl LyricsList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LyricsList {
        LyricsList {
            structured_lyrics: None,
        }
    }
}

/// Converts the LyricsList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LyricsList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping structuredLyrics in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LyricsList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LyricsList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub structured_lyrics: Vec<Vec<models::StructuredLyrics>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing LyricsList".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "structuredLyrics" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in LyricsList"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing LyricsList".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LyricsList {
            structured_lyrics: intermediate_rep.structured_lyrics.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LyricsList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LyricsList>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<LyricsList>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for LyricsList - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LyricsList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <LyricsList as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into LyricsList - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Note: If you support `musicBrainzId` you must support this field to ensure clients knows what the ID refers to.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum MediaType {
    #[serde(rename = "song")]
    Song,
    #[serde(rename = "album")]
    Album,
    #[serde(rename = "artist")]
    Artist,
}

impl std::fmt::Display for MediaType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            MediaType::Song => write!(f, "song"),
            MediaType::Album => write!(f, "album"),
            MediaType::Artist => write!(f, "artist"),
        }
    }
}

impl std::str::FromStr for MediaType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "song" => std::result::Result::Ok(MediaType::Song),
            "album" => std::result::Result::Ok(MediaType::Album),
            "artist" => std::result::Result::Ok(MediaType::Artist),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// MusicFolder.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MusicFolder {
    /// The id
    #[serde(rename = "id")]
    pub id: i32,

    /// The folder name
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
}

impl MusicFolder {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32) -> MusicFolder {
        MusicFolder { id, name: None }
    }
}

/// Converts the MusicFolder value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MusicFolder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            self.name
                .as_ref()
                .map(|name| ["name".to_string(), name.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MusicFolder value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MusicFolder {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MusicFolder".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MusicFolder".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MusicFolder {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in MusicFolder".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MusicFolder> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MusicFolder>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MusicFolder>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MusicFolder - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MusicFolder> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MusicFolder as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MusicFolder - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// MusicFolders.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MusicFolders {
    /// The folders
    #[serde(rename = "musicFolder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_folder: Option<Vec<models::MusicFolder>>,
}

impl MusicFolders {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> MusicFolders {
        MusicFolders { music_folder: None }
    }
}

/// Converts the MusicFolders value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MusicFolders {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping musicFolder in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MusicFolders value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MusicFolders {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub music_folder: Vec<Vec<models::MusicFolder>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MusicFolders".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "musicFolder" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MusicFolders"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MusicFolders".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MusicFolders {
            music_folder: intermediate_rep.music_folder.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MusicFolders> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MusicFolders>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MusicFolders>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MusicFolders - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MusicFolders> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MusicFolders as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MusicFolders - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// NewestPodcasts.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NewestPodcasts {
    #[serde(rename = "episode")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub episode: Option<Vec<models::PodcastEpisode>>,
}

impl NewestPodcasts {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NewestPodcasts {
        NewestPodcasts { episode: None }
    }
}

/// Converts the NewestPodcasts value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NewestPodcasts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping episode in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NewestPodcasts value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NewestPodcasts {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub episode: Vec<Vec<models::PodcastEpisode>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NewestPodcasts".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "episode" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NewestPodcasts"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NewestPodcasts".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NewestPodcasts {
            episode: intermediate_rep.episode.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NewestPodcasts> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NewestPodcasts>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NewestPodcasts>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NewestPodcasts - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NewestPodcasts> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NewestPodcasts as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NewestPodcasts - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// nowPlaying.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NowPlaying {
    /// The now playing entries
    #[serde(rename = "entry")]
    pub entry: Vec<models::NowPlayingEntry>,
}

impl NowPlaying {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(entry: Vec<models::NowPlayingEntry>) -> NowPlaying {
        NowPlaying { entry }
    }
}

/// Converts the NowPlaying value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NowPlaying {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping entry in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NowPlaying value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NowPlaying {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub entry: Vec<Vec<models::NowPlayingEntry>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NowPlaying".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "entry" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NowPlaying"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NowPlaying".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NowPlaying {
            entry: intermediate_rep
                .entry
                .into_iter()
                .next()
                .ok_or_else(|| "entry missing in NowPlaying".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NowPlaying> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NowPlaying>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NowPlaying>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NowPlaying - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NowPlaying> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NowPlaying as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NowPlaying - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NowPlayingEntry {
    /// The id of the media.
    #[serde(rename = "id")]
    pub id: String,

    /// The id of the parent (folder/album)
    #[serde(rename = "parent")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent: Option<String>,

    /// The media is a directory
    #[serde(rename = "isDir")]
    pub is_dir: bool,

    /// The media name.
    #[serde(rename = "title")]
    pub title: String,

    /// The album name.
    #[serde(rename = "album")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album: Option<String>,

    /// The artist name.
    #[serde(rename = "artist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist: Option<String>,

    /// The track number.
    #[serde(rename = "track")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub track: Option<i32>,

    /// The media year.
    #[serde(rename = "year")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub year: Option<i32>,

    /// The media genre
    #[serde(rename = "genre")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub genre: Option<String>,

    /// The coverArt id.
    #[serde(rename = "coverArt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cover_art: Option<String>,

    /// A file size of the media.
    #[serde(rename = "size")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<i32>,

    /// The mimeType of the media.
    #[serde(rename = "contentType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content_type: Option<String>,

    /// The file suffix of the media.
    #[serde(rename = "suffix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suffix: Option<String>,

    /// The transcoded mediaType if transcoding should happen.
    #[serde(rename = "transcodedContentType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transcoded_content_type: Option<String>,

    /// The file suffix of the transcoded media.
    #[serde(rename = "transcodedSuffix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transcoded_suffix: Option<String>,

    /// The duration of the media in seconds.
    #[serde(rename = "duration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub duration: Option<i32>,

    /// The bitrate of the media.
    #[serde(rename = "bitRate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bit_rate: Option<i32>,

    /// The bit depth of the media.
    #[serde(rename = "bitDepth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bit_depth: Option<i32>,

    /// The sampling rate of the media.
    #[serde(rename = "samplingRate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sampling_rate: Option<i32>,

    /// The number of channels of the media.
    #[serde(rename = "channelCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel_count: Option<i32>,

    /// The full path of the media.
    #[serde(rename = "path")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,

    /// Media is a video
    #[serde(rename = "isVideo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_video: Option<bool>,

    /// The user rating of the media [1-5]
    #[serde(rename = "userRating")]
    #[validate(range(min = 1u8, max = 5u8))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_rating: Option<u8>,

    /// The average rating of the media [1.0-5.0]
    #[serde(rename = "averageRating")]
    #[validate(range(min = 0f64, max = 5f64))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub average_rating: Option<f64>,

    /// The play count.
    #[serde(rename = "playCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub play_count: Option<i32>,

    /// The disc number.
    #[serde(rename = "discNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disc_number: Option<i32>,

    /// Date the media was created. [ISO 8601]
    #[serde(rename = "created")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created: Option<chrono::DateTime<chrono::Utc>>,

    /// Date the media was starred. [ISO 8601]
    #[serde(rename = "starred")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub starred: Option<chrono::DateTime<chrono::Utc>>,

    /// The corresponding album id
    #[serde(rename = "albumId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album_id: Option<String>,

    /// The corresponding artist id
    #[serde(rename = "artistId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist_id: Option<String>,

    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub r#type: Option<models::GenericMediaType>,

    #[serde(rename = "mediaType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub media_type: Option<models::MediaType>,

    /// The bookmark position in seconds
    #[serde(rename = "bookmarkPosition")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bookmark_position: Option<i32>,

    /// The video original Width
    #[serde(rename = "originalWidth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub original_width: Option<i32>,

    /// The video original Height
    #[serde(rename = "originalHeight")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub original_height: Option<i32>,

    /// Date the album was last played. [ISO 8601]
    #[serde(rename = "played")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub played: Option<chrono::DateTime<chrono::Utc>>,

    /// The BPM of the song.
    #[serde(rename = "bpm")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bpm: Option<i32>,

    /// The comment tag of the song.
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,

    /// The song sort name.
    #[serde(rename = "sortName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sort_name: Option<String>,

    /// The track MusicBrainzID.
    #[serde(rename = "musicBrainzId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_brainz_id: Option<String>,

    /// The track ISRC(s).
    #[serde(rename = "isrc")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub isrc: Option<Vec<String>>,

    /// The list of all genres of the song.
    #[serde(rename = "genres")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub genres: Option<Vec<models::ItemGenre>>,

    /// The list of all song artists of the song. (Note: Only the required `ArtistID3` fields should be returned by default)
    #[serde(rename = "artists")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artists: Option<Vec<models::ArtistId3>>,

    /// The single value display artist.
    #[serde(rename = "displayArtist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display_artist: Option<String>,

    /// The list of all album artists of the song. (Note: Only the required `ArtistID3` fields should be returned by default)
    #[serde(rename = "albumArtists")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album_artists: Option<Vec<models::ArtistId3>>,

    /// The single value display album artist.
    #[serde(rename = "displayAlbumArtist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display_album_artist: Option<String>,

    /// The list of all contributor artists of the song.
    #[serde(rename = "contributors")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contributors: Option<Vec<models::Contributor>>,

    /// The single value display composer.
    #[serde(rename = "displayComposer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display_composer: Option<String>,

    /// The list of all moods of the song.
    #[serde(rename = "moods")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moods: Option<Vec<String>>,

    /// The replay gain data of the song.
    #[serde(rename = "replayGain")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replay_gain: Option<models::ReplayGain>,

    #[serde(rename = "explicitStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub explicit_status: Option<models::ExplicitStatus>,

    /// The username
    #[serde(rename = "username")]
    pub username: String,

    /// Last update
    #[serde(rename = "minutesAgo")]
    pub minutes_ago: i32,

    /// Player Id
    #[serde(rename = "playerId")]
    pub player_id: i32,

    /// Player name
    #[serde(rename = "playerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub player_name: Option<String>,
}

impl NowPlayingEntry {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        id: String,
        is_dir: bool,
        title: String,
        username: String,
        minutes_ago: i32,
        player_id: i32,
    ) -> NowPlayingEntry {
        NowPlayingEntry {
            id,
            parent: None,
            is_dir,
            title,
            album: None,
            artist: None,
            track: None,
            year: None,
            genre: None,
            cover_art: None,
            size: None,
            content_type: None,
            suffix: None,
            transcoded_content_type: None,
            transcoded_suffix: None,
            duration: None,
            bit_rate: None,
            bit_depth: None,
            sampling_rate: None,
            channel_count: None,
            path: None,
            is_video: None,
            user_rating: None,
            average_rating: None,
            play_count: None,
            disc_number: None,
            created: None,
            starred: None,
            album_id: None,
            artist_id: None,
            r#type: None,
            media_type: None,
            bookmark_position: None,
            original_width: None,
            original_height: None,
            played: None,
            bpm: None,
            comment: None,
            sort_name: None,
            music_brainz_id: None,
            isrc: None,
            genres: None,
            artists: None,
            display_artist: None,
            album_artists: None,
            display_album_artist: None,
            contributors: None,
            display_composer: None,
            moods: None,
            replay_gain: None,
            explicit_status: None,
            username,
            minutes_ago,
            player_id,
            player_name: None,
        }
    }
}

/// Converts the NowPlayingEntry value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NowPlayingEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            self.parent
                .as_ref()
                .map(|parent| ["parent".to_string(), parent.to_string()].join(",")),
            Some("isDir".to_string()),
            Some(self.is_dir.to_string()),
            Some("title".to_string()),
            Some(self.title.to_string()),
            self.album
                .as_ref()
                .map(|album| ["album".to_string(), album.to_string()].join(",")),
            self.artist
                .as_ref()
                .map(|artist| ["artist".to_string(), artist.to_string()].join(",")),
            self.track
                .as_ref()
                .map(|track| ["track".to_string(), track.to_string()].join(",")),
            self.year
                .as_ref()
                .map(|year| ["year".to_string(), year.to_string()].join(",")),
            self.genre
                .as_ref()
                .map(|genre| ["genre".to_string(), genre.to_string()].join(",")),
            self.cover_art
                .as_ref()
                .map(|cover_art| ["coverArt".to_string(), cover_art.to_string()].join(",")),
            self.size
                .as_ref()
                .map(|size| ["size".to_string(), size.to_string()].join(",")),
            self.content_type.as_ref().map(|content_type| {
                ["contentType".to_string(), content_type.to_string()].join(",")
            }),
            self.suffix
                .as_ref()
                .map(|suffix| ["suffix".to_string(), suffix.to_string()].join(",")),
            self.transcoded_content_type
                .as_ref()
                .map(|transcoded_content_type| {
                    [
                        "transcodedContentType".to_string(),
                        transcoded_content_type.to_string(),
                    ]
                    .join(",")
                }),
            self.transcoded_suffix.as_ref().map(|transcoded_suffix| {
                [
                    "transcodedSuffix".to_string(),
                    transcoded_suffix.to_string(),
                ]
                .join(",")
            }),
            self.duration
                .as_ref()
                .map(|duration| ["duration".to_string(), duration.to_string()].join(",")),
            self.bit_rate
                .as_ref()
                .map(|bit_rate| ["bitRate".to_string(), bit_rate.to_string()].join(",")),
            self.bit_depth
                .as_ref()
                .map(|bit_depth| ["bitDepth".to_string(), bit_depth.to_string()].join(",")),
            self.sampling_rate.as_ref().map(|sampling_rate| {
                ["samplingRate".to_string(), sampling_rate.to_string()].join(",")
            }),
            self.channel_count.as_ref().map(|channel_count| {
                ["channelCount".to_string(), channel_count.to_string()].join(",")
            }),
            self.path
                .as_ref()
                .map(|path| ["path".to_string(), path.to_string()].join(",")),
            self.is_video
                .as_ref()
                .map(|is_video| ["isVideo".to_string(), is_video.to_string()].join(",")),
            self.user_rating
                .as_ref()
                .map(|user_rating| ["userRating".to_string(), user_rating.to_string()].join(",")),
            self.average_rating.as_ref().map(|average_rating| {
                ["averageRating".to_string(), average_rating.to_string()].join(",")
            }),
            self.play_count
                .as_ref()
                .map(|play_count| ["playCount".to_string(), play_count.to_string()].join(",")),
            self.disc_number
                .as_ref()
                .map(|disc_number| ["discNumber".to_string(), disc_number.to_string()].join(",")),
            // Skipping created in query parameter serialization

            // Skipping starred in query parameter serialization
            self.album_id
                .as_ref()
                .map(|album_id| ["albumId".to_string(), album_id.to_string()].join(",")),
            self.artist_id
                .as_ref()
                .map(|artist_id| ["artistId".to_string(), artist_id.to_string()].join(",")),
            // Skipping type in query parameter serialization

            // Skipping mediaType in query parameter serialization
            self.bookmark_position.as_ref().map(|bookmark_position| {
                [
                    "bookmarkPosition".to_string(),
                    bookmark_position.to_string(),
                ]
                .join(",")
            }),
            self.original_width.as_ref().map(|original_width| {
                ["originalWidth".to_string(), original_width.to_string()].join(",")
            }),
            self.original_height.as_ref().map(|original_height| {
                ["originalHeight".to_string(), original_height.to_string()].join(",")
            }),
            // Skipping played in query parameter serialization
            self.bpm
                .as_ref()
                .map(|bpm| ["bpm".to_string(), bpm.to_string()].join(",")),
            self.comment
                .as_ref()
                .map(|comment| ["comment".to_string(), comment.to_string()].join(",")),
            self.sort_name
                .as_ref()
                .map(|sort_name| ["sortName".to_string(), sort_name.to_string()].join(",")),
            self.music_brainz_id.as_ref().map(|music_brainz_id| {
                ["musicBrainzId".to_string(), music_brainz_id.to_string()].join(",")
            }),
            self.isrc.as_ref().map(|isrc| {
                [
                    "isrc".to_string(),
                    isrc.iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping genres in query parameter serialization

            // Skipping artists in query parameter serialization
            self.display_artist.as_ref().map(|display_artist| {
                ["displayArtist".to_string(), display_artist.to_string()].join(",")
            }),
            // Skipping albumArtists in query parameter serialization
            self.display_album_artist
                .as_ref()
                .map(|display_album_artist| {
                    [
                        "displayAlbumArtist".to_string(),
                        display_album_artist.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping contributors in query parameter serialization
            self.display_composer.as_ref().map(|display_composer| {
                ["displayComposer".to_string(), display_composer.to_string()].join(",")
            }),
            self.moods.as_ref().map(|moods| {
                [
                    "moods".to_string(),
                    moods
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping replayGain in query parameter serialization

            // Skipping explicitStatus in query parameter serialization
            Some("username".to_string()),
            Some(self.username.to_string()),
            Some("minutesAgo".to_string()),
            Some(self.minutes_ago.to_string()),
            Some("playerId".to_string()),
            Some(self.player_id.to_string()),
            self.player_name
                .as_ref()
                .map(|player_name| ["playerName".to_string(), player_name.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NowPlayingEntry value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NowPlayingEntry {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub parent: Vec<String>,
            pub is_dir: Vec<bool>,
            pub title: Vec<String>,
            pub album: Vec<String>,
            pub artist: Vec<String>,
            pub track: Vec<i32>,
            pub year: Vec<i32>,
            pub genre: Vec<String>,
            pub cover_art: Vec<String>,
            pub size: Vec<i32>,
            pub content_type: Vec<String>,
            pub suffix: Vec<String>,
            pub transcoded_content_type: Vec<String>,
            pub transcoded_suffix: Vec<String>,
            pub duration: Vec<i32>,
            pub bit_rate: Vec<i32>,
            pub bit_depth: Vec<i32>,
            pub sampling_rate: Vec<i32>,
            pub channel_count: Vec<i32>,
            pub path: Vec<String>,
            pub is_video: Vec<bool>,
            pub user_rating: Vec<u8>,
            pub average_rating: Vec<f64>,
            pub play_count: Vec<i32>,
            pub disc_number: Vec<i32>,
            pub created: Vec<chrono::DateTime<chrono::Utc>>,
            pub starred: Vec<chrono::DateTime<chrono::Utc>>,
            pub album_id: Vec<String>,
            pub artist_id: Vec<String>,
            pub r#type: Vec<models::GenericMediaType>,
            pub media_type: Vec<models::MediaType>,
            pub bookmark_position: Vec<i32>,
            pub original_width: Vec<i32>,
            pub original_height: Vec<i32>,
            pub played: Vec<chrono::DateTime<chrono::Utc>>,
            pub bpm: Vec<i32>,
            pub comment: Vec<String>,
            pub sort_name: Vec<String>,
            pub music_brainz_id: Vec<String>,
            pub isrc: Vec<Vec<String>>,
            pub genres: Vec<Vec<models::ItemGenre>>,
            pub artists: Vec<Vec<models::ArtistId3>>,
            pub display_artist: Vec<String>,
            pub album_artists: Vec<Vec<models::ArtistId3>>,
            pub display_album_artist: Vec<String>,
            pub contributors: Vec<Vec<models::Contributor>>,
            pub display_composer: Vec<String>,
            pub moods: Vec<Vec<String>>,
            pub replay_gain: Vec<models::ReplayGain>,
            pub explicit_status: Vec<models::ExplicitStatus>,
            pub username: Vec<String>,
            pub minutes_ago: Vec<i32>,
            pub player_id: Vec<i32>,
            pub player_name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NowPlayingEntry".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "parent" => intermediate_rep.parent.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "isDir" => intermediate_rep.is_dir.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "album" => intermediate_rep.album.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artist" => intermediate_rep.artist.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "track" => intermediate_rep.track.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "year" => intermediate_rep.year.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "genre" => intermediate_rep.genre.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "coverArt" => intermediate_rep.cover_art.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "size" => intermediate_rep.size.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "contentType" => intermediate_rep.content_type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "suffix" => intermediate_rep.suffix.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "transcodedContentType" => intermediate_rep.transcoded_content_type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "transcodedSuffix" => intermediate_rep.transcoded_suffix.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "duration" => intermediate_rep.duration.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "bitRate" => intermediate_rep.bit_rate.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "bitDepth" => intermediate_rep.bit_depth.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "samplingRate" => intermediate_rep.sampling_rate.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "channelCount" => intermediate_rep.channel_count.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "isVideo" => intermediate_rep.is_video.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "userRating" => intermediate_rep
                        .user_rating
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "averageRating" => intermediate_rep.average_rating.push(
                        <f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "playCount" => intermediate_rep.play_count.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "discNumber" => intermediate_rep.disc_number.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "starred" => intermediate_rep.starred.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "albumId" => intermediate_rep.album_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artistId" => intermediate_rep.artist_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <models::GenericMediaType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "mediaType" => intermediate_rep.media_type.push(
                        <models::MediaType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "bookmarkPosition" => intermediate_rep.bookmark_position.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "originalWidth" => intermediate_rep.original_width.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "originalHeight" => intermediate_rep.original_height.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "played" => intermediate_rep.played.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "bpm" => intermediate_rep.bpm.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "comment" => intermediate_rep.comment.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sortName" => intermediate_rep.sort_name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "musicBrainzId" => intermediate_rep.music_brainz_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "isrc" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NowPlayingEntry"
                                .to_string(),
                        )
                    }
                    "genres" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NowPlayingEntry"
                                .to_string(),
                        )
                    }
                    "artists" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NowPlayingEntry"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "displayArtist" => intermediate_rep.display_artist.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "albumArtists" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NowPlayingEntry"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "displayAlbumArtist" => intermediate_rep.display_album_artist.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "contributors" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NowPlayingEntry"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "displayComposer" => intermediate_rep.display_composer.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "moods" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NowPlayingEntry"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "replayGain" => intermediate_rep.replay_gain.push(
                        <models::ReplayGain as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "explicitStatus" => intermediate_rep.explicit_status.push(
                        <models::ExplicitStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "minutesAgo" => intermediate_rep.minutes_ago.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "playerId" => intermediate_rep.player_id.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "playerName" => intermediate_rep.player_name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NowPlayingEntry".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NowPlayingEntry {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in NowPlayingEntry".to_string())?,
            parent: intermediate_rep.parent.into_iter().next(),
            is_dir: intermediate_rep
                .is_dir
                .into_iter()
                .next()
                .ok_or_else(|| "isDir missing in NowPlayingEntry".to_string())?,
            title: intermediate_rep
                .title
                .into_iter()
                .next()
                .ok_or_else(|| "title missing in NowPlayingEntry".to_string())?,
            album: intermediate_rep.album.into_iter().next(),
            artist: intermediate_rep.artist.into_iter().next(),
            track: intermediate_rep.track.into_iter().next(),
            year: intermediate_rep.year.into_iter().next(),
            genre: intermediate_rep.genre.into_iter().next(),
            cover_art: intermediate_rep.cover_art.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
            content_type: intermediate_rep.content_type.into_iter().next(),
            suffix: intermediate_rep.suffix.into_iter().next(),
            transcoded_content_type: intermediate_rep.transcoded_content_type.into_iter().next(),
            transcoded_suffix: intermediate_rep.transcoded_suffix.into_iter().next(),
            duration: intermediate_rep.duration.into_iter().next(),
            bit_rate: intermediate_rep.bit_rate.into_iter().next(),
            bit_depth: intermediate_rep.bit_depth.into_iter().next(),
            sampling_rate: intermediate_rep.sampling_rate.into_iter().next(),
            channel_count: intermediate_rep.channel_count.into_iter().next(),
            path: intermediate_rep.path.into_iter().next(),
            is_video: intermediate_rep.is_video.into_iter().next(),
            user_rating: intermediate_rep.user_rating.into_iter().next(),
            average_rating: intermediate_rep.average_rating.into_iter().next(),
            play_count: intermediate_rep.play_count.into_iter().next(),
            disc_number: intermediate_rep.disc_number.into_iter().next(),
            created: intermediate_rep.created.into_iter().next(),
            starred: intermediate_rep.starred.into_iter().next(),
            album_id: intermediate_rep.album_id.into_iter().next(),
            artist_id: intermediate_rep.artist_id.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            media_type: intermediate_rep.media_type.into_iter().next(),
            bookmark_position: intermediate_rep.bookmark_position.into_iter().next(),
            original_width: intermediate_rep.original_width.into_iter().next(),
            original_height: intermediate_rep.original_height.into_iter().next(),
            played: intermediate_rep.played.into_iter().next(),
            bpm: intermediate_rep.bpm.into_iter().next(),
            comment: intermediate_rep.comment.into_iter().next(),
            sort_name: intermediate_rep.sort_name.into_iter().next(),
            music_brainz_id: intermediate_rep.music_brainz_id.into_iter().next(),
            isrc: intermediate_rep.isrc.into_iter().next(),
            genres: intermediate_rep.genres.into_iter().next(),
            artists: intermediate_rep.artists.into_iter().next(),
            display_artist: intermediate_rep.display_artist.into_iter().next(),
            album_artists: intermediate_rep.album_artists.into_iter().next(),
            display_album_artist: intermediate_rep.display_album_artist.into_iter().next(),
            contributors: intermediate_rep.contributors.into_iter().next(),
            display_composer: intermediate_rep.display_composer.into_iter().next(),
            moods: intermediate_rep.moods.into_iter().next(),
            replay_gain: intermediate_rep.replay_gain.into_iter().next(),
            explicit_status: intermediate_rep.explicit_status.into_iter().next(),
            username: intermediate_rep
                .username
                .into_iter()
                .next()
                .ok_or_else(|| "username missing in NowPlayingEntry".to_string())?,
            minutes_ago: intermediate_rep
                .minutes_ago
                .into_iter()
                .next()
                .ok_or_else(|| "minutesAgo missing in NowPlayingEntry".to_string())?,
            player_id: intermediate_rep
                .player_id
                .into_iter()
                .next()
                .ok_or_else(|| "playerId missing in NowPlayingEntry".to_string())?,
            player_name: intermediate_rep.player_name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NowPlayingEntry> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NowPlayingEntry>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NowPlayingEntry>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NowPlayingEntry - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NowPlayingEntry> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NowPlayingEntry as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NowPlayingEntry - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A supported OpenSubsonic API extension.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OpenSubsonicExtension {
    /// The name of the extension.
    #[serde(rename = "name")]
    pub name: String,

    /// The list of supported versions of the this extension.
    #[serde(rename = "versions")]
    pub versions: Vec<i32>,
}

impl OpenSubsonicExtension {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, versions: Vec<i32>) -> OpenSubsonicExtension {
        OpenSubsonicExtension { name, versions }
    }
}

/// Converts the OpenSubsonicExtension value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OpenSubsonicExtension {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("name".to_string()),
            Some(self.name.to_string()),
            Some("versions".to_string()),
            Some(
                self.versions
                    .iter()
                    .map(|x| x.to_string())
                    .collect::<Vec<_>>()
                    .join(","),
            ),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OpenSubsonicExtension value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OpenSubsonicExtension {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub versions: Vec<Vec<i32>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing OpenSubsonicExtension".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "versions" => return std::result::Result::Err("Parsing a container in this style is not supported in OpenSubsonicExtension".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing OpenSubsonicExtension".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OpenSubsonicExtension {
            name: intermediate_rep
                .name
                .into_iter()
                .next()
                .ok_or_else(|| "name missing in OpenSubsonicExtension".to_string())?,
            versions: intermediate_rep
                .versions
                .into_iter()
                .next()
                .ok_or_else(|| "versions missing in OpenSubsonicExtension".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OpenSubsonicExtension> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OpenSubsonicExtension>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<OpenSubsonicExtension>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for OpenSubsonicExtension - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OpenSubsonicExtension> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <OpenSubsonicExtension as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into OpenSubsonicExtension - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// NowPlayingEntry.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PlayQueue {
    /// ID of currently playing track
    #[serde(rename = "current")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub current: Option<String>,

    /// Position in milliseconds of currently playing track
    #[serde(rename = "position")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub position: Option<i32>,

    /// The user this queue belongs to
    #[serde(rename = "username")]
    pub username: String,

    /// Date modified [ISO 8601]
    #[serde(rename = "changed")]
    pub changed: chrono::DateTime<chrono::Utc>,

    /// Name of client app
    #[serde(rename = "changedBy")]
    pub changed_by: String,

    /// The list of songs in the queue
    #[serde(rename = "entry")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entry: Option<Vec<models::Child>>,
}

impl PlayQueue {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        username: String,
        changed: chrono::DateTime<chrono::Utc>,
        changed_by: String,
    ) -> PlayQueue {
        PlayQueue {
            current: None,
            position: None,
            username,
            changed,
            changed_by,
            entry: None,
        }
    }
}

/// Converts the PlayQueue value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PlayQueue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            self.current
                .as_ref()
                .map(|current| ["current".to_string(), current.to_string()].join(",")),
            self.position
                .as_ref()
                .map(|position| ["position".to_string(), position.to_string()].join(",")),
            Some("username".to_string()),
            Some(self.username.to_string()),
            // Skipping changed in query parameter serialization
            Some("changedBy".to_string()),
            Some(self.changed_by.to_string()),
            // Skipping entry in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PlayQueue value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PlayQueue {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub current: Vec<String>,
            pub position: Vec<i32>,
            pub username: Vec<String>,
            pub changed: Vec<chrono::DateTime<chrono::Utc>>,
            pub changed_by: Vec<String>,
            pub entry: Vec<Vec<models::Child>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PlayQueue".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "current" => intermediate_rep.current.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "position" => intermediate_rep.position.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "changed" => intermediate_rep.changed.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "changedBy" => intermediate_rep.changed_by.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "entry" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PlayQueue"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PlayQueue".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PlayQueue {
            current: intermediate_rep.current.into_iter().next(),
            position: intermediate_rep.position.into_iter().next(),
            username: intermediate_rep
                .username
                .into_iter()
                .next()
                .ok_or_else(|| "username missing in PlayQueue".to_string())?,
            changed: intermediate_rep
                .changed
                .into_iter()
                .next()
                .ok_or_else(|| "changed missing in PlayQueue".to_string())?,
            changed_by: intermediate_rep
                .changed_by
                .into_iter()
                .next()
                .ok_or_else(|| "changedBy missing in PlayQueue".to_string())?,
            entry: intermediate_rep.entry.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PlayQueue> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PlayQueue>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PlayQueue>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PlayQueue - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PlayQueue> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PlayQueue as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PlayQueue - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// NowPlayingEntry with queue index.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PlayQueueByIndex {
    /// index of currently playing track
    #[serde(rename = "currentIndex")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub current_index: Option<i32>,

    /// Position in milliseconds of currently playing track
    #[serde(rename = "position")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub position: Option<i32>,

    /// The user this queue belongs to
    #[serde(rename = "username")]
    pub username: String,

    /// Date modified [ISO 8601]
    #[serde(rename = "changed")]
    pub changed: chrono::DateTime<chrono::Utc>,

    /// Name of client app
    #[serde(rename = "changedBy")]
    pub changed_by: String,

    /// The list of songs in the queue
    #[serde(rename = "entry")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entry: Option<Vec<models::Child>>,
}

impl PlayQueueByIndex {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        username: String,
        changed: chrono::DateTime<chrono::Utc>,
        changed_by: String,
    ) -> PlayQueueByIndex {
        PlayQueueByIndex {
            current_index: None,
            position: None,
            username,
            changed,
            changed_by,
            entry: None,
        }
    }
}

/// Converts the PlayQueueByIndex value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PlayQueueByIndex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            self.current_index.as_ref().map(|current_index| {
                ["currentIndex".to_string(), current_index.to_string()].join(",")
            }),
            self.position
                .as_ref()
                .map(|position| ["position".to_string(), position.to_string()].join(",")),
            Some("username".to_string()),
            Some(self.username.to_string()),
            // Skipping changed in query parameter serialization
            Some("changedBy".to_string()),
            Some(self.changed_by.to_string()),
            // Skipping entry in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PlayQueueByIndex value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PlayQueueByIndex {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub current_index: Vec<i32>,
            pub position: Vec<i32>,
            pub username: Vec<String>,
            pub changed: Vec<chrono::DateTime<chrono::Utc>>,
            pub changed_by: Vec<String>,
            pub entry: Vec<Vec<models::Child>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PlayQueueByIndex".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "currentIndex" => intermediate_rep.current_index.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "position" => intermediate_rep.position.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "changed" => intermediate_rep.changed.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "changedBy" => intermediate_rep.changed_by.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "entry" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in PlayQueueByIndex"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PlayQueueByIndex".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PlayQueueByIndex {
            current_index: intermediate_rep.current_index.into_iter().next(),
            position: intermediate_rep.position.into_iter().next(),
            username: intermediate_rep
                .username
                .into_iter()
                .next()
                .ok_or_else(|| "username missing in PlayQueueByIndex".to_string())?,
            changed: intermediate_rep
                .changed
                .into_iter()
                .next()
                .ok_or_else(|| "changed missing in PlayQueueByIndex".to_string())?,
            changed_by: intermediate_rep
                .changed_by
                .into_iter()
                .next()
                .ok_or_else(|| "changedBy missing in PlayQueueByIndex".to_string())?,
            entry: intermediate_rep.entry.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PlayQueueByIndex> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PlayQueueByIndex>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PlayQueueByIndex>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PlayQueueByIndex - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PlayQueueByIndex> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PlayQueueByIndex as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PlayQueueByIndex - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Playlist.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Playlist {
    /// Id of the playlist
    #[serde(rename = "id")]
    pub id: String,

    /// Name of the playlist
    #[serde(rename = "name")]
    pub name: String,

    /// A comment
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,

    /// Owner of the playlist
    #[serde(rename = "owner")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub owner: Option<String>,

    /// Is the playlist public
    #[serde(rename = "public")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub public: Option<bool>,

    /// number of songs
    #[serde(rename = "songCount")]
    pub song_count: i32,

    /// Playlist duration in seconds
    #[serde(rename = "duration")]
    pub duration: i32,

    /// Creation date [ISO 8601]
    #[serde(rename = "created")]
    pub created: chrono::DateTime<chrono::Utc>,

    /// Last changed date [ISO 8601]
    #[serde(rename = "changed")]
    pub changed: chrono::DateTime<chrono::Utc>,

    /// A cover Art Id
    #[serde(rename = "coverArt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cover_art: Option<String>,

    /// A list of allowed usernames
    #[serde(rename = "allowedUser")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed_user: Option<Vec<String>>,
}

impl Playlist {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        id: String,
        name: String,
        song_count: i32,
        duration: i32,
        created: chrono::DateTime<chrono::Utc>,
        changed: chrono::DateTime<chrono::Utc>,
    ) -> Playlist {
        Playlist {
            id,
            name,
            comment: None,
            owner: None,
            public: None,
            song_count,
            duration,
            created,
            changed,
            cover_art: None,
            allowed_user: None,
        }
    }
}

/// Converts the Playlist value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Playlist {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            Some("name".to_string()),
            Some(self.name.to_string()),
            self.comment
                .as_ref()
                .map(|comment| ["comment".to_string(), comment.to_string()].join(",")),
            self.owner
                .as_ref()
                .map(|owner| ["owner".to_string(), owner.to_string()].join(",")),
            self.public
                .as_ref()
                .map(|public| ["public".to_string(), public.to_string()].join(",")),
            Some("songCount".to_string()),
            Some(self.song_count.to_string()),
            Some("duration".to_string()),
            Some(self.duration.to_string()),
            // Skipping created in query parameter serialization

            // Skipping changed in query parameter serialization
            self.cover_art
                .as_ref()
                .map(|cover_art| ["coverArt".to_string(), cover_art.to_string()].join(",")),
            self.allowed_user.as_ref().map(|allowed_user| {
                [
                    "allowedUser".to_string(),
                    allowed_user
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Playlist value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Playlist {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub comment: Vec<String>,
            pub owner: Vec<String>,
            pub public: Vec<bool>,
            pub song_count: Vec<i32>,
            pub duration: Vec<i32>,
            pub created: Vec<chrono::DateTime<chrono::Utc>>,
            pub changed: Vec<chrono::DateTime<chrono::Utc>>,
            pub cover_art: Vec<String>,
            pub allowed_user: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Playlist".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "comment" => intermediate_rep.comment.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "owner" => intermediate_rep.owner.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "public" => intermediate_rep.public.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "songCount" => intermediate_rep.song_count.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "duration" => intermediate_rep.duration.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "changed" => intermediate_rep.changed.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "coverArt" => intermediate_rep.cover_art.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "allowedUser" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Playlist"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Playlist".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Playlist {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in Playlist".to_string())?,
            name: intermediate_rep
                .name
                .into_iter()
                .next()
                .ok_or_else(|| "name missing in Playlist".to_string())?,
            comment: intermediate_rep.comment.into_iter().next(),
            owner: intermediate_rep.owner.into_iter().next(),
            public: intermediate_rep.public.into_iter().next(),
            song_count: intermediate_rep
                .song_count
                .into_iter()
                .next()
                .ok_or_else(|| "songCount missing in Playlist".to_string())?,
            duration: intermediate_rep
                .duration
                .into_iter()
                .next()
                .ok_or_else(|| "duration missing in Playlist".to_string())?,
            created: intermediate_rep
                .created
                .into_iter()
                .next()
                .ok_or_else(|| "created missing in Playlist".to_string())?,
            changed: intermediate_rep
                .changed
                .into_iter()
                .next()
                .ok_or_else(|| "changed missing in Playlist".to_string())?,
            cover_art: intermediate_rep.cover_art.into_iter().next(),
            allowed_user: intermediate_rep.allowed_user.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Playlist> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Playlist>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Playlist>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Playlist - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Playlist> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Playlist as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Playlist - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PlaylistWithSongs {
    /// Id of the playlist
    #[serde(rename = "id")]
    pub id: String,

    /// Name of the playlist
    #[serde(rename = "name")]
    pub name: String,

    /// A comment
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,

    /// Owner of the playlist
    #[serde(rename = "owner")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub owner: Option<String>,

    /// Is the playlist public
    #[serde(rename = "public")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub public: Option<bool>,

    /// number of songs
    #[serde(rename = "songCount")]
    pub song_count: i32,

    /// Playlist duration in seconds
    #[serde(rename = "duration")]
    pub duration: i32,

    /// Creation date [ISO 8601]
    #[serde(rename = "created")]
    pub created: chrono::DateTime<chrono::Utc>,

    /// Last changed date [ISO 8601]
    #[serde(rename = "changed")]
    pub changed: chrono::DateTime<chrono::Utc>,

    /// A cover Art Id
    #[serde(rename = "coverArt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cover_art: Option<String>,

    /// A list of allowed usernames
    #[serde(rename = "allowedUser")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed_user: Option<Vec<String>>,

    /// The list of songs
    #[serde(rename = "entry")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entry: Option<Vec<models::Child>>,
}

impl PlaylistWithSongs {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        id: String,
        name: String,
        song_count: i32,
        duration: i32,
        created: chrono::DateTime<chrono::Utc>,
        changed: chrono::DateTime<chrono::Utc>,
    ) -> PlaylistWithSongs {
        PlaylistWithSongs {
            id,
            name,
            comment: None,
            owner: None,
            public: None,
            song_count,
            duration,
            created,
            changed,
            cover_art: None,
            allowed_user: None,
            entry: None,
        }
    }
}

/// Converts the PlaylistWithSongs value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PlaylistWithSongs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            Some("name".to_string()),
            Some(self.name.to_string()),
            self.comment
                .as_ref()
                .map(|comment| ["comment".to_string(), comment.to_string()].join(",")),
            self.owner
                .as_ref()
                .map(|owner| ["owner".to_string(), owner.to_string()].join(",")),
            self.public
                .as_ref()
                .map(|public| ["public".to_string(), public.to_string()].join(",")),
            Some("songCount".to_string()),
            Some(self.song_count.to_string()),
            Some("duration".to_string()),
            Some(self.duration.to_string()),
            // Skipping created in query parameter serialization

            // Skipping changed in query parameter serialization
            self.cover_art
                .as_ref()
                .map(|cover_art| ["coverArt".to_string(), cover_art.to_string()].join(",")),
            self.allowed_user.as_ref().map(|allowed_user| {
                [
                    "allowedUser".to_string(),
                    allowed_user
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping entry in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PlaylistWithSongs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PlaylistWithSongs {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub comment: Vec<String>,
            pub owner: Vec<String>,
            pub public: Vec<bool>,
            pub song_count: Vec<i32>,
            pub duration: Vec<i32>,
            pub created: Vec<chrono::DateTime<chrono::Utc>>,
            pub changed: Vec<chrono::DateTime<chrono::Utc>>,
            pub cover_art: Vec<String>,
            pub allowed_user: Vec<Vec<String>>,
            pub entry: Vec<Vec<models::Child>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PlaylistWithSongs".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "comment" => intermediate_rep.comment.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "owner" => intermediate_rep.owner.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "public" => intermediate_rep.public.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "songCount" => intermediate_rep.song_count.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "duration" => intermediate_rep.duration.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "changed" => intermediate_rep.changed.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "coverArt" => intermediate_rep.cover_art.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "allowedUser" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in PlaylistWithSongs"
                            .to_string(),
                    ),
                    "entry" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in PlaylistWithSongs"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PlaylistWithSongs".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PlaylistWithSongs {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PlaylistWithSongs".to_string())?,
            name: intermediate_rep
                .name
                .into_iter()
                .next()
                .ok_or_else(|| "name missing in PlaylistWithSongs".to_string())?,
            comment: intermediate_rep.comment.into_iter().next(),
            owner: intermediate_rep.owner.into_iter().next(),
            public: intermediate_rep.public.into_iter().next(),
            song_count: intermediate_rep
                .song_count
                .into_iter()
                .next()
                .ok_or_else(|| "songCount missing in PlaylistWithSongs".to_string())?,
            duration: intermediate_rep
                .duration
                .into_iter()
                .next()
                .ok_or_else(|| "duration missing in PlaylistWithSongs".to_string())?,
            created: intermediate_rep
                .created
                .into_iter()
                .next()
                .ok_or_else(|| "created missing in PlaylistWithSongs".to_string())?,
            changed: intermediate_rep
                .changed
                .into_iter()
                .next()
                .ok_or_else(|| "changed missing in PlaylistWithSongs".to_string())?,
            cover_art: intermediate_rep.cover_art.into_iter().next(),
            allowed_user: intermediate_rep.allowed_user.into_iter().next(),
            entry: intermediate_rep.entry.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PlaylistWithSongs> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PlaylistWithSongs>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PlaylistWithSongs>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PlaylistWithSongs - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PlaylistWithSongs> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PlaylistWithSongs as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PlaylistWithSongs - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Playlists.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Playlists {
    /// The playlists
    #[serde(rename = "playlist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub playlist: Option<Vec<models::Playlist>>,
}

impl Playlists {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Playlists {
        Playlists { playlist: None }
    }
}

/// Converts the Playlists value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Playlists {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping playlist in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Playlists value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Playlists {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub playlist: Vec<Vec<models::Playlist>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Playlists".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "playlist" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Playlists"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Playlists".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Playlists {
            playlist: intermediate_rep.playlist.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Playlists> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Playlists>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Playlists>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Playlists - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Playlists> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Playlists as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Playlists - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A Podcast channel
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodcastChannel {
    /// The channel ID
    #[serde(rename = "id")]
    pub id: String,

    /// Podcast channel URL
    #[serde(rename = "url")]
    pub url: String,

    /// The channel title
    #[serde(rename = "title")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,

    /// The channel description
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// ID used for retrieving cover art
    #[serde(rename = "coverArt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cover_art: Option<String>,

    /// URL for original image of podcast channel
    #[serde(rename = "originalImageUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub original_image_url: Option<String>,

    #[serde(rename = "status")]
    pub status: models::PodcastStatus,

    /// An error message
    #[serde(rename = "errorMessage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_message: Option<String>,

    /// Podcast episodes with this channel
    #[serde(rename = "episode")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub episode: Option<Vec<models::PodcastEpisode>>,
}

impl PodcastChannel {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, url: String, status: models::PodcastStatus) -> PodcastChannel {
        PodcastChannel {
            id,
            url,
            title: None,
            description: None,
            cover_art: None,
            original_image_url: None,
            status,
            error_message: None,
            episode: None,
        }
    }
}

/// Converts the PodcastChannel value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PodcastChannel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            Some("url".to_string()),
            Some(self.url.to_string()),
            self.title
                .as_ref()
                .map(|title| ["title".to_string(), title.to_string()].join(",")),
            self.description
                .as_ref()
                .map(|description| ["description".to_string(), description.to_string()].join(",")),
            self.cover_art
                .as_ref()
                .map(|cover_art| ["coverArt".to_string(), cover_art.to_string()].join(",")),
            self.original_image_url.as_ref().map(|original_image_url| {
                [
                    "originalImageUrl".to_string(),
                    original_image_url.to_string(),
                ]
                .join(",")
            }),
            // Skipping status in query parameter serialization
            self.error_message.as_ref().map(|error_message| {
                ["errorMessage".to_string(), error_message.to_string()].join(",")
            }),
            // Skipping episode in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodcastChannel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodcastChannel {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub url: Vec<String>,
            pub title: Vec<String>,
            pub description: Vec<String>,
            pub cover_art: Vec<String>,
            pub original_image_url: Vec<String>,
            pub status: Vec<models::PodcastStatus>,
            pub error_message: Vec<String>,
            pub episode: Vec<Vec<models::PodcastEpisode>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PodcastChannel".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "coverArt" => intermediate_rep.cover_art.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "originalImageUrl" => intermediate_rep.original_image_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <models::PodcastStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "errorMessage" => intermediate_rep.error_message.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "episode" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PodcastChannel"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PodcastChannel".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodcastChannel {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PodcastChannel".to_string())?,
            url: intermediate_rep
                .url
                .into_iter()
                .next()
                .ok_or_else(|| "url missing in PodcastChannel".to_string())?,
            title: intermediate_rep.title.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            cover_art: intermediate_rep.cover_art.into_iter().next(),
            original_image_url: intermediate_rep.original_image_url.into_iter().next(),
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in PodcastChannel".to_string())?,
            error_message: intermediate_rep.error_message.into_iter().next(),
            episode: intermediate_rep.episode.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodcastChannel> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodcastChannel>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PodcastChannel>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PodcastChannel - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodcastChannel> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PodcastChannel as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PodcastChannel - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodcastEpisode {
    /// The id of the media.
    #[serde(rename = "id")]
    pub id: String,

    /// The id of the parent (folder/album)
    #[serde(rename = "parent")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent: Option<String>,

    /// The media is a directory
    #[serde(rename = "isDir")]
    pub is_dir: bool,

    /// The media name.
    #[serde(rename = "title")]
    pub title: String,

    /// The album name.
    #[serde(rename = "album")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album: Option<String>,

    /// The artist name.
    #[serde(rename = "artist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist: Option<String>,

    /// The track number.
    #[serde(rename = "track")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub track: Option<i32>,

    /// The media year.
    #[serde(rename = "year")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub year: Option<i32>,

    /// The media genre
    #[serde(rename = "genre")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub genre: Option<String>,

    /// The coverArt id.
    #[serde(rename = "coverArt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cover_art: Option<String>,

    /// A file size of the media.
    #[serde(rename = "size")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<i32>,

    /// The mimeType of the media.
    #[serde(rename = "contentType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content_type: Option<String>,

    /// The file suffix of the media.
    #[serde(rename = "suffix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suffix: Option<String>,

    /// The transcoded mediaType if transcoding should happen.
    #[serde(rename = "transcodedContentType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transcoded_content_type: Option<String>,

    /// The file suffix of the transcoded media.
    #[serde(rename = "transcodedSuffix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transcoded_suffix: Option<String>,

    /// The duration of the media in seconds.
    #[serde(rename = "duration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub duration: Option<i32>,

    /// The bitrate of the media.
    #[serde(rename = "bitRate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bit_rate: Option<i32>,

    /// The bit depth of the media.
    #[serde(rename = "bitDepth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bit_depth: Option<i32>,

    /// The sampling rate of the media.
    #[serde(rename = "samplingRate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sampling_rate: Option<i32>,

    /// The number of channels of the media.
    #[serde(rename = "channelCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel_count: Option<i32>,

    /// The full path of the media.
    #[serde(rename = "path")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,

    /// Media is a video
    #[serde(rename = "isVideo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_video: Option<bool>,

    /// The user rating of the media [1-5]
    #[serde(rename = "userRating")]
    #[validate(range(min = 1u8, max = 5u8))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_rating: Option<u8>,

    /// The average rating of the media [1.0-5.0]
    #[serde(rename = "averageRating")]
    #[validate(range(min = 0f64, max = 5f64))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub average_rating: Option<f64>,

    /// The play count.
    #[serde(rename = "playCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub play_count: Option<i32>,

    /// The disc number.
    #[serde(rename = "discNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disc_number: Option<i32>,

    /// Date the media was created. [ISO 8601]
    #[serde(rename = "created")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created: Option<chrono::DateTime<chrono::Utc>>,

    /// Date the media was starred. [ISO 8601]
    #[serde(rename = "starred")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub starred: Option<chrono::DateTime<chrono::Utc>>,

    /// The corresponding album id
    #[serde(rename = "albumId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album_id: Option<String>,

    /// The corresponding artist id
    #[serde(rename = "artistId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist_id: Option<String>,

    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub r#type: Option<models::GenericMediaType>,

    #[serde(rename = "mediaType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub media_type: Option<models::MediaType>,

    /// The bookmark position in seconds
    #[serde(rename = "bookmarkPosition")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bookmark_position: Option<i32>,

    /// The video original Width
    #[serde(rename = "originalWidth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub original_width: Option<i32>,

    /// The video original Height
    #[serde(rename = "originalHeight")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub original_height: Option<i32>,

    /// Date the album was last played. [ISO 8601]
    #[serde(rename = "played")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub played: Option<chrono::DateTime<chrono::Utc>>,

    /// The BPM of the song.
    #[serde(rename = "bpm")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bpm: Option<i32>,

    /// The comment tag of the song.
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,

    /// The song sort name.
    #[serde(rename = "sortName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sort_name: Option<String>,

    /// The track MusicBrainzID.
    #[serde(rename = "musicBrainzId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_brainz_id: Option<String>,

    /// The track ISRC(s).
    #[serde(rename = "isrc")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub isrc: Option<Vec<String>>,

    /// The list of all genres of the song.
    #[serde(rename = "genres")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub genres: Option<Vec<models::ItemGenre>>,

    /// The list of all song artists of the song. (Note: Only the required `ArtistID3` fields should be returned by default)
    #[serde(rename = "artists")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artists: Option<Vec<models::ArtistId3>>,

    /// The single value display artist.
    #[serde(rename = "displayArtist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display_artist: Option<String>,

    /// The list of all album artists of the song. (Note: Only the required `ArtistID3` fields should be returned by default)
    #[serde(rename = "albumArtists")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album_artists: Option<Vec<models::ArtistId3>>,

    /// The single value display album artist.
    #[serde(rename = "displayAlbumArtist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display_album_artist: Option<String>,

    /// The list of all contributor artists of the song.
    #[serde(rename = "contributors")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contributors: Option<Vec<models::Contributor>>,

    /// The single value display composer.
    #[serde(rename = "displayComposer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display_composer: Option<String>,

    /// The list of all moods of the song.
    #[serde(rename = "moods")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moods: Option<Vec<String>>,

    /// The replay gain data of the song.
    #[serde(rename = "replayGain")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replay_gain: Option<models::ReplayGain>,

    #[serde(rename = "explicitStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub explicit_status: Option<models::ExplicitStatus>,

    /// ID used for streaming podcast
    #[serde(rename = "streamId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_id: Option<String>,

    /// TID of the podcast channel
    #[serde(rename = "channelId")]
    pub channel_id: String,

    /// Episode description
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "status")]
    pub status: models::PodcastStatus,

    /// Date the episode was published [ISO 8601]
    #[serde(rename = "publishDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub publish_date: Option<chrono::DateTime<chrono::Utc>>,
}

impl PodcastEpisode {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        id: String,
        is_dir: bool,
        title: String,
        channel_id: String,
        status: models::PodcastStatus,
    ) -> PodcastEpisode {
        PodcastEpisode {
            id,
            parent: None,
            is_dir,
            title,
            album: None,
            artist: None,
            track: None,
            year: None,
            genre: None,
            cover_art: None,
            size: None,
            content_type: None,
            suffix: None,
            transcoded_content_type: None,
            transcoded_suffix: None,
            duration: None,
            bit_rate: None,
            bit_depth: None,
            sampling_rate: None,
            channel_count: None,
            path: None,
            is_video: None,
            user_rating: None,
            average_rating: None,
            play_count: None,
            disc_number: None,
            created: None,
            starred: None,
            album_id: None,
            artist_id: None,
            r#type: None,
            media_type: None,
            bookmark_position: None,
            original_width: None,
            original_height: None,
            played: None,
            bpm: None,
            comment: None,
            sort_name: None,
            music_brainz_id: None,
            isrc: None,
            genres: None,
            artists: None,
            display_artist: None,
            album_artists: None,
            display_album_artist: None,
            contributors: None,
            display_composer: None,
            moods: None,
            replay_gain: None,
            explicit_status: None,
            stream_id: None,
            channel_id,
            description: None,
            status,
            publish_date: None,
        }
    }
}

/// Converts the PodcastEpisode value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PodcastEpisode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            self.parent
                .as_ref()
                .map(|parent| ["parent".to_string(), parent.to_string()].join(",")),
            Some("isDir".to_string()),
            Some(self.is_dir.to_string()),
            Some("title".to_string()),
            Some(self.title.to_string()),
            self.album
                .as_ref()
                .map(|album| ["album".to_string(), album.to_string()].join(",")),
            self.artist
                .as_ref()
                .map(|artist| ["artist".to_string(), artist.to_string()].join(",")),
            self.track
                .as_ref()
                .map(|track| ["track".to_string(), track.to_string()].join(",")),
            self.year
                .as_ref()
                .map(|year| ["year".to_string(), year.to_string()].join(",")),
            self.genre
                .as_ref()
                .map(|genre| ["genre".to_string(), genre.to_string()].join(",")),
            self.cover_art
                .as_ref()
                .map(|cover_art| ["coverArt".to_string(), cover_art.to_string()].join(",")),
            self.size
                .as_ref()
                .map(|size| ["size".to_string(), size.to_string()].join(",")),
            self.content_type.as_ref().map(|content_type| {
                ["contentType".to_string(), content_type.to_string()].join(",")
            }),
            self.suffix
                .as_ref()
                .map(|suffix| ["suffix".to_string(), suffix.to_string()].join(",")),
            self.transcoded_content_type
                .as_ref()
                .map(|transcoded_content_type| {
                    [
                        "transcodedContentType".to_string(),
                        transcoded_content_type.to_string(),
                    ]
                    .join(",")
                }),
            self.transcoded_suffix.as_ref().map(|transcoded_suffix| {
                [
                    "transcodedSuffix".to_string(),
                    transcoded_suffix.to_string(),
                ]
                .join(",")
            }),
            self.duration
                .as_ref()
                .map(|duration| ["duration".to_string(), duration.to_string()].join(",")),
            self.bit_rate
                .as_ref()
                .map(|bit_rate| ["bitRate".to_string(), bit_rate.to_string()].join(",")),
            self.bit_depth
                .as_ref()
                .map(|bit_depth| ["bitDepth".to_string(), bit_depth.to_string()].join(",")),
            self.sampling_rate.as_ref().map(|sampling_rate| {
                ["samplingRate".to_string(), sampling_rate.to_string()].join(",")
            }),
            self.channel_count.as_ref().map(|channel_count| {
                ["channelCount".to_string(), channel_count.to_string()].join(",")
            }),
            self.path
                .as_ref()
                .map(|path| ["path".to_string(), path.to_string()].join(",")),
            self.is_video
                .as_ref()
                .map(|is_video| ["isVideo".to_string(), is_video.to_string()].join(",")),
            self.user_rating
                .as_ref()
                .map(|user_rating| ["userRating".to_string(), user_rating.to_string()].join(",")),
            self.average_rating.as_ref().map(|average_rating| {
                ["averageRating".to_string(), average_rating.to_string()].join(",")
            }),
            self.play_count
                .as_ref()
                .map(|play_count| ["playCount".to_string(), play_count.to_string()].join(",")),
            self.disc_number
                .as_ref()
                .map(|disc_number| ["discNumber".to_string(), disc_number.to_string()].join(",")),
            // Skipping created in query parameter serialization

            // Skipping starred in query parameter serialization
            self.album_id
                .as_ref()
                .map(|album_id| ["albumId".to_string(), album_id.to_string()].join(",")),
            self.artist_id
                .as_ref()
                .map(|artist_id| ["artistId".to_string(), artist_id.to_string()].join(",")),
            // Skipping type in query parameter serialization

            // Skipping mediaType in query parameter serialization
            self.bookmark_position.as_ref().map(|bookmark_position| {
                [
                    "bookmarkPosition".to_string(),
                    bookmark_position.to_string(),
                ]
                .join(",")
            }),
            self.original_width.as_ref().map(|original_width| {
                ["originalWidth".to_string(), original_width.to_string()].join(",")
            }),
            self.original_height.as_ref().map(|original_height| {
                ["originalHeight".to_string(), original_height.to_string()].join(",")
            }),
            // Skipping played in query parameter serialization
            self.bpm
                .as_ref()
                .map(|bpm| ["bpm".to_string(), bpm.to_string()].join(",")),
            self.comment
                .as_ref()
                .map(|comment| ["comment".to_string(), comment.to_string()].join(",")),
            self.sort_name
                .as_ref()
                .map(|sort_name| ["sortName".to_string(), sort_name.to_string()].join(",")),
            self.music_brainz_id.as_ref().map(|music_brainz_id| {
                ["musicBrainzId".to_string(), music_brainz_id.to_string()].join(",")
            }),
            self.isrc.as_ref().map(|isrc| {
                [
                    "isrc".to_string(),
                    isrc.iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping genres in query parameter serialization

            // Skipping artists in query parameter serialization
            self.display_artist.as_ref().map(|display_artist| {
                ["displayArtist".to_string(), display_artist.to_string()].join(",")
            }),
            // Skipping albumArtists in query parameter serialization
            self.display_album_artist
                .as_ref()
                .map(|display_album_artist| {
                    [
                        "displayAlbumArtist".to_string(),
                        display_album_artist.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping contributors in query parameter serialization
            self.display_composer.as_ref().map(|display_composer| {
                ["displayComposer".to_string(), display_composer.to_string()].join(",")
            }),
            self.moods.as_ref().map(|moods| {
                [
                    "moods".to_string(),
                    moods
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping replayGain in query parameter serialization

            // Skipping explicitStatus in query parameter serialization
            self.stream_id
                .as_ref()
                .map(|stream_id| ["streamId".to_string(), stream_id.to_string()].join(",")),
            Some("channelId".to_string()),
            Some(self.channel_id.to_string()),
            self.description
                .as_ref()
                .map(|description| ["description".to_string(), description.to_string()].join(",")),
            // Skipping status in query parameter serialization

            // Skipping publishDate in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodcastEpisode value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodcastEpisode {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub parent: Vec<String>,
            pub is_dir: Vec<bool>,
            pub title: Vec<String>,
            pub album: Vec<String>,
            pub artist: Vec<String>,
            pub track: Vec<i32>,
            pub year: Vec<i32>,
            pub genre: Vec<String>,
            pub cover_art: Vec<String>,
            pub size: Vec<i32>,
            pub content_type: Vec<String>,
            pub suffix: Vec<String>,
            pub transcoded_content_type: Vec<String>,
            pub transcoded_suffix: Vec<String>,
            pub duration: Vec<i32>,
            pub bit_rate: Vec<i32>,
            pub bit_depth: Vec<i32>,
            pub sampling_rate: Vec<i32>,
            pub channel_count: Vec<i32>,
            pub path: Vec<String>,
            pub is_video: Vec<bool>,
            pub user_rating: Vec<u8>,
            pub average_rating: Vec<f64>,
            pub play_count: Vec<i32>,
            pub disc_number: Vec<i32>,
            pub created: Vec<chrono::DateTime<chrono::Utc>>,
            pub starred: Vec<chrono::DateTime<chrono::Utc>>,
            pub album_id: Vec<String>,
            pub artist_id: Vec<String>,
            pub r#type: Vec<models::GenericMediaType>,
            pub media_type: Vec<models::MediaType>,
            pub bookmark_position: Vec<i32>,
            pub original_width: Vec<i32>,
            pub original_height: Vec<i32>,
            pub played: Vec<chrono::DateTime<chrono::Utc>>,
            pub bpm: Vec<i32>,
            pub comment: Vec<String>,
            pub sort_name: Vec<String>,
            pub music_brainz_id: Vec<String>,
            pub isrc: Vec<Vec<String>>,
            pub genres: Vec<Vec<models::ItemGenre>>,
            pub artists: Vec<Vec<models::ArtistId3>>,
            pub display_artist: Vec<String>,
            pub album_artists: Vec<Vec<models::ArtistId3>>,
            pub display_album_artist: Vec<String>,
            pub contributors: Vec<Vec<models::Contributor>>,
            pub display_composer: Vec<String>,
            pub moods: Vec<Vec<String>>,
            pub replay_gain: Vec<models::ReplayGain>,
            pub explicit_status: Vec<models::ExplicitStatus>,
            pub stream_id: Vec<String>,
            pub channel_id: Vec<String>,
            pub description: Vec<String>,
            pub status: Vec<models::PodcastStatus>,
            pub publish_date: Vec<chrono::DateTime<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PodcastEpisode".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "parent" => intermediate_rep.parent.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "isDir" => intermediate_rep.is_dir.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "album" => intermediate_rep.album.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artist" => intermediate_rep.artist.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "track" => intermediate_rep.track.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "year" => intermediate_rep.year.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "genre" => intermediate_rep.genre.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "coverArt" => intermediate_rep.cover_art.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "size" => intermediate_rep.size.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "contentType" => intermediate_rep.content_type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "suffix" => intermediate_rep.suffix.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "transcodedContentType" => intermediate_rep.transcoded_content_type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "transcodedSuffix" => intermediate_rep.transcoded_suffix.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "duration" => intermediate_rep.duration.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "bitRate" => intermediate_rep.bit_rate.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "bitDepth" => intermediate_rep.bit_depth.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "samplingRate" => intermediate_rep.sampling_rate.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "channelCount" => intermediate_rep.channel_count.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "isVideo" => intermediate_rep.is_video.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "userRating" => intermediate_rep
                        .user_rating
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "averageRating" => intermediate_rep.average_rating.push(
                        <f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "playCount" => intermediate_rep.play_count.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "discNumber" => intermediate_rep.disc_number.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "starred" => intermediate_rep.starred.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "albumId" => intermediate_rep.album_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artistId" => intermediate_rep.artist_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <models::GenericMediaType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "mediaType" => intermediate_rep.media_type.push(
                        <models::MediaType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "bookmarkPosition" => intermediate_rep.bookmark_position.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "originalWidth" => intermediate_rep.original_width.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "originalHeight" => intermediate_rep.original_height.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "played" => intermediate_rep.played.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "bpm" => intermediate_rep.bpm.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "comment" => intermediate_rep.comment.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sortName" => intermediate_rep.sort_name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "musicBrainzId" => intermediate_rep.music_brainz_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "isrc" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PodcastEpisode"
                                .to_string(),
                        )
                    }
                    "genres" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PodcastEpisode"
                                .to_string(),
                        )
                    }
                    "artists" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PodcastEpisode"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "displayArtist" => intermediate_rep.display_artist.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "albumArtists" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PodcastEpisode"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "displayAlbumArtist" => intermediate_rep.display_album_artist.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "contributors" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PodcastEpisode"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "displayComposer" => intermediate_rep.display_composer.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "moods" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PodcastEpisode"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "replayGain" => intermediate_rep.replay_gain.push(
                        <models::ReplayGain as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "explicitStatus" => intermediate_rep.explicit_status.push(
                        <models::ExplicitStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "streamId" => intermediate_rep.stream_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "channelId" => intermediate_rep.channel_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <models::PodcastStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "publishDate" => intermediate_rep.publish_date.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PodcastEpisode".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodcastEpisode {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PodcastEpisode".to_string())?,
            parent: intermediate_rep.parent.into_iter().next(),
            is_dir: intermediate_rep
                .is_dir
                .into_iter()
                .next()
                .ok_or_else(|| "isDir missing in PodcastEpisode".to_string())?,
            title: intermediate_rep
                .title
                .into_iter()
                .next()
                .ok_or_else(|| "title missing in PodcastEpisode".to_string())?,
            album: intermediate_rep.album.into_iter().next(),
            artist: intermediate_rep.artist.into_iter().next(),
            track: intermediate_rep.track.into_iter().next(),
            year: intermediate_rep.year.into_iter().next(),
            genre: intermediate_rep.genre.into_iter().next(),
            cover_art: intermediate_rep.cover_art.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
            content_type: intermediate_rep.content_type.into_iter().next(),
            suffix: intermediate_rep.suffix.into_iter().next(),
            transcoded_content_type: intermediate_rep.transcoded_content_type.into_iter().next(),
            transcoded_suffix: intermediate_rep.transcoded_suffix.into_iter().next(),
            duration: intermediate_rep.duration.into_iter().next(),
            bit_rate: intermediate_rep.bit_rate.into_iter().next(),
            bit_depth: intermediate_rep.bit_depth.into_iter().next(),
            sampling_rate: intermediate_rep.sampling_rate.into_iter().next(),
            channel_count: intermediate_rep.channel_count.into_iter().next(),
            path: intermediate_rep.path.into_iter().next(),
            is_video: intermediate_rep.is_video.into_iter().next(),
            user_rating: intermediate_rep.user_rating.into_iter().next(),
            average_rating: intermediate_rep.average_rating.into_iter().next(),
            play_count: intermediate_rep.play_count.into_iter().next(),
            disc_number: intermediate_rep.disc_number.into_iter().next(),
            created: intermediate_rep.created.into_iter().next(),
            starred: intermediate_rep.starred.into_iter().next(),
            album_id: intermediate_rep.album_id.into_iter().next(),
            artist_id: intermediate_rep.artist_id.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            media_type: intermediate_rep.media_type.into_iter().next(),
            bookmark_position: intermediate_rep.bookmark_position.into_iter().next(),
            original_width: intermediate_rep.original_width.into_iter().next(),
            original_height: intermediate_rep.original_height.into_iter().next(),
            played: intermediate_rep.played.into_iter().next(),
            bpm: intermediate_rep.bpm.into_iter().next(),
            comment: intermediate_rep.comment.into_iter().next(),
            sort_name: intermediate_rep.sort_name.into_iter().next(),
            music_brainz_id: intermediate_rep.music_brainz_id.into_iter().next(),
            isrc: intermediate_rep.isrc.into_iter().next(),
            genres: intermediate_rep.genres.into_iter().next(),
            artists: intermediate_rep.artists.into_iter().next(),
            display_artist: intermediate_rep.display_artist.into_iter().next(),
            album_artists: intermediate_rep.album_artists.into_iter().next(),
            display_album_artist: intermediate_rep.display_album_artist.into_iter().next(),
            contributors: intermediate_rep.contributors.into_iter().next(),
            display_composer: intermediate_rep.display_composer.into_iter().next(),
            moods: intermediate_rep.moods.into_iter().next(),
            replay_gain: intermediate_rep.replay_gain.into_iter().next(),
            explicit_status: intermediate_rep.explicit_status.into_iter().next(),
            stream_id: intermediate_rep.stream_id.into_iter().next(),
            channel_id: intermediate_rep
                .channel_id
                .into_iter()
                .next()
                .ok_or_else(|| "channelId missing in PodcastEpisode".to_string())?,
            description: intermediate_rep.description.into_iter().next(),
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in PodcastEpisode".to_string())?,
            publish_date: intermediate_rep.publish_date.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodcastEpisode> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodcastEpisode>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PodcastEpisode>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PodcastEpisode - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodcastEpisode> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PodcastEpisode as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PodcastEpisode - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// An enumeration of possible podcast statuses
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PodcastStatus {
    #[serde(rename = "new")]
    New,
    #[serde(rename = "downloading")]
    Downloading,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "error")]
    Error,
    #[serde(rename = "deleted")]
    Deleted,
    #[serde(rename = "skipped")]
    Skipped,
}

impl std::fmt::Display for PodcastStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PodcastStatus::New => write!(f, "new"),
            PodcastStatus::Downloading => write!(f, "downloading"),
            PodcastStatus::Completed => write!(f, "completed"),
            PodcastStatus::Error => write!(f, "error"),
            PodcastStatus::Deleted => write!(f, "deleted"),
            PodcastStatus::Skipped => write!(f, "skipped"),
        }
    }
}

impl std::str::FromStr for PodcastStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "new" => std::result::Result::Ok(PodcastStatus::New),
            "downloading" => std::result::Result::Ok(PodcastStatus::Downloading),
            "completed" => std::result::Result::Ok(PodcastStatus::Completed),
            "error" => std::result::Result::Ok(PodcastStatus::Error),
            "deleted" => std::result::Result::Ok(PodcastStatus::Deleted),
            "skipped" => std::result::Result::Ok(PodcastStatus::Skipped),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Podcasts.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Podcasts {
    /// Podcast channel(s)
    #[serde(rename = "channel")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel: Option<Vec<models::PodcastChannel>>,
}

impl Podcasts {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Podcasts {
        Podcasts { channel: None }
    }
}

/// Converts the Podcasts value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Podcasts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping channel in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Podcasts value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Podcasts {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub channel: Vec<Vec<models::PodcastChannel>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Podcasts".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "channel" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Podcasts"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Podcasts".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Podcasts {
            channel: intermediate_rep.channel.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Podcasts> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Podcasts>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Podcasts>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Podcasts - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Podcasts> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Podcasts as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Podcasts - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostAddChatMessageRequest {
    /// The chat message.
    #[serde(rename = "message")]
    pub message: String,
}

impl PostAddChatMessageRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(message: String) -> PostAddChatMessageRequest {
        PostAddChatMessageRequest { message }
    }
}

/// Converts the PostAddChatMessageRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostAddChatMessageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> =
            vec![Some("message".to_string()), Some(self.message.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostAddChatMessageRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostAddChatMessageRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostAddChatMessageRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostAddChatMessageRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostAddChatMessageRequest {
            message: intermediate_rep
                .message
                .into_iter()
                .next()
                .ok_or_else(|| "message missing in PostAddChatMessageRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostAddChatMessageRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostAddChatMessageRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostAddChatMessageRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostAddChatMessageRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostAddChatMessageRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostAddChatMessageRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostAddChatMessageRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostChangePasswordRequest {
    /// The name of the user which should change its password.
    #[serde(rename = "username")]
    pub username: String,

    /// The new password of the new user, either in clear text of hex-encoded (see above).
    #[serde(rename = "password")]
    pub password: String,
}

impl PostChangePasswordRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(username: String, password: String) -> PostChangePasswordRequest {
        PostChangePasswordRequest { username, password }
    }
}

/// Converts the PostChangePasswordRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostChangePasswordRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("username".to_string()),
            Some(self.username.to_string()),
            Some("password".to_string()),
            Some(self.password.to_string()),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostChangePasswordRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostChangePasswordRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub username: Vec<String>,
            pub password: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostChangePasswordRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "password" => intermediate_rep.password.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostChangePasswordRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostChangePasswordRequest {
            username: intermediate_rep
                .username
                .into_iter()
                .next()
                .ok_or_else(|| "username missing in PostChangePasswordRequest".to_string())?,
            password: intermediate_rep
                .password
                .into_iter()
                .next()
                .ok_or_else(|| "password missing in PostChangePasswordRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostChangePasswordRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostChangePasswordRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostChangePasswordRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostChangePasswordRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostChangePasswordRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostChangePasswordRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostChangePasswordRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostCreateBookmarkRequest {
    /// ID of the media file to bookmark. If a bookmark already exists for this file it will be overwritten.
    #[serde(rename = "id")]
    pub id: String,

    /// The position (in milliseconds) within the media file.
    #[serde(rename = "position")]
    pub position: i32,

    /// A user-defined comment.
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
}

impl PostCreateBookmarkRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, position: i32) -> PostCreateBookmarkRequest {
        PostCreateBookmarkRequest {
            id,
            position,
            comment: None,
        }
    }
}

/// Converts the PostCreateBookmarkRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostCreateBookmarkRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            Some("position".to_string()),
            Some(self.position.to_string()),
            self.comment
                .as_ref()
                .map(|comment| ["comment".to_string(), comment.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostCreateBookmarkRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostCreateBookmarkRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub position: Vec<i32>,
            pub comment: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostCreateBookmarkRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "position" => intermediate_rep.position.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "comment" => intermediate_rep.comment.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostCreateBookmarkRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostCreateBookmarkRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostCreateBookmarkRequest".to_string())?,
            position: intermediate_rep
                .position
                .into_iter()
                .next()
                .ok_or_else(|| "position missing in PostCreateBookmarkRequest".to_string())?,
            comment: intermediate_rep.comment.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostCreateBookmarkRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostCreateBookmarkRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostCreateBookmarkRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostCreateBookmarkRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostCreateBookmarkRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostCreateBookmarkRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostCreateBookmarkRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostCreateInternetRadioStationRequest {
    /// The stream URL for the station.
    #[serde(rename = "streamUrl")]
    pub stream_url: String,

    /// The station name.
    #[serde(rename = "name")]
    pub name: String,

    /// The home page URL for the station.
    #[serde(rename = "homepageUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub homepage_url: Option<String>,
}

impl PostCreateInternetRadioStationRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(stream_url: String, name: String) -> PostCreateInternetRadioStationRequest {
        PostCreateInternetRadioStationRequest {
            stream_url,
            name,
            homepage_url: None,
        }
    }
}

/// Converts the PostCreateInternetRadioStationRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostCreateInternetRadioStationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("streamUrl".to_string()),
            Some(self.stream_url.to_string()),
            Some("name".to_string()),
            Some(self.name.to_string()),
            self.homepage_url.as_ref().map(|homepage_url| {
                ["homepageUrl".to_string(), homepage_url.to_string()].join(",")
            }),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostCreateInternetRadioStationRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostCreateInternetRadioStationRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub stream_url: Vec<String>,
            pub name: Vec<String>,
            pub homepage_url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostCreateInternetRadioStationRequest"
                            .to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "streamUrl" => intermediate_rep.stream_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "homepageUrl" => intermediate_rep.homepage_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostCreateInternetRadioStationRequest"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostCreateInternetRadioStationRequest {
            stream_url: intermediate_rep
                .stream_url
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "streamUrl missing in PostCreateInternetRadioStationRequest".to_string()
                })?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| {
                "name missing in PostCreateInternetRadioStationRequest".to_string()
            })?,
            homepage_url: intermediate_rep.homepage_url.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostCreateInternetRadioStationRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostCreateInternetRadioStationRequest>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostCreateInternetRadioStationRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PostCreateInternetRadioStationRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<PostCreateInternetRadioStationRequest>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PostCreateInternetRadioStationRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PostCreateInternetRadioStationRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostCreatePlaylistRequest {
    /// The playlist ID. Required if updating an existing playlist.
    #[serde(rename = "playlistId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub playlist_id: Option<String>,

    /// The human-readable name of the playlist. Required if creating a new playlist.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// ID of a song in the playlist. Use one `songId` parameter for each song in the playlist.
    #[serde(rename = "songId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub song_id: Option<Vec<String>>,
}

impl PostCreatePlaylistRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PostCreatePlaylistRequest {
        PostCreatePlaylistRequest {
            playlist_id: None,
            name: None,
            song_id: None,
        }
    }
}

/// Converts the PostCreatePlaylistRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostCreatePlaylistRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            self.playlist_id
                .as_ref()
                .map(|playlist_id| ["playlistId".to_string(), playlist_id.to_string()].join(",")),
            self.name
                .as_ref()
                .map(|name| ["name".to_string(), name.to_string()].join(",")),
            self.song_id.as_ref().map(|song_id| {
                [
                    "songId".to_string(),
                    song_id
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostCreatePlaylistRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostCreatePlaylistRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub playlist_id: Vec<String>,
            pub name: Vec<String>,
            pub song_id: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostCreatePlaylistRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "playlistId" => intermediate_rep.playlist_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "songId" => return std::result::Result::Err("Parsing a container in this style is not supported in PostCreatePlaylistRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PostCreatePlaylistRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostCreatePlaylistRequest {
            playlist_id: intermediate_rep.playlist_id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            song_id: intermediate_rep.song_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostCreatePlaylistRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostCreatePlaylistRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostCreatePlaylistRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostCreatePlaylistRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostCreatePlaylistRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostCreatePlaylistRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostCreatePlaylistRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostCreatePodcastChannelRequest {
    /// The URL of the Podcast to add.
    #[serde(rename = "url")]
    pub url: String,
}

impl PostCreatePodcastChannelRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(url: String) -> PostCreatePodcastChannelRequest {
        PostCreatePodcastChannelRequest { url }
    }
}

/// Converts the PostCreatePodcastChannelRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostCreatePodcastChannelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![Some("url".to_string()), Some(self.url.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostCreatePodcastChannelRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostCreatePodcastChannelRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostCreatePodcastChannelRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostCreatePodcastChannelRequest"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostCreatePodcastChannelRequest {
            url: intermediate_rep
                .url
                .into_iter()
                .next()
                .ok_or_else(|| "url missing in PostCreatePodcastChannelRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostCreatePodcastChannelRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostCreatePodcastChannelRequest>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostCreatePodcastChannelRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PostCreatePodcastChannelRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<PostCreatePodcastChannelRequest>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PostCreatePodcastChannelRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PostCreatePodcastChannelRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostCreateShareRequest {
    /// ID of a song, album or video to share. Use one id parameter for each entry to share.
    #[serde(rename = "id")]
    pub id: Vec<String>,

    /// A user-defined description that will be displayed to people visiting the shared media.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// The time at which the share expires. Given as milliseconds since 1970.
    #[serde(rename = "expires")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires: Option<i32>,
}

impl PostCreateShareRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: Vec<String>) -> PostCreateShareRequest {
        PostCreateShareRequest {
            id,
            description: None,
            expires: None,
        }
    }
}

/// Converts the PostCreateShareRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostCreateShareRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(
                self.id
                    .iter()
                    .map(|x| x.to_string())
                    .collect::<Vec<_>>()
                    .join(","),
            ),
            self.description
                .as_ref()
                .map(|description| ["description".to_string(), description.to_string()].join(",")),
            self.expires
                .as_ref()
                .map(|expires| ["expires".to_string(), expires.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostCreateShareRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostCreateShareRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<Vec<String>>,
            pub description: Vec<String>,
            pub expires: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostCreateShareRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "id" => return std::result::Result::Err("Parsing a container in this style is not supported in PostCreateShareRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expires" => intermediate_rep.expires.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PostCreateShareRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostCreateShareRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostCreateShareRequest".to_string())?,
            description: intermediate_rep.description.into_iter().next(),
            expires: intermediate_rep.expires.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostCreateShareRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostCreateShareRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostCreateShareRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostCreateShareRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostCreateShareRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostCreateShareRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostCreateShareRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostCreateUserRequest {
    /// The name of the new user.
    #[serde(rename = "username")]
    pub username: String,

    /// The password of the new user, either in clear text or hex-encoded.
    #[serde(rename = "password")]
    pub password: String,

    /// The email address of the new user.
    #[serde(rename = "email")]
    pub email: String,

    /// Whether the user is authenticated in LDAP.
    #[serde(rename = "ldapAuthenticated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ldap_authenticated: Option<bool>,

    /// Whether the user is administrator.
    #[serde(rename = "adminRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub admin_role: Option<bool>,

    /// Whether the user is allowed to change personal settings and password.
    #[serde(rename = "settingsRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub settings_role: Option<bool>,

    /// Whether the user is allowed to play files.
    #[serde(rename = "streamRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_role: Option<bool>,

    /// Whether the user is allowed to play files in jukebox mode.
    #[serde(rename = "jukeboxRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub jukebox_role: Option<bool>,

    /// Whether the user is allowed to download files.
    #[serde(rename = "downloadRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub download_role: Option<bool>,

    /// Whether the user is allowed to upload files.
    #[serde(rename = "uploadRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub upload_role: Option<bool>,

    /// Whether the user is allowed to create and delete playlists. Since 1.8.0, changing this role has no effect.
    #[serde(rename = "playlistRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub playlist_role: Option<bool>,

    /// Whether the user is allowed to change cover art and tags.
    #[serde(rename = "coverArtRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cover_art_role: Option<bool>,

    /// Whether the user is allowed to create and edit comments and ratings.
    #[serde(rename = "commentRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment_role: Option<bool>,

    /// Whether the user is allowed to administrate Podcasts.
    #[serde(rename = "podcastRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub podcast_role: Option<bool>,

    /// (Since 1.8.0) Whether the user is allowed to share files with anyone.
    #[serde(rename = "shareRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub share_role: Option<bool>,

    /// (Since 1.15.0) Whether the user is allowed to start video conversions.
    #[serde(rename = "videoConversionRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub video_conversion_role: Option<bool>,

    /// (Since 1.12.0) IDs of the music folders the user is allowed access to. Include the parameter once for each folder. Default all folders.
    #[serde(rename = "musicFolderId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_folder_id: Option<Vec<String>>,
}

impl PostCreateUserRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(username: String, password: String, email: String) -> PostCreateUserRequest {
        PostCreateUserRequest {
            username,
            password,
            email,
            ldap_authenticated: Some(false),
            admin_role: Some(false),
            settings_role: Some(true),
            stream_role: Some(true),
            jukebox_role: Some(false),
            download_role: Some(false),
            upload_role: Some(false),
            playlist_role: Some(false),
            cover_art_role: Some(false),
            comment_role: Some(false),
            podcast_role: Some(false),
            share_role: Some(false),
            video_conversion_role: Some(false),
            music_folder_id: None,
        }
    }
}

/// Converts the PostCreateUserRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostCreateUserRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("username".to_string()),
            Some(self.username.to_string()),
            Some("password".to_string()),
            Some(self.password.to_string()),
            Some("email".to_string()),
            Some(self.email.to_string()),
            self.ldap_authenticated.as_ref().map(|ldap_authenticated| {
                [
                    "ldapAuthenticated".to_string(),
                    ldap_authenticated.to_string(),
                ]
                .join(",")
            }),
            self.admin_role
                .as_ref()
                .map(|admin_role| ["adminRole".to_string(), admin_role.to_string()].join(",")),
            self.settings_role.as_ref().map(|settings_role| {
                ["settingsRole".to_string(), settings_role.to_string()].join(",")
            }),
            self.stream_role
                .as_ref()
                .map(|stream_role| ["streamRole".to_string(), stream_role.to_string()].join(",")),
            self.jukebox_role.as_ref().map(|jukebox_role| {
                ["jukeboxRole".to_string(), jukebox_role.to_string()].join(",")
            }),
            self.download_role.as_ref().map(|download_role| {
                ["downloadRole".to_string(), download_role.to_string()].join(",")
            }),
            self.upload_role
                .as_ref()
                .map(|upload_role| ["uploadRole".to_string(), upload_role.to_string()].join(",")),
            self.playlist_role.as_ref().map(|playlist_role| {
                ["playlistRole".to_string(), playlist_role.to_string()].join(",")
            }),
            self.cover_art_role.as_ref().map(|cover_art_role| {
                ["coverArtRole".to_string(), cover_art_role.to_string()].join(",")
            }),
            self.comment_role.as_ref().map(|comment_role| {
                ["commentRole".to_string(), comment_role.to_string()].join(",")
            }),
            self.podcast_role.as_ref().map(|podcast_role| {
                ["podcastRole".to_string(), podcast_role.to_string()].join(",")
            }),
            self.share_role
                .as_ref()
                .map(|share_role| ["shareRole".to_string(), share_role.to_string()].join(",")),
            self.video_conversion_role
                .as_ref()
                .map(|video_conversion_role| {
                    [
                        "videoConversionRole".to_string(),
                        video_conversion_role.to_string(),
                    ]
                    .join(",")
                }),
            self.music_folder_id.as_ref().map(|music_folder_id| {
                [
                    "musicFolderId".to_string(),
                    music_folder_id
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostCreateUserRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostCreateUserRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub username: Vec<String>,
            pub password: Vec<String>,
            pub email: Vec<String>,
            pub ldap_authenticated: Vec<bool>,
            pub admin_role: Vec<bool>,
            pub settings_role: Vec<bool>,
            pub stream_role: Vec<bool>,
            pub jukebox_role: Vec<bool>,
            pub download_role: Vec<bool>,
            pub upload_role: Vec<bool>,
            pub playlist_role: Vec<bool>,
            pub cover_art_role: Vec<bool>,
            pub comment_role: Vec<bool>,
            pub podcast_role: Vec<bool>,
            pub share_role: Vec<bool>,
            pub video_conversion_role: Vec<bool>,
            pub music_folder_id: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostCreateUserRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "password" => intermediate_rep.password.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "email" => intermediate_rep.email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ldapAuthenticated" => intermediate_rep.ldap_authenticated.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "adminRole" => intermediate_rep.admin_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "settingsRole" => intermediate_rep.settings_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "streamRole" => intermediate_rep.stream_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "jukeboxRole" => intermediate_rep.jukebox_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "downloadRole" => intermediate_rep.download_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "uploadRole" => intermediate_rep.upload_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "playlistRole" => intermediate_rep.playlist_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "coverArtRole" => intermediate_rep.cover_art_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "commentRole" => intermediate_rep.comment_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "podcastRole" => intermediate_rep.podcast_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shareRole" => intermediate_rep.share_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "videoConversionRole" => intermediate_rep.video_conversion_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "musicFolderId" => return std::result::Result::Err("Parsing a container in this style is not supported in PostCreateUserRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PostCreateUserRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostCreateUserRequest {
            username: intermediate_rep
                .username
                .into_iter()
                .next()
                .ok_or_else(|| "username missing in PostCreateUserRequest".to_string())?,
            password: intermediate_rep
                .password
                .into_iter()
                .next()
                .ok_or_else(|| "password missing in PostCreateUserRequest".to_string())?,
            email: intermediate_rep
                .email
                .into_iter()
                .next()
                .ok_or_else(|| "email missing in PostCreateUserRequest".to_string())?,
            ldap_authenticated: intermediate_rep.ldap_authenticated.into_iter().next(),
            admin_role: intermediate_rep.admin_role.into_iter().next(),
            settings_role: intermediate_rep.settings_role.into_iter().next(),
            stream_role: intermediate_rep.stream_role.into_iter().next(),
            jukebox_role: intermediate_rep.jukebox_role.into_iter().next(),
            download_role: intermediate_rep.download_role.into_iter().next(),
            upload_role: intermediate_rep.upload_role.into_iter().next(),
            playlist_role: intermediate_rep.playlist_role.into_iter().next(),
            cover_art_role: intermediate_rep.cover_art_role.into_iter().next(),
            comment_role: intermediate_rep.comment_role.into_iter().next(),
            podcast_role: intermediate_rep.podcast_role.into_iter().next(),
            share_role: intermediate_rep.share_role.into_iter().next(),
            video_conversion_role: intermediate_rep.video_conversion_role.into_iter().next(),
            music_folder_id: intermediate_rep.music_folder_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostCreateUserRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostCreateUserRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostCreateUserRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostCreateUserRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostCreateUserRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostCreateUserRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostCreateUserRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostDeleteBookmarkRequest {
    /// ID of the media file for which to delete the bookmark. Other users’ bookmarks are not affected.
    #[serde(rename = "id")]
    pub id: String,
}

impl PostDeleteBookmarkRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostDeleteBookmarkRequest {
        PostDeleteBookmarkRequest { id }
    }
}

/// Converts the PostDeleteBookmarkRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostDeleteBookmarkRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![Some("id".to_string()), Some(self.id.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostDeleteBookmarkRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostDeleteBookmarkRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostDeleteBookmarkRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostDeleteBookmarkRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostDeleteBookmarkRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostDeleteBookmarkRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostDeleteBookmarkRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostDeleteBookmarkRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostDeleteBookmarkRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostDeleteBookmarkRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostDeleteBookmarkRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostDeleteBookmarkRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostDeleteBookmarkRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostDeleteInternetRadioStationRequest {
    /// The ID for the station.
    #[serde(rename = "id")]
    pub id: String,
}

impl PostDeleteInternetRadioStationRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostDeleteInternetRadioStationRequest {
        PostDeleteInternetRadioStationRequest { id }
    }
}

/// Converts the PostDeleteInternetRadioStationRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostDeleteInternetRadioStationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![Some("id".to_string()), Some(self.id.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostDeleteInternetRadioStationRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostDeleteInternetRadioStationRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostDeleteInternetRadioStationRequest"
                            .to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostDeleteInternetRadioStationRequest"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostDeleteInternetRadioStationRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostDeleteInternetRadioStationRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostDeleteInternetRadioStationRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostDeleteInternetRadioStationRequest>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostDeleteInternetRadioStationRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PostDeleteInternetRadioStationRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<PostDeleteInternetRadioStationRequest>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PostDeleteInternetRadioStationRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PostDeleteInternetRadioStationRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostDeletePlaylistRequest {
    /// ID of the playlist to delete, as obtained by `getPlaylists`.
    #[serde(rename = "id")]
    pub id: String,
}

impl PostDeletePlaylistRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostDeletePlaylistRequest {
        PostDeletePlaylistRequest { id }
    }
}

/// Converts the PostDeletePlaylistRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostDeletePlaylistRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![Some("id".to_string()), Some(self.id.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostDeletePlaylistRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostDeletePlaylistRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostDeletePlaylistRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostDeletePlaylistRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostDeletePlaylistRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostDeletePlaylistRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostDeletePlaylistRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostDeletePlaylistRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostDeletePlaylistRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostDeletePlaylistRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostDeletePlaylistRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostDeletePlaylistRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostDeletePlaylistRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostDeletePodcastChannelRequest {
    /// The ID of the Podcast channel to delete.
    #[serde(rename = "id")]
    pub id: String,
}

impl PostDeletePodcastChannelRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostDeletePodcastChannelRequest {
        PostDeletePodcastChannelRequest { id }
    }
}

/// Converts the PostDeletePodcastChannelRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostDeletePodcastChannelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![Some("id".to_string()), Some(self.id.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostDeletePodcastChannelRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostDeletePodcastChannelRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostDeletePodcastChannelRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostDeletePodcastChannelRequest"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostDeletePodcastChannelRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostDeletePodcastChannelRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostDeletePodcastChannelRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostDeletePodcastChannelRequest>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostDeletePodcastChannelRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PostDeletePodcastChannelRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<PostDeletePodcastChannelRequest>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PostDeletePodcastChannelRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PostDeletePodcastChannelRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostDeletePodcastEpisodeRequest {
    /// The ID of the Podcast episode to delete.
    #[serde(rename = "id")]
    pub id: String,
}

impl PostDeletePodcastEpisodeRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostDeletePodcastEpisodeRequest {
        PostDeletePodcastEpisodeRequest { id }
    }
}

/// Converts the PostDeletePodcastEpisodeRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostDeletePodcastEpisodeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![Some("id".to_string()), Some(self.id.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostDeletePodcastEpisodeRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostDeletePodcastEpisodeRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostDeletePodcastEpisodeRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostDeletePodcastEpisodeRequest"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostDeletePodcastEpisodeRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostDeletePodcastEpisodeRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostDeletePodcastEpisodeRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostDeletePodcastEpisodeRequest>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostDeletePodcastEpisodeRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PostDeletePodcastEpisodeRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<PostDeletePodcastEpisodeRequest>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PostDeletePodcastEpisodeRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PostDeletePodcastEpisodeRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostDeleteShareRequest {
    /// ID of the share to delete.
    #[serde(rename = "id")]
    pub id: String,
}

impl PostDeleteShareRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostDeleteShareRequest {
        PostDeleteShareRequest { id }
    }
}

/// Converts the PostDeleteShareRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostDeleteShareRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![Some("id".to_string()), Some(self.id.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostDeleteShareRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostDeleteShareRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostDeleteShareRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostDeleteShareRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostDeleteShareRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostDeleteShareRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostDeleteShareRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostDeleteShareRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostDeleteShareRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostDeleteShareRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostDeleteShareRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostDeleteShareRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostDeleteShareRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostDeleteUserRequest {
    /// The name of the user to delete.
    #[serde(rename = "username")]
    pub username: String,
}

impl PostDeleteUserRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(username: String) -> PostDeleteUserRequest {
        PostDeleteUserRequest { username }
    }
}

/// Converts the PostDeleteUserRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostDeleteUserRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("username".to_string()),
            Some(self.username.to_string()),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostDeleteUserRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostDeleteUserRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostDeleteUserRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostDeleteUserRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostDeleteUserRequest {
            username: intermediate_rep
                .username
                .into_iter()
                .next()
                .ok_or_else(|| "username missing in PostDeleteUserRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostDeleteUserRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostDeleteUserRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostDeleteUserRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostDeleteUserRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostDeleteUserRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostDeleteUserRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostDeleteUserRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostDownloadPodcastEpisodeRequest {
    /// The ID of the Podcast episode to download.
    #[serde(rename = "id")]
    pub id: String,
}

impl PostDownloadPodcastEpisodeRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostDownloadPodcastEpisodeRequest {
        PostDownloadPodcastEpisodeRequest { id }
    }
}

/// Converts the PostDownloadPodcastEpisodeRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostDownloadPodcastEpisodeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![Some("id".to_string()), Some(self.id.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostDownloadPodcastEpisodeRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostDownloadPodcastEpisodeRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostDownloadPodcastEpisodeRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostDownloadPodcastEpisodeRequest"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostDownloadPodcastEpisodeRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostDownloadPodcastEpisodeRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostDownloadPodcastEpisodeRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostDownloadPodcastEpisodeRequest>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostDownloadPodcastEpisodeRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PostDownloadPodcastEpisodeRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<PostDownloadPodcastEpisodeRequest>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PostDownloadPodcastEpisodeRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PostDownloadPodcastEpisodeRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostDownloadRequest {
    /// A string which uniquely identifies the file to download. Obtained by calls to getMusicDirectory.
    #[serde(rename = "id")]
    pub id: String,
}

impl PostDownloadRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostDownloadRequest {
        PostDownloadRequest { id }
    }
}

/// Converts the PostDownloadRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostDownloadRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![Some("id".to_string()), Some(self.id.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostDownloadRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostDownloadRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostDownloadRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostDownloadRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostDownloadRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostDownloadRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostDownloadRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostDownloadRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostDownloadRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostDownloadRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostDownloadRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostDownloadRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostDownloadRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetAlbumInfoRequest {
    /// The album ID or song ID.
    #[serde(rename = "id")]
    pub id: String,
}

impl PostGetAlbumInfoRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostGetAlbumInfoRequest {
        PostGetAlbumInfoRequest { id }
    }
}

/// Converts the PostGetAlbumInfoRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetAlbumInfoRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![Some("id".to_string()), Some(self.id.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetAlbumInfoRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetAlbumInfoRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetAlbumInfoRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetAlbumInfoRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetAlbumInfoRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostGetAlbumInfoRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetAlbumInfoRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetAlbumInfoRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetAlbumInfoRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetAlbumInfoRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetAlbumInfoRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostGetAlbumInfoRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostGetAlbumInfoRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetAlbumListRequest {
    #[serde(rename = "type")]
    pub r#type: models::AlbumListType,

    /// The number of albums to return. Max 500.
    #[serde(rename = "size")]
    #[validate(range(min = 1u16, max = 500u16))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<u16>,

    /// The list offset. Useful if you for example want to page through the list of newest albums.
    #[serde(rename = "offset")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub offset: Option<u32>,

    /// Required if `type=='byYear'`. The first year in the range. If `fromYear` > `toYear` a reverse chronological list is returned.
    #[serde(rename = "fromYear")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub from_year: Option<i32>,

    /// Required if `type=='byYear'`. The last year in the range.
    #[serde(rename = "toYear")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub to_year: Option<i32>,

    /// Required if `type=='byGenre'`. The name of the genre, e.g., “Rock”.
    #[serde(rename = "genre")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub genre: Option<String>,

    /// (Since 1.11.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
    #[serde(rename = "musicFolderId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_folder_id: Option<String>,
}

impl PostGetAlbumListRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: models::AlbumListType) -> PostGetAlbumListRequest {
        PostGetAlbumListRequest {
            r#type,
            size: Some(10),
            offset: Some(0),
            from_year: None,
            to_year: None,
            genre: None,
            music_folder_id: None,
        }
    }
}

/// Converts the PostGetAlbumListRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetAlbumListRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping type in query parameter serialization
            self.size
                .as_ref()
                .map(|size| ["size".to_string(), size.to_string()].join(",")),
            self.offset
                .as_ref()
                .map(|offset| ["offset".to_string(), offset.to_string()].join(",")),
            self.from_year
                .as_ref()
                .map(|from_year| ["fromYear".to_string(), from_year.to_string()].join(",")),
            self.to_year
                .as_ref()
                .map(|to_year| ["toYear".to_string(), to_year.to_string()].join(",")),
            self.genre
                .as_ref()
                .map(|genre| ["genre".to_string(), genre.to_string()].join(",")),
            self.music_folder_id.as_ref().map(|music_folder_id| {
                ["musicFolderId".to_string(), music_folder_id.to_string()].join(",")
            }),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetAlbumListRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetAlbumListRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<models::AlbumListType>,
            pub size: Vec<u16>,
            pub offset: Vec<u32>,
            pub from_year: Vec<i32>,
            pub to_year: Vec<i32>,
            pub genre: Vec<String>,
            pub music_folder_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetAlbumListRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <models::AlbumListType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "size" => intermediate_rep.size.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "offset" => intermediate_rep.offset.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "fromYear" => intermediate_rep.from_year.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "toYear" => intermediate_rep.to_year.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "genre" => intermediate_rep.genre.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "musicFolderId" => intermediate_rep.music_folder_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetAlbumListRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetAlbumListRequest {
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in PostGetAlbumListRequest".to_string())?,
            size: intermediate_rep.size.into_iter().next(),
            offset: intermediate_rep.offset.into_iter().next(),
            from_year: intermediate_rep.from_year.into_iter().next(),
            to_year: intermediate_rep.to_year.into_iter().next(),
            genre: intermediate_rep.genre.into_iter().next(),
            music_folder_id: intermediate_rep.music_folder_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetAlbumListRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetAlbumListRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetAlbumListRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetAlbumListRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetAlbumListRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostGetAlbumListRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostGetAlbumListRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetAlbumRequest {
    /// The album ID.
    #[serde(rename = "id")]
    pub id: String,
}

impl PostGetAlbumRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostGetAlbumRequest {
        PostGetAlbumRequest { id }
    }
}

/// Converts the PostGetAlbumRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetAlbumRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![Some("id".to_string()), Some(self.id.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetAlbumRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetAlbumRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetAlbumRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetAlbumRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetAlbumRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostGetAlbumRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetAlbumRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetAlbumRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetAlbumRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetAlbumRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetAlbumRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostGetAlbumRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostGetAlbumRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetArtistInfoRequest {
    /// The artist, album or song ID.
    #[serde(rename = "id")]
    pub id: String,

    /// Max number of similar artists to return.
    #[serde(rename = "count")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<u32>,

    /// Whether to return artists that are not present in the media library.
    #[serde(rename = "includeNotPresent")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub include_not_present: Option<bool>,
}

impl PostGetArtistInfoRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostGetArtistInfoRequest {
        PostGetArtistInfoRequest {
            id,
            count: Some(20),
            include_not_present: Some(false),
        }
    }
}

/// Converts the PostGetArtistInfoRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetArtistInfoRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            self.count
                .as_ref()
                .map(|count| ["count".to_string(), count.to_string()].join(",")),
            self.include_not_present
                .as_ref()
                .map(|include_not_present| {
                    [
                        "includeNotPresent".to_string(),
                        include_not_present.to_string(),
                    ]
                    .join(",")
                }),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetArtistInfoRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetArtistInfoRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub count: Vec<u32>,
            pub include_not_present: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetArtistInfoRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "includeNotPresent" => intermediate_rep.include_not_present.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetArtistInfoRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetArtistInfoRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostGetArtistInfoRequest".to_string())?,
            count: intermediate_rep.count.into_iter().next(),
            include_not_present: intermediate_rep.include_not_present.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetArtistInfoRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetArtistInfoRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetArtistInfoRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetArtistInfoRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetArtistInfoRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostGetArtistInfoRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostGetArtistInfoRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetArtistRequest {
    /// The artist ID.
    #[serde(rename = "id")]
    pub id: String,
}

impl PostGetArtistRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostGetArtistRequest {
        PostGetArtistRequest { id }
    }
}

/// Converts the PostGetArtistRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetArtistRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![Some("id".to_string()), Some(self.id.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetArtistRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetArtistRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetArtistRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetArtistRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetArtistRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostGetArtistRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetArtistRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetArtistRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetArtistRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetArtistRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetArtistRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostGetArtistRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostGetArtistRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetArtistsRequest {
    /// If specified, only return artists in the music folder with the given ID. See `getMusicFolders`.
    #[serde(rename = "musicFolderId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_folder_id: Option<String>,
}

impl PostGetArtistsRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PostGetArtistsRequest {
        PostGetArtistsRequest {
            music_folder_id: None,
        }
    }
}

/// Converts the PostGetArtistsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetArtistsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> =
            vec![self.music_folder_id.as_ref().map(|music_folder_id| {
                ["musicFolderId".to_string(), music_folder_id.to_string()].join(",")
            })];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetArtistsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetArtistsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub music_folder_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetArtistsRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "musicFolderId" => intermediate_rep.music_folder_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetArtistsRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetArtistsRequest {
            music_folder_id: intermediate_rep.music_folder_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetArtistsRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetArtistsRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetArtistsRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetArtistsRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetArtistsRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostGetArtistsRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostGetArtistsRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetAvatarRequest {
    /// The username for which to retrieve the avatar.
    #[serde(rename = "username")]
    pub username: String,
}

impl PostGetAvatarRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(username: String) -> PostGetAvatarRequest {
        PostGetAvatarRequest { username }
    }
}

/// Converts the PostGetAvatarRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetAvatarRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("username".to_string()),
            Some(self.username.to_string()),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetAvatarRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetAvatarRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetAvatarRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetAvatarRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetAvatarRequest {
            username: intermediate_rep
                .username
                .into_iter()
                .next()
                .ok_or_else(|| "username missing in PostGetAvatarRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetAvatarRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetAvatarRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetAvatarRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetAvatarRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetAvatarRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostGetAvatarRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostGetAvatarRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetCaptionsRequest {
    /// The ID of the video.
    #[serde(rename = "id")]
    pub id: String,

    /// Preferred captions format (“srt” or “vtt”).
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub format: Option<String>,
}

impl PostGetCaptionsRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostGetCaptionsRequest {
        PostGetCaptionsRequest { id, format: None }
    }
}

/// Converts the PostGetCaptionsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetCaptionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            self.format
                .as_ref()
                .map(|format| ["format".to_string(), format.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetCaptionsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetCaptionsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub format: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetCaptionsRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "format" => intermediate_rep.format.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetCaptionsRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetCaptionsRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostGetCaptionsRequest".to_string())?,
            format: intermediate_rep.format.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetCaptionsRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetCaptionsRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetCaptionsRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetCaptionsRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetCaptionsRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostGetCaptionsRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostGetCaptionsRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetCoverArtRequest {
    /// The coverArt ID. Returned by most entities likes `Child` or `AlbumID3`
    #[serde(rename = "id")]
    pub id: String,

    /// If specified, scale image to this size.
    #[serde(rename = "size")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<i32>,
}

impl PostGetCoverArtRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostGetCoverArtRequest {
        PostGetCoverArtRequest { id, size: None }
    }
}

/// Converts the PostGetCoverArtRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetCoverArtRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            self.size
                .as_ref()
                .map(|size| ["size".to_string(), size.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetCoverArtRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetCoverArtRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub size: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetCoverArtRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "size" => intermediate_rep.size.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetCoverArtRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetCoverArtRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostGetCoverArtRequest".to_string())?,
            size: intermediate_rep.size.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetCoverArtRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetCoverArtRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetCoverArtRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetCoverArtRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetCoverArtRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostGetCoverArtRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostGetCoverArtRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetIndexesRequest {
    /// If specified, only return artists in the music folder with the given ID. See `getMusicFolders`.
    #[serde(rename = "musicFolderId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_folder_id: Option<String>,

    /// If specified, only return a result if the artist collection has changed since the given time (in milliseconds since 1 Jan 1970).
    #[serde(rename = "ifModifiedSince")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub if_modified_since: Option<i32>,
}

impl PostGetIndexesRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PostGetIndexesRequest {
        PostGetIndexesRequest {
            music_folder_id: None,
            if_modified_since: None,
        }
    }
}

/// Converts the PostGetIndexesRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetIndexesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            self.music_folder_id.as_ref().map(|music_folder_id| {
                ["musicFolderId".to_string(), music_folder_id.to_string()].join(",")
            }),
            self.if_modified_since.as_ref().map(|if_modified_since| {
                ["ifModifiedSince".to_string(), if_modified_since.to_string()].join(",")
            }),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetIndexesRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetIndexesRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub music_folder_id: Vec<String>,
            pub if_modified_since: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetIndexesRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "musicFolderId" => intermediate_rep.music_folder_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ifModifiedSince" => intermediate_rep.if_modified_since.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetIndexesRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetIndexesRequest {
            music_folder_id: intermediate_rep.music_folder_id.into_iter().next(),
            if_modified_since: intermediate_rep.if_modified_since.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetIndexesRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetIndexesRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetIndexesRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetIndexesRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetIndexesRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostGetIndexesRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostGetIndexesRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetLyricsBySongIdRequest {
    /// The track ID.
    #[serde(rename = "id")]
    pub id: String,
}

impl PostGetLyricsBySongIdRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostGetLyricsBySongIdRequest {
        PostGetLyricsBySongIdRequest { id }
    }
}

/// Converts the PostGetLyricsBySongIdRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetLyricsBySongIdRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![Some("id".to_string()), Some(self.id.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetLyricsBySongIdRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetLyricsBySongIdRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetLyricsBySongIdRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetLyricsBySongIdRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetLyricsBySongIdRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostGetLyricsBySongIdRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetLyricsBySongIdRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetLyricsBySongIdRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetLyricsBySongIdRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetLyricsBySongIdRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetLyricsBySongIdRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PostGetLyricsBySongIdRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PostGetLyricsBySongIdRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetLyricsRequest {
    /// The artist name.
    #[serde(rename = "artist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist: Option<String>,

    /// The song title.
    #[serde(rename = "title")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
}

impl PostGetLyricsRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PostGetLyricsRequest {
        PostGetLyricsRequest {
            artist: None,
            title: None,
        }
    }
}

/// Converts the PostGetLyricsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetLyricsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            self.artist
                .as_ref()
                .map(|artist| ["artist".to_string(), artist.to_string()].join(",")),
            self.title
                .as_ref()
                .map(|title| ["title".to_string(), title.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetLyricsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetLyricsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub artist: Vec<String>,
            pub title: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetLyricsRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "artist" => intermediate_rep.artist.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetLyricsRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetLyricsRequest {
            artist: intermediate_rep.artist.into_iter().next(),
            title: intermediate_rep.title.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetLyricsRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetLyricsRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetLyricsRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetLyricsRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetLyricsRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostGetLyricsRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostGetLyricsRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetMusicDirectoryRequest {
    /// A string which uniquely identifies the music folder. Obtained by calls to `getIndexes` or `getMusicDirectory`.
    #[serde(rename = "id")]
    pub id: String,
}

impl PostGetMusicDirectoryRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostGetMusicDirectoryRequest {
        PostGetMusicDirectoryRequest { id }
    }
}

/// Converts the PostGetMusicDirectoryRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetMusicDirectoryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![Some("id".to_string()), Some(self.id.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetMusicDirectoryRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetMusicDirectoryRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetMusicDirectoryRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetMusicDirectoryRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetMusicDirectoryRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostGetMusicDirectoryRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetMusicDirectoryRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetMusicDirectoryRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetMusicDirectoryRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetMusicDirectoryRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetMusicDirectoryRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PostGetMusicDirectoryRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PostGetMusicDirectoryRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetNewestPodcastsRequest {
    /// The maximum number of episodes to return.
    #[serde(rename = "count")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<i32>,
}

impl PostGetNewestPodcastsRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PostGetNewestPodcastsRequest {
        PostGetNewestPodcastsRequest { count: Some(20) }
    }
}

/// Converts the PostGetNewestPodcastsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetNewestPodcastsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![self
            .count
            .as_ref()
            .map(|count| ["count".to_string(), count.to_string()].join(","))];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetNewestPodcastsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetNewestPodcastsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetNewestPodcastsRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetNewestPodcastsRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetNewestPodcastsRequest {
            count: intermediate_rep.count.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetNewestPodcastsRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetNewestPodcastsRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetNewestPodcastsRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetNewestPodcastsRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetNewestPodcastsRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PostGetNewestPodcastsRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PostGetNewestPodcastsRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetPlaylistRequest {
    /// ID of the playlist to return, as obtained by `getPlaylists`.
    #[serde(rename = "id")]
    pub id: String,
}

impl PostGetPlaylistRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostGetPlaylistRequest {
        PostGetPlaylistRequest { id }
    }
}

/// Converts the PostGetPlaylistRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetPlaylistRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![Some("id".to_string()), Some(self.id.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetPlaylistRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetPlaylistRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetPlaylistRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetPlaylistRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetPlaylistRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostGetPlaylistRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetPlaylistRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetPlaylistRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetPlaylistRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetPlaylistRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetPlaylistRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostGetPlaylistRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostGetPlaylistRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetPlaylistsRequest {
    /// (Since 1.8.0) If specified, return playlists for this user rather than for the authenticated user. The authenticated user must have admin role if this parameter is used.
    #[serde(rename = "username")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

impl PostGetPlaylistsRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PostGetPlaylistsRequest {
        PostGetPlaylistsRequest { username: None }
    }
}

/// Converts the PostGetPlaylistsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetPlaylistsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![self
            .username
            .as_ref()
            .map(|username| ["username".to_string(), username.to_string()].join(","))];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetPlaylistsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetPlaylistsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetPlaylistsRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetPlaylistsRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetPlaylistsRequest {
            username: intermediate_rep.username.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetPlaylistsRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetPlaylistsRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetPlaylistsRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetPlaylistsRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetPlaylistsRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostGetPlaylistsRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostGetPlaylistsRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetPodcastEpisodeRequest {
    /// The podcast episode ID.
    #[serde(rename = "id")]
    pub id: String,
}

impl PostGetPodcastEpisodeRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostGetPodcastEpisodeRequest {
        PostGetPodcastEpisodeRequest { id }
    }
}

/// Converts the PostGetPodcastEpisodeRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetPodcastEpisodeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![Some("id".to_string()), Some(self.id.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetPodcastEpisodeRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetPodcastEpisodeRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetPodcastEpisodeRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetPodcastEpisodeRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetPodcastEpisodeRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostGetPodcastEpisodeRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetPodcastEpisodeRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetPodcastEpisodeRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetPodcastEpisodeRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetPodcastEpisodeRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetPodcastEpisodeRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PostGetPodcastEpisodeRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PostGetPodcastEpisodeRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetPodcastsRequest {
    /// (Since 1.9.0) If specified, only return the Podcast channel with this ID.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// (Since 1.9.0) Whether to include Podcast episodes in the returned result.
    #[serde(rename = "includeEpisodes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub include_episodes: Option<bool>,
}

impl PostGetPodcastsRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PostGetPodcastsRequest {
        PostGetPodcastsRequest {
            id: None,
            include_episodes: Some(true),
        }
    }
}

/// Converts the PostGetPodcastsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetPodcastsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            self.id
                .as_ref()
                .map(|id| ["id".to_string(), id.to_string()].join(",")),
            self.include_episodes.as_ref().map(|include_episodes| {
                ["includeEpisodes".to_string(), include_episodes.to_string()].join(",")
            }),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetPodcastsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetPodcastsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub include_episodes: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetPodcastsRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "includeEpisodes" => intermediate_rep.include_episodes.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetPodcastsRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetPodcastsRequest {
            id: intermediate_rep.id.into_iter().next(),
            include_episodes: intermediate_rep.include_episodes.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetPodcastsRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetPodcastsRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetPodcastsRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetPodcastsRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetPodcastsRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostGetPodcastsRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostGetPodcastsRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetRandomSongsRequest {
    /// The maximum number of songs to return. Max 500.
    #[serde(rename = "size")]
    #[validate(range(min = 0u16, max = 500u16))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<u16>,

    /// Only returns songs belonging to this genre.
    #[serde(rename = "genre")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub genre: Option<String>,

    /// (Since 1.9.0) Only return songs from this year or later.
    #[serde(rename = "fromYear")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub from_year: Option<i32>,

    /// Only return songs published before or in this year.
    #[serde(rename = "toYear")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub to_year: Option<i32>,

    /// Only return songs in the music folder with the given ID. See `getMusicFolders`.
    #[serde(rename = "musicFolderId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_folder_id: Option<String>,
}

impl PostGetRandomSongsRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PostGetRandomSongsRequest {
        PostGetRandomSongsRequest {
            size: Some(10),
            genre: None,
            from_year: None,
            to_year: None,
            music_folder_id: None,
        }
    }
}

/// Converts the PostGetRandomSongsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetRandomSongsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            self.size
                .as_ref()
                .map(|size| ["size".to_string(), size.to_string()].join(",")),
            self.genre
                .as_ref()
                .map(|genre| ["genre".to_string(), genre.to_string()].join(",")),
            self.from_year
                .as_ref()
                .map(|from_year| ["fromYear".to_string(), from_year.to_string()].join(",")),
            self.to_year
                .as_ref()
                .map(|to_year| ["toYear".to_string(), to_year.to_string()].join(",")),
            self.music_folder_id.as_ref().map(|music_folder_id| {
                ["musicFolderId".to_string(), music_folder_id.to_string()].join(",")
            }),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetRandomSongsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetRandomSongsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub size: Vec<u16>,
            pub genre: Vec<String>,
            pub from_year: Vec<i32>,
            pub to_year: Vec<i32>,
            pub music_folder_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetRandomSongsRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "size" => intermediate_rep.size.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "genre" => intermediate_rep.genre.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "fromYear" => intermediate_rep.from_year.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "toYear" => intermediate_rep.to_year.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "musicFolderId" => intermediate_rep.music_folder_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetRandomSongsRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetRandomSongsRequest {
            size: intermediate_rep.size.into_iter().next(),
            genre: intermediate_rep.genre.into_iter().next(),
            from_year: intermediate_rep.from_year.into_iter().next(),
            to_year: intermediate_rep.to_year.into_iter().next(),
            music_folder_id: intermediate_rep.music_folder_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetRandomSongsRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetRandomSongsRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetRandomSongsRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetRandomSongsRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetRandomSongsRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostGetRandomSongsRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostGetRandomSongsRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetSimilarSongsRequest {
    /// The artist, album or song ID.
    #[serde(rename = "id")]
    pub id: String,

    /// Max number of songs to return.
    #[serde(rename = "count")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<u32>,
}

impl PostGetSimilarSongsRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostGetSimilarSongsRequest {
        PostGetSimilarSongsRequest {
            id,
            count: Some(50),
        }
    }
}

/// Converts the PostGetSimilarSongsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetSimilarSongsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            self.count
                .as_ref()
                .map(|count| ["count".to_string(), count.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetSimilarSongsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetSimilarSongsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub count: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetSimilarSongsRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetSimilarSongsRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetSimilarSongsRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostGetSimilarSongsRequest".to_string())?,
            count: intermediate_rep.count.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetSimilarSongsRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetSimilarSongsRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetSimilarSongsRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetSimilarSongsRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetSimilarSongsRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostGetSimilarSongsRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostGetSimilarSongsRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetSongRequest {
    /// The song ID.
    #[serde(rename = "id")]
    pub id: String,
}

impl PostGetSongRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostGetSongRequest {
        PostGetSongRequest { id }
    }
}

/// Converts the PostGetSongRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetSongRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![Some("id".to_string()), Some(self.id.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetSongRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetSongRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetSongRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetSongRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetSongRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostGetSongRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetSongRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetSongRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetSongRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetSongRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetSongRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostGetSongRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostGetSongRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetSongsByGenreRequest {
    /// The genre, as returned by `getGenres`.
    #[serde(rename = "genre")]
    pub genre: String,

    /// The maximum number of songs to return. Max 500.
    #[serde(rename = "count")]
    #[validate(range(min = 0u16, max = 500u16))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<u16>,

    /// The offset. Useful if you want to page through the songs in a genre.
    #[serde(rename = "offset")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub offset: Option<u32>,

    /// (Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
    #[serde(rename = "musicFolderId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_folder_id: Option<String>,
}

impl PostGetSongsByGenreRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(genre: String) -> PostGetSongsByGenreRequest {
        PostGetSongsByGenreRequest {
            genre,
            count: Some(10),
            offset: Some(0),
            music_folder_id: None,
        }
    }
}

/// Converts the PostGetSongsByGenreRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetSongsByGenreRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("genre".to_string()),
            Some(self.genre.to_string()),
            self.count
                .as_ref()
                .map(|count| ["count".to_string(), count.to_string()].join(",")),
            self.offset
                .as_ref()
                .map(|offset| ["offset".to_string(), offset.to_string()].join(",")),
            self.music_folder_id.as_ref().map(|music_folder_id| {
                ["musicFolderId".to_string(), music_folder_id.to_string()].join(",")
            }),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetSongsByGenreRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetSongsByGenreRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub genre: Vec<String>,
            pub count: Vec<u16>,
            pub offset: Vec<u32>,
            pub music_folder_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetSongsByGenreRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "genre" => intermediate_rep.genre.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "offset" => intermediate_rep.offset.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "musicFolderId" => intermediate_rep.music_folder_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetSongsByGenreRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetSongsByGenreRequest {
            genre: intermediate_rep
                .genre
                .into_iter()
                .next()
                .ok_or_else(|| "genre missing in PostGetSongsByGenreRequest".to_string())?,
            count: intermediate_rep.count.into_iter().next(),
            offset: intermediate_rep.offset.into_iter().next(),
            music_folder_id: intermediate_rep.music_folder_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetSongsByGenreRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetSongsByGenreRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetSongsByGenreRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetSongsByGenreRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetSongsByGenreRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostGetSongsByGenreRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostGetSongsByGenreRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetTopSongsRequest {
    /// The artist name.
    #[serde(rename = "id")]
    pub id: String,

    /// The maximum number of songs to return.
    #[serde(rename = "count")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<u32>,
}

impl PostGetTopSongsRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostGetTopSongsRequest {
        PostGetTopSongsRequest {
            id,
            count: Some(50),
        }
    }
}

/// Converts the PostGetTopSongsRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetTopSongsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            self.count
                .as_ref()
                .map(|count| ["count".to_string(), count.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetTopSongsRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetTopSongsRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub count: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetTopSongsRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetTopSongsRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetTopSongsRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostGetTopSongsRequest".to_string())?,
            count: intermediate_rep.count.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetTopSongsRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetTopSongsRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetTopSongsRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetTopSongsRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetTopSongsRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostGetTopSongsRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostGetTopSongsRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetUserRequest {
    /// The name of the user to retrieve. You can only retrieve your own user unless you have admin privileges.
    #[serde(rename = "username")]
    pub username: String,
}

impl PostGetUserRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(username: String) -> PostGetUserRequest {
        PostGetUserRequest { username }
    }
}

/// Converts the PostGetUserRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetUserRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("username".to_string()),
            Some(self.username.to_string()),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetUserRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetUserRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetUserRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetUserRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetUserRequest {
            username: intermediate_rep
                .username
                .into_iter()
                .next()
                .ok_or_else(|| "username missing in PostGetUserRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetUserRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetUserRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetUserRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetUserRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetUserRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostGetUserRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostGetUserRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostGetVideoInfoRequest {
    /// The video ID.
    #[serde(rename = "id")]
    pub id: String,
}

impl PostGetVideoInfoRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostGetVideoInfoRequest {
        PostGetVideoInfoRequest { id }
    }
}

/// Converts the PostGetVideoInfoRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostGetVideoInfoRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![Some("id".to_string()), Some(self.id.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostGetVideoInfoRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostGetVideoInfoRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostGetVideoInfoRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostGetVideoInfoRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostGetVideoInfoRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostGetVideoInfoRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostGetVideoInfoRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostGetVideoInfoRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostGetVideoInfoRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostGetVideoInfoRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostGetVideoInfoRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostGetVideoInfoRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostGetVideoInfoRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostHlsM3u8Request {
    /// A string which uniquely identifies the media file to stream.
    #[serde(rename = "id")]
    pub id: String,

    /// If specified, the server will attempt to limit the bitrate to this value, in kilobits per second. If set to zero, no limit is imposed.
    #[serde(rename = "bitRate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bit_rate: Option<i32>,

    /// The ID of the audio track to use. See `getVideoInfo` for how to get the list of available audio tracks for a video.
    #[serde(rename = "audioTrack")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audio_track: Option<String>,
}

impl PostHlsM3u8Request {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostHlsM3u8Request {
        PostHlsM3u8Request {
            id,
            bit_rate: None,
            audio_track: None,
        }
    }
}

/// Converts the PostHlsM3u8Request value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostHlsM3u8Request {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            self.bit_rate
                .as_ref()
                .map(|bit_rate| ["bitRate".to_string(), bit_rate.to_string()].join(",")),
            self.audio_track
                .as_ref()
                .map(|audio_track| ["audioTrack".to_string(), audio_track.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostHlsM3u8Request value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostHlsM3u8Request {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub bit_rate: Vec<i32>,
            pub audio_track: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostHlsM3u8Request".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "bitRate" => intermediate_rep.bit_rate.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "audioTrack" => intermediate_rep.audio_track.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostHlsM3u8Request".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostHlsM3u8Request {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostHlsM3u8Request".to_string())?,
            bit_rate: intermediate_rep.bit_rate.into_iter().next(),
            audio_track: intermediate_rep.audio_track.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostHlsM3u8Request> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostHlsM3u8Request>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostHlsM3u8Request>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostHlsM3u8Request - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostHlsM3u8Request> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostHlsM3u8Request as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostHlsM3u8Request - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum PostJukeboxControlRequest {
    PostJukeboxControlRequestOneOf(Box<models::PostJukeboxControlRequestOneOf>),
    PostJukeboxControlRequestOneOf1(Box<models::PostJukeboxControlRequestOneOf1>),
    PostJukeboxControlRequestOneOf2(Box<models::PostJukeboxControlRequestOneOf2>),
    PostJukeboxControlRequestOneOf3(Box<models::PostJukeboxControlRequestOneOf3>),
    PostJukeboxControlRequestOneOf4(Box<models::PostJukeboxControlRequestOneOf4>),
    PostJukeboxControlRequestOneOf5(Box<models::PostJukeboxControlRequestOneOf5>),
}

impl validator::Validate for PostJukeboxControlRequest {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::PostJukeboxControlRequestOneOf(x) => x.validate(),
            Self::PostJukeboxControlRequestOneOf1(x) => x.validate(),
            Self::PostJukeboxControlRequestOneOf2(x) => x.validate(),
            Self::PostJukeboxControlRequestOneOf3(x) => x.validate(),
            Self::PostJukeboxControlRequestOneOf4(x) => x.validate(),
            Self::PostJukeboxControlRequestOneOf5(x) => x.validate(),
        }
    }
}

impl From<models::PostJukeboxControlRequestOneOf> for PostJukeboxControlRequest {
    fn from(value: models::PostJukeboxControlRequestOneOf) -> Self {
        Self::PostJukeboxControlRequestOneOf(Box::new(value))
    }
}
impl From<models::PostJukeboxControlRequestOneOf1> for PostJukeboxControlRequest {
    fn from(value: models::PostJukeboxControlRequestOneOf1) -> Self {
        Self::PostJukeboxControlRequestOneOf1(Box::new(value))
    }
}
impl From<models::PostJukeboxControlRequestOneOf2> for PostJukeboxControlRequest {
    fn from(value: models::PostJukeboxControlRequestOneOf2) -> Self {
        Self::PostJukeboxControlRequestOneOf2(Box::new(value))
    }
}
impl From<models::PostJukeboxControlRequestOneOf3> for PostJukeboxControlRequest {
    fn from(value: models::PostJukeboxControlRequestOneOf3) -> Self {
        Self::PostJukeboxControlRequestOneOf3(Box::new(value))
    }
}
impl From<models::PostJukeboxControlRequestOneOf4> for PostJukeboxControlRequest {
    fn from(value: models::PostJukeboxControlRequestOneOf4) -> Self {
        Self::PostJukeboxControlRequestOneOf4(Box::new(value))
    }
}
impl From<models::PostJukeboxControlRequestOneOf5> for PostJukeboxControlRequest {
    fn from(value: models::PostJukeboxControlRequestOneOf5) -> Self {
        Self::PostJukeboxControlRequestOneOf5(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostJukeboxControlRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostJukeboxControlRequest {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostJukeboxControlRequestOneOf {
    /// The operation to perform. Must be one of: get, status (since 1.7.0), set (since 1.7.0), start, stop, skip, add, clear, remove, shuffle, setGain
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "action")]
    pub action: String,
}

impl PostJukeboxControlRequestOneOf {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(action: String) -> PostJukeboxControlRequestOneOf {
        PostJukeboxControlRequestOneOf { action }
    }
}

/// Converts the PostJukeboxControlRequestOneOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostJukeboxControlRequestOneOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> =
            vec![Some("action".to_string()), Some(self.action.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostJukeboxControlRequestOneOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostJukeboxControlRequestOneOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub action: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostJukeboxControlRequestOneOf".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "action" => intermediate_rep.action.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostJukeboxControlRequestOneOf"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostJukeboxControlRequestOneOf {
            action: intermediate_rep
                .action
                .into_iter()
                .next()
                .ok_or_else(|| "action missing in PostJukeboxControlRequestOneOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostJukeboxControlRequestOneOf> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostJukeboxControlRequestOneOf>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostJukeboxControlRequestOneOf>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostJukeboxControlRequestOneOf - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<PostJukeboxControlRequestOneOf>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PostJukeboxControlRequestOneOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PostJukeboxControlRequestOneOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostJukeboxControlRequestOneOf1 {
    /// 'remove' action.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "action")]
    pub action: String,

    /// Zero-based index of the song to remove.
    #[serde(rename = "index")]
    #[validate(range(min = 0u32))]
    pub index: u32,
}

impl PostJukeboxControlRequestOneOf1 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(action: String, index: u32) -> PostJukeboxControlRequestOneOf1 {
        PostJukeboxControlRequestOneOf1 { action, index }
    }
}

/// Converts the PostJukeboxControlRequestOneOf1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostJukeboxControlRequestOneOf1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("action".to_string()),
            Some(self.action.to_string()),
            Some("index".to_string()),
            Some(self.index.to_string()),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostJukeboxControlRequestOneOf1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostJukeboxControlRequestOneOf1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub action: Vec<String>,
            pub index: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostJukeboxControlRequestOneOf1".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "action" => intermediate_rep.action.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostJukeboxControlRequestOneOf1"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostJukeboxControlRequestOneOf1 {
            action: intermediate_rep
                .action
                .into_iter()
                .next()
                .ok_or_else(|| "action missing in PostJukeboxControlRequestOneOf1".to_string())?,
            index: intermediate_rep
                .index
                .into_iter()
                .next()
                .ok_or_else(|| "index missing in PostJukeboxControlRequestOneOf1".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostJukeboxControlRequestOneOf1> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostJukeboxControlRequestOneOf1>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostJukeboxControlRequestOneOf1>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PostJukeboxControlRequestOneOf1 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<PostJukeboxControlRequestOneOf1>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PostJukeboxControlRequestOneOf1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PostJukeboxControlRequestOneOf1 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostJukeboxControlRequestOneOf2 {
    /// 'skip' action.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "action")]
    pub action: String,

    /// Zero-based index of the song to skip.
    #[serde(rename = "index")]
    #[validate(range(min = 0u32))]
    pub index: u32,

    /// (Since 1.7.0) Used by `skip`. Start playing this many seconds into the track.
    #[serde(rename = "offset")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub offset: Option<u32>,
}

impl PostJukeboxControlRequestOneOf2 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(action: String, index: u32) -> PostJukeboxControlRequestOneOf2 {
        PostJukeboxControlRequestOneOf2 {
            action,
            index,
            offset: None,
        }
    }
}

/// Converts the PostJukeboxControlRequestOneOf2 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostJukeboxControlRequestOneOf2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("action".to_string()),
            Some(self.action.to_string()),
            Some("index".to_string()),
            Some(self.index.to_string()),
            self.offset
                .as_ref()
                .map(|offset| ["offset".to_string(), offset.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostJukeboxControlRequestOneOf2 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostJukeboxControlRequestOneOf2 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub action: Vec<String>,
            pub index: Vec<u32>,
            pub offset: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostJukeboxControlRequestOneOf2".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "action" => intermediate_rep.action.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "offset" => intermediate_rep.offset.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostJukeboxControlRequestOneOf2"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostJukeboxControlRequestOneOf2 {
            action: intermediate_rep
                .action
                .into_iter()
                .next()
                .ok_or_else(|| "action missing in PostJukeboxControlRequestOneOf2".to_string())?,
            index: intermediate_rep
                .index
                .into_iter()
                .next()
                .ok_or_else(|| "index missing in PostJukeboxControlRequestOneOf2".to_string())?,
            offset: intermediate_rep.offset.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostJukeboxControlRequestOneOf2> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostJukeboxControlRequestOneOf2>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostJukeboxControlRequestOneOf2>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PostJukeboxControlRequestOneOf2 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<PostJukeboxControlRequestOneOf2>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PostJukeboxControlRequestOneOf2 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PostJukeboxControlRequestOneOf2 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostJukeboxControlRequestOneOf3 {
    /// 'add' action.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "action")]
    pub action: String,

    /// ID of song to add to the jukebox playlist. Use multiple id parameters to add many songs in the same request. (set is similar to a clear followed by an add, but will not change the currently playing track.)
    #[serde(rename = "id")]
    pub id: Vec<String>,
}

impl PostJukeboxControlRequestOneOf3 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(action: String, id: Vec<String>) -> PostJukeboxControlRequestOneOf3 {
        PostJukeboxControlRequestOneOf3 { action, id }
    }
}

/// Converts the PostJukeboxControlRequestOneOf3 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostJukeboxControlRequestOneOf3 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("action".to_string()),
            Some(self.action.to_string()),
            Some("id".to_string()),
            Some(
                self.id
                    .iter()
                    .map(|x| x.to_string())
                    .collect::<Vec<_>>()
                    .join(","),
            ),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostJukeboxControlRequestOneOf3 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostJukeboxControlRequestOneOf3 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub action: Vec<String>,
            pub id: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostJukeboxControlRequestOneOf3".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "action" => intermediate_rep.action.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "id" => return std::result::Result::Err("Parsing a container in this style is not supported in PostJukeboxControlRequestOneOf3".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PostJukeboxControlRequestOneOf3".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostJukeboxControlRequestOneOf3 {
            action: intermediate_rep
                .action
                .into_iter()
                .next()
                .ok_or_else(|| "action missing in PostJukeboxControlRequestOneOf3".to_string())?,
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostJukeboxControlRequestOneOf3".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostJukeboxControlRequestOneOf3> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostJukeboxControlRequestOneOf3>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostJukeboxControlRequestOneOf3>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PostJukeboxControlRequestOneOf3 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<PostJukeboxControlRequestOneOf3>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PostJukeboxControlRequestOneOf3 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PostJukeboxControlRequestOneOf3 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostJukeboxControlRequestOneOf4 {
    /// 'set' action.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "action")]
    pub action: String,

    /// ID of song to add to the jukebox playlist. Use multiple id parameters to add many songs in the same request. (set is similar to a clear followed by an add, but will not change the currently playing track.)
    #[serde(rename = "id")]
    pub id: Vec<String>,
}

impl PostJukeboxControlRequestOneOf4 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(action: String, id: Vec<String>) -> PostJukeboxControlRequestOneOf4 {
        PostJukeboxControlRequestOneOf4 { action, id }
    }
}

/// Converts the PostJukeboxControlRequestOneOf4 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostJukeboxControlRequestOneOf4 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("action".to_string()),
            Some(self.action.to_string()),
            Some("id".to_string()),
            Some(
                self.id
                    .iter()
                    .map(|x| x.to_string())
                    .collect::<Vec<_>>()
                    .join(","),
            ),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostJukeboxControlRequestOneOf4 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostJukeboxControlRequestOneOf4 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub action: Vec<String>,
            pub id: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostJukeboxControlRequestOneOf4".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "action" => intermediate_rep.action.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "id" => return std::result::Result::Err("Parsing a container in this style is not supported in PostJukeboxControlRequestOneOf4".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PostJukeboxControlRequestOneOf4".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostJukeboxControlRequestOneOf4 {
            action: intermediate_rep
                .action
                .into_iter()
                .next()
                .ok_or_else(|| "action missing in PostJukeboxControlRequestOneOf4".to_string())?,
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostJukeboxControlRequestOneOf4".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostJukeboxControlRequestOneOf4> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostJukeboxControlRequestOneOf4>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostJukeboxControlRequestOneOf4>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PostJukeboxControlRequestOneOf4 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<PostJukeboxControlRequestOneOf4>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PostJukeboxControlRequestOneOf4 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PostJukeboxControlRequestOneOf4 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostJukeboxControlRequestOneOf5 {
    /// 'setGain' action.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "action")]
    pub action: String,

    /// Used by `setGain` to control the playback volume. A float value between 0.0 and 1.0.
    #[serde(rename = "gain")]
    #[validate(range(min = 0f32, max = 1f32))]
    pub gain: f32,
}

impl PostJukeboxControlRequestOneOf5 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(action: String, gain: f32) -> PostJukeboxControlRequestOneOf5 {
        PostJukeboxControlRequestOneOf5 { action, gain }
    }
}

/// Converts the PostJukeboxControlRequestOneOf5 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostJukeboxControlRequestOneOf5 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("action".to_string()),
            Some(self.action.to_string()),
            Some("gain".to_string()),
            Some(self.gain.to_string()),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostJukeboxControlRequestOneOf5 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostJukeboxControlRequestOneOf5 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub action: Vec<String>,
            pub gain: Vec<f32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostJukeboxControlRequestOneOf5".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "action" => intermediate_rep.action.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "gain" => intermediate_rep.gain.push(
                        <f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostJukeboxControlRequestOneOf5"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostJukeboxControlRequestOneOf5 {
            action: intermediate_rep
                .action
                .into_iter()
                .next()
                .ok_or_else(|| "action missing in PostJukeboxControlRequestOneOf5".to_string())?,
            gain: intermediate_rep
                .gain
                .into_iter()
                .next()
                .ok_or_else(|| "gain missing in PostJukeboxControlRequestOneOf5".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostJukeboxControlRequestOneOf5> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostJukeboxControlRequestOneOf5>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostJukeboxControlRequestOneOf5>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PostJukeboxControlRequestOneOf5 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<PostJukeboxControlRequestOneOf5>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PostJukeboxControlRequestOneOf5 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PostJukeboxControlRequestOneOf5 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostSavePlayQueueRequest {
    /// ID of a song in the play queue. Use one id parameter for each song in the play queue.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The ID of the current playing song.
    #[serde(rename = "current")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub current: Option<String>,

    /// The position in milliseconds within the currently playing song.
    #[serde(rename = "position")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub position: Option<u32>,
}

impl PostSavePlayQueueRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PostSavePlayQueueRequest {
        PostSavePlayQueueRequest {
            id: None,
            current: None,
            position: None,
        }
    }
}

/// Converts the PostSavePlayQueueRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostSavePlayQueueRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            self.id
                .as_ref()
                .map(|id| ["id".to_string(), id.to_string()].join(",")),
            self.current
                .as_ref()
                .map(|current| ["current".to_string(), current.to_string()].join(",")),
            self.position
                .as_ref()
                .map(|position| ["position".to_string(), position.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostSavePlayQueueRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostSavePlayQueueRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub current: Vec<String>,
            pub position: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostSavePlayQueueRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "current" => intermediate_rep.current.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "position" => intermediate_rep.position.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostSavePlayQueueRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostSavePlayQueueRequest {
            id: intermediate_rep.id.into_iter().next(),
            current: intermediate_rep.current.into_iter().next(),
            position: intermediate_rep.position.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostSavePlayQueueRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostSavePlayQueueRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostSavePlayQueueRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostSavePlayQueueRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostSavePlayQueueRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostSavePlayQueueRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostSavePlayQueueRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostScrobbleRequest {
    /// A string which uniquely identifies the file to scrobble.
    #[serde(rename = "id")]
    pub id: String,

    /// (Since 1.8.0) The time (in milliseconds since 1 Jan 1970) at which the song was listened to.
    #[serde(rename = "time")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time: Option<u32>,

    /// Whether this is a “submission” or a “now playing” notification.
    #[serde(rename = "submission")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub submission: Option<bool>,
}

impl PostScrobbleRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostScrobbleRequest {
        PostScrobbleRequest {
            id,
            time: None,
            submission: Some(true),
        }
    }
}

/// Converts the PostScrobbleRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostScrobbleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            self.time
                .as_ref()
                .map(|time| ["time".to_string(), time.to_string()].join(",")),
            self.submission
                .as_ref()
                .map(|submission| ["submission".to_string(), submission.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostScrobbleRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostScrobbleRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub time: Vec<u32>,
            pub submission: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostScrobbleRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "time" => intermediate_rep.time.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "submission" => intermediate_rep.submission.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostScrobbleRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostScrobbleRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostScrobbleRequest".to_string())?,
            time: intermediate_rep.time.into_iter().next(),
            submission: intermediate_rep.submission.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostScrobbleRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostScrobbleRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostScrobbleRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostScrobbleRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostScrobbleRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostScrobbleRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostScrobbleRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostSearch2Request {
    /// Search query.
    #[serde(rename = "query")]
    pub query: String,

    /// Maximum number of artists to return.
    #[serde(rename = "artistCount")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist_count: Option<u32>,

    /// Search result offset for artists. Used for paging.
    #[serde(rename = "artistOffset")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist_offset: Option<u32>,

    /// Maximum number of albums to return.
    #[serde(rename = "albumCount")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album_count: Option<u32>,

    /// Search result offset for albums. Used for paging.
    #[serde(rename = "albumOffset")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album_offset: Option<u32>,

    /// Maximum number of songs to return.
    #[serde(rename = "songCount")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub song_count: Option<u32>,

    /// Search result offset for songs. Used for paging.
    #[serde(rename = "songOffset")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub song_offset: Option<u32>,

    /// (Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
    #[serde(rename = "musicFolderId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_folder_id: Option<String>,
}

impl PostSearch2Request {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(query: String) -> PostSearch2Request {
        PostSearch2Request {
            query,
            artist_count: Some(20),
            artist_offset: Some(0),
            album_count: Some(20),
            album_offset: Some(0),
            song_count: Some(20),
            song_offset: Some(0),
            music_folder_id: None,
        }
    }
}

/// Converts the PostSearch2Request value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostSearch2Request {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("query".to_string()),
            Some(self.query.to_string()),
            self.artist_count.as_ref().map(|artist_count| {
                ["artistCount".to_string(), artist_count.to_string()].join(",")
            }),
            self.artist_offset.as_ref().map(|artist_offset| {
                ["artistOffset".to_string(), artist_offset.to_string()].join(",")
            }),
            self.album_count
                .as_ref()
                .map(|album_count| ["albumCount".to_string(), album_count.to_string()].join(",")),
            self.album_offset.as_ref().map(|album_offset| {
                ["albumOffset".to_string(), album_offset.to_string()].join(",")
            }),
            self.song_count
                .as_ref()
                .map(|song_count| ["songCount".to_string(), song_count.to_string()].join(",")),
            self.song_offset
                .as_ref()
                .map(|song_offset| ["songOffset".to_string(), song_offset.to_string()].join(",")),
            self.music_folder_id.as_ref().map(|music_folder_id| {
                ["musicFolderId".to_string(), music_folder_id.to_string()].join(",")
            }),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostSearch2Request value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostSearch2Request {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub query: Vec<String>,
            pub artist_count: Vec<u32>,
            pub artist_offset: Vec<u32>,
            pub album_count: Vec<u32>,
            pub album_offset: Vec<u32>,
            pub song_count: Vec<u32>,
            pub song_offset: Vec<u32>,
            pub music_folder_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostSearch2Request".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "query" => intermediate_rep.query.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artistCount" => intermediate_rep.artist_count.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artistOffset" => intermediate_rep.artist_offset.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "albumCount" => intermediate_rep.album_count.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "albumOffset" => intermediate_rep.album_offset.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "songCount" => intermediate_rep.song_count.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "songOffset" => intermediate_rep.song_offset.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "musicFolderId" => intermediate_rep.music_folder_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostSearch2Request".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostSearch2Request {
            query: intermediate_rep
                .query
                .into_iter()
                .next()
                .ok_or_else(|| "query missing in PostSearch2Request".to_string())?,
            artist_count: intermediate_rep.artist_count.into_iter().next(),
            artist_offset: intermediate_rep.artist_offset.into_iter().next(),
            album_count: intermediate_rep.album_count.into_iter().next(),
            album_offset: intermediate_rep.album_offset.into_iter().next(),
            song_count: intermediate_rep.song_count.into_iter().next(),
            song_offset: intermediate_rep.song_offset.into_iter().next(),
            music_folder_id: intermediate_rep.music_folder_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostSearch2Request> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostSearch2Request>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostSearch2Request>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostSearch2Request - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostSearch2Request> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostSearch2Request as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostSearch2Request - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostSearch3Request {
    /// Search query. Servers must support an empty query and return all the data to allow clients to properly access all the media information for offline sync.
    #[serde(rename = "query")]
    pub query: String,

    /// Maximum number of artists to return.
    #[serde(rename = "artistCount")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist_count: Option<u32>,

    /// Search result offset for artists. Used for paging.
    #[serde(rename = "artistOffset")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist_offset: Option<u32>,

    /// Maximum number of albums to return.
    #[serde(rename = "albumCount")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album_count: Option<u32>,

    /// Search result offset for albums. Used for paging.
    #[serde(rename = "albumOffset")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album_offset: Option<u32>,

    /// Maximum number of songs to return.
    #[serde(rename = "songCount")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub song_count: Option<u32>,

    /// Search result offset for songs. Used for paging.
    #[serde(rename = "songOffset")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub song_offset: Option<u32>,

    /// (Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
    #[serde(rename = "musicFolderId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_folder_id: Option<String>,
}

impl PostSearch3Request {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(query: String) -> PostSearch3Request {
        PostSearch3Request {
            query,
            artist_count: Some(20),
            artist_offset: Some(0),
            album_count: Some(20),
            album_offset: Some(0),
            song_count: Some(20),
            song_offset: Some(0),
            music_folder_id: None,
        }
    }
}

/// Converts the PostSearch3Request value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostSearch3Request {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("query".to_string()),
            Some(self.query.to_string()),
            self.artist_count.as_ref().map(|artist_count| {
                ["artistCount".to_string(), artist_count.to_string()].join(",")
            }),
            self.artist_offset.as_ref().map(|artist_offset| {
                ["artistOffset".to_string(), artist_offset.to_string()].join(",")
            }),
            self.album_count
                .as_ref()
                .map(|album_count| ["albumCount".to_string(), album_count.to_string()].join(",")),
            self.album_offset.as_ref().map(|album_offset| {
                ["albumOffset".to_string(), album_offset.to_string()].join(",")
            }),
            self.song_count
                .as_ref()
                .map(|song_count| ["songCount".to_string(), song_count.to_string()].join(",")),
            self.song_offset
                .as_ref()
                .map(|song_offset| ["songOffset".to_string(), song_offset.to_string()].join(",")),
            self.music_folder_id.as_ref().map(|music_folder_id| {
                ["musicFolderId".to_string(), music_folder_id.to_string()].join(",")
            }),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostSearch3Request value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostSearch3Request {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub query: Vec<String>,
            pub artist_count: Vec<u32>,
            pub artist_offset: Vec<u32>,
            pub album_count: Vec<u32>,
            pub album_offset: Vec<u32>,
            pub song_count: Vec<u32>,
            pub song_offset: Vec<u32>,
            pub music_folder_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostSearch3Request".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "query" => intermediate_rep.query.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artistCount" => intermediate_rep.artist_count.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artistOffset" => intermediate_rep.artist_offset.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "albumCount" => intermediate_rep.album_count.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "albumOffset" => intermediate_rep.album_offset.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "songCount" => intermediate_rep.song_count.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "songOffset" => intermediate_rep.song_offset.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "musicFolderId" => intermediate_rep.music_folder_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostSearch3Request".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostSearch3Request {
            query: intermediate_rep
                .query
                .into_iter()
                .next()
                .ok_or_else(|| "query missing in PostSearch3Request".to_string())?,
            artist_count: intermediate_rep.artist_count.into_iter().next(),
            artist_offset: intermediate_rep.artist_offset.into_iter().next(),
            album_count: intermediate_rep.album_count.into_iter().next(),
            album_offset: intermediate_rep.album_offset.into_iter().next(),
            song_count: intermediate_rep.song_count.into_iter().next(),
            song_offset: intermediate_rep.song_offset.into_iter().next(),
            music_folder_id: intermediate_rep.music_folder_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostSearch3Request> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostSearch3Request>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostSearch3Request>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostSearch3Request - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostSearch3Request> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostSearch3Request as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostSearch3Request - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostSearchRequest {
    /// Artist to search for.
    #[serde(rename = "artist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist: Option<String>,

    /// Album to search for.
    #[serde(rename = "album")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album: Option<String>,

    /// Song title to search for.
    #[serde(rename = "title")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,

    /// Searches all fields.
    #[serde(rename = "any")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub any: Option<bool>,

    /// Maximum number of results to return.
    #[serde(rename = "count")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<u32>,

    /// Search result offset. Used for paging.
    #[serde(rename = "offset")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub offset: Option<u32>,

    /// Only return matches that are newer than this. Given as milliseconds since 1970.
    #[serde(rename = "newerThan")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub newer_than: Option<u32>,
}

impl PostSearchRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PostSearchRequest {
        PostSearchRequest {
            artist: None,
            album: None,
            title: None,
            any: Some(false),
            count: Some(20),
            offset: Some(0),
            newer_than: None,
        }
    }
}

/// Converts the PostSearchRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostSearchRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            self.artist
                .as_ref()
                .map(|artist| ["artist".to_string(), artist.to_string()].join(",")),
            self.album
                .as_ref()
                .map(|album| ["album".to_string(), album.to_string()].join(",")),
            self.title
                .as_ref()
                .map(|title| ["title".to_string(), title.to_string()].join(",")),
            self.any
                .as_ref()
                .map(|any| ["any".to_string(), any.to_string()].join(",")),
            self.count
                .as_ref()
                .map(|count| ["count".to_string(), count.to_string()].join(",")),
            self.offset
                .as_ref()
                .map(|offset| ["offset".to_string(), offset.to_string()].join(",")),
            self.newer_than
                .as_ref()
                .map(|newer_than| ["newerThan".to_string(), newer_than.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostSearchRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostSearchRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub artist: Vec<String>,
            pub album: Vec<String>,
            pub title: Vec<String>,
            pub any: Vec<bool>,
            pub count: Vec<u32>,
            pub offset: Vec<u32>,
            pub newer_than: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostSearchRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "artist" => intermediate_rep.artist.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "album" => intermediate_rep.album.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "any" => intermediate_rep.any.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "offset" => intermediate_rep.offset.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "newerThan" => intermediate_rep.newer_than.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostSearchRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostSearchRequest {
            artist: intermediate_rep.artist.into_iter().next(),
            album: intermediate_rep.album.into_iter().next(),
            title: intermediate_rep.title.into_iter().next(),
            any: intermediate_rep.any.into_iter().next(),
            count: intermediate_rep.count.into_iter().next(),
            offset: intermediate_rep.offset.into_iter().next(),
            newer_than: intermediate_rep.newer_than.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostSearchRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostSearchRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostSearchRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostSearchRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostSearchRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostSearchRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostSearchRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostSetRatingRequest {
    /// A string which uniquely identifies the file (song) or folder (album/artist) to rate.
    #[serde(rename = "id")]
    pub id: String,

    /// The rating between 1 and 5 (inclusive), or 0 to remove the rating.
    #[serde(rename = "rating")]
    #[validate(range(min = 0u8, max = 5u8))]
    pub rating: u8,
}

impl PostSetRatingRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, rating: u8) -> PostSetRatingRequest {
        PostSetRatingRequest { id, rating }
    }
}

/// Converts the PostSetRatingRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostSetRatingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            Some("rating".to_string()),
            Some(self.rating.to_string()),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostSetRatingRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostSetRatingRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub rating: Vec<u8>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostSetRatingRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "rating" => intermediate_rep
                        .rating
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostSetRatingRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostSetRatingRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostSetRatingRequest".to_string())?,
            rating: intermediate_rep
                .rating
                .into_iter()
                .next()
                .ok_or_else(|| "rating missing in PostSetRatingRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostSetRatingRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostSetRatingRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostSetRatingRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostSetRatingRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostSetRatingRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostSetRatingRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostSetRatingRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostStarRequest {
    /// The ID of the file (song) or folder (album/artist) to star. Multiple parameters allowed.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<Vec<String>>,

    /// The ID of an album to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.
    #[serde(rename = "albumId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album_id: Option<Vec<String>>,

    /// The ID of an artist to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.
    #[serde(rename = "artistId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist_id: Option<Vec<String>>,
}

impl PostStarRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PostStarRequest {
        PostStarRequest {
            id: None,
            album_id: None,
            artist_id: None,
        }
    }
}

/// Converts the PostStarRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostStarRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.album_id.as_ref().map(|album_id| {
                [
                    "albumId".to_string(),
                    album_id
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.artist_id.as_ref().map(|artist_id| {
                [
                    "artistId".to_string(),
                    artist_id
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostStarRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostStarRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<Vec<String>>,
            pub album_id: Vec<Vec<String>>,
            pub artist_id: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostStarRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "id" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PostStarRequest"
                                .to_string(),
                        )
                    }
                    "albumId" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PostStarRequest"
                                .to_string(),
                        )
                    }
                    "artistId" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PostStarRequest"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostStarRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostStarRequest {
            id: intermediate_rep.id.into_iter().next(),
            album_id: intermediate_rep.album_id.into_iter().next(),
            artist_id: intermediate_rep.artist_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostStarRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostStarRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostStarRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostStarRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostStarRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostStarRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostStarRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostStreamRequest {
    /// A string which uniquely identifies the file to stream. Obtained by calls to getMusicDirectory.
    #[serde(rename = "id")]
    pub id: String,

    /// (Since 1.2.0) If specified, the server will attempt to limit the bitrate to this value, in kilobits per second. If set to zero, no limit is imposed.
    #[serde(rename = "maxBitRate")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_bit_rate: Option<u32>,

    /// (Since 1.6.0) Specifies the preferred target format (e.g., “mp3” or “flv”) in case there are multiple applicable transcodings. Starting with 1.9.0 you can use the special value “raw” to disable transcoding.
    #[serde(rename = "format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub format: Option<String>,

    /// By default only applicable to video streaming. If specified, start streaming at the given offset (in seconds) into the media. The `Transcode Offset` extension enables the parameter to music too.
    #[serde(rename = "timeOffset")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time_offset: Option<u32>,

    /// (Since 1.6.0) Only applicable to video streaming. Requested video size specified as WxH, for instance “640x480”.
    #[serde(rename = "size")]
    #[validate(
            regex(path = *RE_POSTSTREAMREQUEST_SIZE),
        )]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<String>,

    /// (Since 1.8.0). If set to “true”, the Content-Length HTTP header will be set to an estimated value for transcoded or downsampled media.
    #[serde(rename = "estimateContentLength")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub estimate_content_length: Option<bool>,

    /// (Since 1.14.0) Only applicable to video streaming. Servers can optimize videos for streaming by converting them to MP4. If a conversion exists for the video in question, then setting this parameter to “true” will cause the converted video to be returned instead of the original.
    #[serde(rename = "converted")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub converted: Option<bool>,
}

lazy_static::lazy_static! {
    static ref RE_POSTSTREAMREQUEST_SIZE: regex::Regex = regex::Regex::new(r"^[0-9]+x[0-9]+$").unwrap();
}

impl PostStreamRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostStreamRequest {
        PostStreamRequest {
            id,
            max_bit_rate: None,
            format: None,
            time_offset: None,
            size: None,
            estimate_content_length: Some(false),
            converted: Some(false),
        }
    }
}

/// Converts the PostStreamRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostStreamRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            self.max_bit_rate
                .as_ref()
                .map(|max_bit_rate| ["maxBitRate".to_string(), max_bit_rate.to_string()].join(",")),
            self.format
                .as_ref()
                .map(|format| ["format".to_string(), format.to_string()].join(",")),
            self.time_offset
                .as_ref()
                .map(|time_offset| ["timeOffset".to_string(), time_offset.to_string()].join(",")),
            self.size
                .as_ref()
                .map(|size| ["size".to_string(), size.to_string()].join(",")),
            self.estimate_content_length
                .as_ref()
                .map(|estimate_content_length| {
                    [
                        "estimateContentLength".to_string(),
                        estimate_content_length.to_string(),
                    ]
                    .join(",")
                }),
            self.converted
                .as_ref()
                .map(|converted| ["converted".to_string(), converted.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostStreamRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostStreamRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub max_bit_rate: Vec<u32>,
            pub format: Vec<String>,
            pub time_offset: Vec<u32>,
            pub size: Vec<String>,
            pub estimate_content_length: Vec<bool>,
            pub converted: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostStreamRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "maxBitRate" => intermediate_rep.max_bit_rate.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "format" => intermediate_rep.format.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "timeOffset" => intermediate_rep.time_offset.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "size" => intermediate_rep.size.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "estimateContentLength" => intermediate_rep.estimate_content_length.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "converted" => intermediate_rep.converted.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostStreamRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostStreamRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostStreamRequest".to_string())?,
            max_bit_rate: intermediate_rep.max_bit_rate.into_iter().next(),
            format: intermediate_rep.format.into_iter().next(),
            time_offset: intermediate_rep.time_offset.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
            estimate_content_length: intermediate_rep.estimate_content_length.into_iter().next(),
            converted: intermediate_rep.converted.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostStreamRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostStreamRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostStreamRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostStreamRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostStreamRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostStreamRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostStreamRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostUnstarRequest {
    /// The ID of the file (song) or folder (album/artist) to unstar. Multiple parameters allowed.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<crate::types::Object>,

    /// The ID of an album to unstar. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.
    #[serde(rename = "albumId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album_id: Option<crate::types::Object>,

    /// The ID of an artist to unstar. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.
    #[serde(rename = "artistId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist_id: Option<crate::types::Object>,
}

impl PostUnstarRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PostUnstarRequest {
        PostUnstarRequest {
            id: None,
            album_id: None,
            artist_id: None,
        }
    }
}

/// Converts the PostUnstarRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostUnstarRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping id in query parameter serialization

            // Skipping albumId in query parameter serialization

            // Skipping artistId in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostUnstarRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostUnstarRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<crate::types::Object>,
            pub album_id: Vec<crate::types::Object>,
            pub artist_id: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostUnstarRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <crate::types::Object as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "albumId" => intermediate_rep.album_id.push(
                        <crate::types::Object as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "artistId" => intermediate_rep.artist_id.push(
                        <crate::types::Object as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostUnstarRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostUnstarRequest {
            id: intermediate_rep.id.into_iter().next(),
            album_id: intermediate_rep.album_id.into_iter().next(),
            artist_id: intermediate_rep.artist_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostUnstarRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostUnstarRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostUnstarRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostUnstarRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostUnstarRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostUnstarRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostUnstarRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostUpdateInternetRadioStationRequest {
    /// The ID of the station.
    #[serde(rename = "id")]
    pub id: String,

    /// The stream URL for the station.
    #[serde(rename = "streamUrl")]
    pub stream_url: String,

    /// The user-defined name for the station.
    #[serde(rename = "name")]
    pub name: String,

    /// The home page URL for the station.
    #[serde(rename = "homepageUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub homepage_url: Option<String>,
}

impl PostUpdateInternetRadioStationRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        id: String,
        stream_url: String,
        name: String,
    ) -> PostUpdateInternetRadioStationRequest {
        PostUpdateInternetRadioStationRequest {
            id,
            stream_url,
            name,
            homepage_url: None,
        }
    }
}

/// Converts the PostUpdateInternetRadioStationRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostUpdateInternetRadioStationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            Some("streamUrl".to_string()),
            Some(self.stream_url.to_string()),
            Some("name".to_string()),
            Some(self.name.to_string()),
            self.homepage_url.as_ref().map(|homepage_url| {
                ["homepageUrl".to_string(), homepage_url.to_string()].join(",")
            }),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostUpdateInternetRadioStationRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostUpdateInternetRadioStationRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub stream_url: Vec<String>,
            pub name: Vec<String>,
            pub homepage_url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostUpdateInternetRadioStationRequest"
                            .to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "streamUrl" => intermediate_rep.stream_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "homepageUrl" => intermediate_rep.homepage_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostUpdateInternetRadioStationRequest"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostUpdateInternetRadioStationRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostUpdateInternetRadioStationRequest".to_string())?,
            stream_url: intermediate_rep
                .stream_url
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "streamUrl missing in PostUpdateInternetRadioStationRequest".to_string()
                })?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| {
                "name missing in PostUpdateInternetRadioStationRequest".to_string()
            })?,
            homepage_url: intermediate_rep.homepage_url.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostUpdateInternetRadioStationRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostUpdateInternetRadioStationRequest>>
    for HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostUpdateInternetRadioStationRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PostUpdateInternetRadioStationRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue>
    for header::IntoHeaderValue<PostUpdateInternetRadioStationRequest>
{
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PostUpdateInternetRadioStationRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PostUpdateInternetRadioStationRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostUpdatePlaylistRequest {
    /// The playlist ID.
    #[serde(rename = "playlistId")]
    pub playlist_id: String,

    /// The human-readable name of the playlist.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// The playlist comment.
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,

    /// `true` if the playlist should be visible to all users, `false` otherwise.
    #[serde(rename = "public")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub public: Option<bool>,

    /// Add this song with this ID to the playlist. Multiple parameters allowed.
    #[serde(rename = "songIdToAdd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub song_id_to_add: Option<Vec<String>>,

    /// Remove the song at this position in the playlist. Multiple parameters allowed.
    #[serde(rename = "songIndexToRemove")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub song_index_to_remove: Option<Vec<i32>>,
}

impl PostUpdatePlaylistRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(playlist_id: String) -> PostUpdatePlaylistRequest {
        PostUpdatePlaylistRequest {
            playlist_id,
            name: None,
            comment: None,
            public: None,
            song_id_to_add: None,
            song_index_to_remove: None,
        }
    }
}

/// Converts the PostUpdatePlaylistRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostUpdatePlaylistRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("playlistId".to_string()),
            Some(self.playlist_id.to_string()),
            self.name
                .as_ref()
                .map(|name| ["name".to_string(), name.to_string()].join(",")),
            self.comment
                .as_ref()
                .map(|comment| ["comment".to_string(), comment.to_string()].join(",")),
            self.public
                .as_ref()
                .map(|public| ["public".to_string(), public.to_string()].join(",")),
            self.song_id_to_add.as_ref().map(|song_id_to_add| {
                [
                    "songIdToAdd".to_string(),
                    song_id_to_add
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.song_index_to_remove
                .as_ref()
                .map(|song_index_to_remove| {
                    [
                        "songIndexToRemove".to_string(),
                        song_index_to_remove
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostUpdatePlaylistRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostUpdatePlaylistRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub playlist_id: Vec<String>,
            pub name: Vec<String>,
            pub comment: Vec<String>,
            pub public: Vec<bool>,
            pub song_id_to_add: Vec<Vec<String>>,
            pub song_index_to_remove: Vec<Vec<i32>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostUpdatePlaylistRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "playlistId" => intermediate_rep.playlist_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "comment" => intermediate_rep.comment.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "public" => intermediate_rep.public.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "songIdToAdd" => return std::result::Result::Err("Parsing a container in this style is not supported in PostUpdatePlaylistRequest".to_string()),
                    "songIndexToRemove" => return std::result::Result::Err("Parsing a container in this style is not supported in PostUpdatePlaylistRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PostUpdatePlaylistRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostUpdatePlaylistRequest {
            playlist_id: intermediate_rep
                .playlist_id
                .into_iter()
                .next()
                .ok_or_else(|| "playlistId missing in PostUpdatePlaylistRequest".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            comment: intermediate_rep.comment.into_iter().next(),
            public: intermediate_rep.public.into_iter().next(),
            song_id_to_add: intermediate_rep.song_id_to_add.into_iter().next(),
            song_index_to_remove: intermediate_rep.song_index_to_remove.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostUpdatePlaylistRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostUpdatePlaylistRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostUpdatePlaylistRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostUpdatePlaylistRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostUpdatePlaylistRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostUpdatePlaylistRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostUpdatePlaylistRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostUpdateShareRequest {
    /// ID of the share to update.
    #[serde(rename = "id")]
    pub id: String,

    /// A user-defined description that will be displayed to people visiting the shared media.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// The time at which the share expires. Given as milliseconds since 1970, or zero to remove the expiration.
    #[serde(rename = "expires")]
    #[validate(range(min = 0u32))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires: Option<u32>,
}

impl PostUpdateShareRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String) -> PostUpdateShareRequest {
        PostUpdateShareRequest {
            id,
            description: None,
            expires: None,
        }
    }
}

/// Converts the PostUpdateShareRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostUpdateShareRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            self.description
                .as_ref()
                .map(|description| ["description".to_string(), description.to_string()].join(",")),
            self.expires
                .as_ref()
                .map(|expires| ["expires".to_string(), expires.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostUpdateShareRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostUpdateShareRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub description: Vec<String>,
            pub expires: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostUpdateShareRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "expires" => intermediate_rep.expires.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PostUpdateShareRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostUpdateShareRequest {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in PostUpdateShareRequest".to_string())?,
            description: intermediate_rep.description.into_iter().next(),
            expires: intermediate_rep.expires.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostUpdateShareRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostUpdateShareRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostUpdateShareRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostUpdateShareRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostUpdateShareRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostUpdateShareRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostUpdateShareRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PostUpdateUserRequest {
    /// The name of the user.
    #[serde(rename = "username")]
    pub username: String,

    /// The password of the user, either in clear text or hex-encoded.
    #[serde(rename = "password")]
    pub password: String,

    /// The email address of the user.
    #[serde(rename = "email")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<String>,

    /// Whether the user is authenticated in LDAP.
    #[serde(rename = "ldapAuthenticated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ldap_authenticated: Option<bool>,

    /// Whether the user is an administrator.
    #[serde(rename = "adminRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub admin_role: Option<bool>,

    /// Whether the user is allowed to change personal settings and password.
    #[serde(rename = "settingsRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub settings_role: Option<bool>,

    /// Whether the user is allowed to play files.
    #[serde(rename = "streamRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_role: Option<bool>,

    /// Whether the user is allowed to play files in jukebox mode.
    #[serde(rename = "jukeboxRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub jukebox_role: Option<bool>,

    /// Whether the user is allowed to download files.
    #[serde(rename = "downloadRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub download_role: Option<bool>,

    /// Whether the user is allowed to upload files.
    #[serde(rename = "uploadRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub upload_role: Option<bool>,

    /// Whether the user is allowed to change cover art and tags.
    #[serde(rename = "coverArtRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cover_art_role: Option<bool>,

    /// Whether the user is allowed to create and edit comments and ratings.
    #[serde(rename = "commentRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment_role: Option<bool>,

    /// Whether the user is allowed to administrate Podcasts.
    #[serde(rename = "podcastRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub podcast_role: Option<bool>,

    /// Whether the user is allowed to share files with anyone.
    #[serde(rename = "shareRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub share_role: Option<bool>,

    /// (Since 1.15.0) Whether the user is allowed to start video conversions.
    #[serde(rename = "videoConversionRole")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub video_conversion_role: Option<bool>,

    /// (Since 1.12.0) IDs of the music folders the user is allowed access to. Include the parameter once for each folder.
    #[serde(rename = "musicFolderId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub music_folder_id: Option<Vec<String>>,

    /// (Since 1.13.0) The maximum bit rate (in Kbps) for the user. Audio streams of higher bit rates are automatically downsampled to this bit rate. Legal values: 0 (no limit), 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "maxBitRate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_bit_rate: Option<i32>,
}

impl PostUpdateUserRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(username: String, password: String) -> PostUpdateUserRequest {
        PostUpdateUserRequest {
            username,
            password,
            email: None,
            ldap_authenticated: Some(false),
            admin_role: Some(false),
            settings_role: Some(true),
            stream_role: Some(true),
            jukebox_role: Some(false),
            download_role: Some(false),
            upload_role: Some(false),
            cover_art_role: Some(false),
            comment_role: Some(false),
            podcast_role: Some(false),
            share_role: Some(false),
            video_conversion_role: Some(false),
            music_folder_id: None,
            max_bit_rate: None,
        }
    }
}

/// Converts the PostUpdateUserRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PostUpdateUserRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("username".to_string()),
            Some(self.username.to_string()),
            Some("password".to_string()),
            Some(self.password.to_string()),
            self.email
                .as_ref()
                .map(|email| ["email".to_string(), email.to_string()].join(",")),
            self.ldap_authenticated.as_ref().map(|ldap_authenticated| {
                [
                    "ldapAuthenticated".to_string(),
                    ldap_authenticated.to_string(),
                ]
                .join(",")
            }),
            self.admin_role
                .as_ref()
                .map(|admin_role| ["adminRole".to_string(), admin_role.to_string()].join(",")),
            self.settings_role.as_ref().map(|settings_role| {
                ["settingsRole".to_string(), settings_role.to_string()].join(",")
            }),
            self.stream_role
                .as_ref()
                .map(|stream_role| ["streamRole".to_string(), stream_role.to_string()].join(",")),
            self.jukebox_role.as_ref().map(|jukebox_role| {
                ["jukeboxRole".to_string(), jukebox_role.to_string()].join(",")
            }),
            self.download_role.as_ref().map(|download_role| {
                ["downloadRole".to_string(), download_role.to_string()].join(",")
            }),
            self.upload_role
                .as_ref()
                .map(|upload_role| ["uploadRole".to_string(), upload_role.to_string()].join(",")),
            self.cover_art_role.as_ref().map(|cover_art_role| {
                ["coverArtRole".to_string(), cover_art_role.to_string()].join(",")
            }),
            self.comment_role.as_ref().map(|comment_role| {
                ["commentRole".to_string(), comment_role.to_string()].join(",")
            }),
            self.podcast_role.as_ref().map(|podcast_role| {
                ["podcastRole".to_string(), podcast_role.to_string()].join(",")
            }),
            self.share_role
                .as_ref()
                .map(|share_role| ["shareRole".to_string(), share_role.to_string()].join(",")),
            self.video_conversion_role
                .as_ref()
                .map(|video_conversion_role| {
                    [
                        "videoConversionRole".to_string(),
                        video_conversion_role.to_string(),
                    ]
                    .join(",")
                }),
            self.music_folder_id.as_ref().map(|music_folder_id| {
                [
                    "musicFolderId".to_string(),
                    music_folder_id
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.max_bit_rate
                .as_ref()
                .map(|max_bit_rate| ["maxBitRate".to_string(), max_bit_rate.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PostUpdateUserRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PostUpdateUserRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub username: Vec<String>,
            pub password: Vec<String>,
            pub email: Vec<String>,
            pub ldap_authenticated: Vec<bool>,
            pub admin_role: Vec<bool>,
            pub settings_role: Vec<bool>,
            pub stream_role: Vec<bool>,
            pub jukebox_role: Vec<bool>,
            pub download_role: Vec<bool>,
            pub upload_role: Vec<bool>,
            pub cover_art_role: Vec<bool>,
            pub comment_role: Vec<bool>,
            pub podcast_role: Vec<bool>,
            pub share_role: Vec<bool>,
            pub video_conversion_role: Vec<bool>,
            pub music_folder_id: Vec<Vec<String>>,
            pub max_bit_rate: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PostUpdateUserRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "password" => intermediate_rep.password.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "email" => intermediate_rep.email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ldapAuthenticated" => intermediate_rep.ldap_authenticated.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "adminRole" => intermediate_rep.admin_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "settingsRole" => intermediate_rep.settings_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "streamRole" => intermediate_rep.stream_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "jukeboxRole" => intermediate_rep.jukebox_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "downloadRole" => intermediate_rep.download_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "uploadRole" => intermediate_rep.upload_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "coverArtRole" => intermediate_rep.cover_art_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "commentRole" => intermediate_rep.comment_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "podcastRole" => intermediate_rep.podcast_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shareRole" => intermediate_rep.share_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "videoConversionRole" => intermediate_rep.video_conversion_role.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "musicFolderId" => return std::result::Result::Err("Parsing a container in this style is not supported in PostUpdateUserRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "maxBitRate" => intermediate_rep.max_bit_rate.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PostUpdateUserRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PostUpdateUserRequest {
            username: intermediate_rep
                .username
                .into_iter()
                .next()
                .ok_or_else(|| "username missing in PostUpdateUserRequest".to_string())?,
            password: intermediate_rep
                .password
                .into_iter()
                .next()
                .ok_or_else(|| "password missing in PostUpdateUserRequest".to_string())?,
            email: intermediate_rep.email.into_iter().next(),
            ldap_authenticated: intermediate_rep.ldap_authenticated.into_iter().next(),
            admin_role: intermediate_rep.admin_role.into_iter().next(),
            settings_role: intermediate_rep.settings_role.into_iter().next(),
            stream_role: intermediate_rep.stream_role.into_iter().next(),
            jukebox_role: intermediate_rep.jukebox_role.into_iter().next(),
            download_role: intermediate_rep.download_role.into_iter().next(),
            upload_role: intermediate_rep.upload_role.into_iter().next(),
            cover_art_role: intermediate_rep.cover_art_role.into_iter().next(),
            comment_role: intermediate_rep.comment_role.into_iter().next(),
            podcast_role: intermediate_rep.podcast_role.into_iter().next(),
            share_role: intermediate_rep.share_role.into_iter().next(),
            video_conversion_role: intermediate_rep.video_conversion_role.into_iter().next(),
            music_folder_id: intermediate_rep.music_folder_id.into_iter().next(),
            max_bit_rate: intermediate_rep.max_bit_rate.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PostUpdateUserRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PostUpdateUserRequest>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PostUpdateUserRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PostUpdateUserRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PostUpdateUserRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PostUpdateUserRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PostUpdateUserRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A record label for an album.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RecordLabel {
    #[serde(rename = "name")]
    pub name: String,
}

impl RecordLabel {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String) -> RecordLabel {
        RecordLabel { name }
    }
}

/// Converts the RecordLabel value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RecordLabel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> =
            vec![Some("name".to_string()), Some(self.name.to_string())];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RecordLabel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RecordLabel {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing RecordLabel".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing RecordLabel".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RecordLabel {
            name: intermediate_rep
                .name
                .into_iter()
                .next()
                .ok_or_else(|| "name missing in RecordLabel".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RecordLabel> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RecordLabel>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<RecordLabel>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for RecordLabel - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RecordLabel> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <RecordLabel as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into RecordLabel - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// The replay gain data of a song. Note: If the data is not present the field must be ommited in the answer. (But the replayGain field on Child must always be present)
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ReplayGain {
    /// The track replay gain value. (In Db)
    #[serde(rename = "trackGain")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub track_gain: Option<f64>,

    /// The album replay gain value. (In Db)
    #[serde(rename = "albumGain")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album_gain: Option<f64>,

    /// The track peak value. (Must be positive)
    #[serde(rename = "trackPeak")]
    #[validate(range(min = 0f64))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub track_peak: Option<f64>,

    /// The album peak value. (Must be positive)
    #[serde(rename = "albumPeak")]
    #[validate(range(min = 0f64))]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album_peak: Option<f64>,

    /// The base gain value. (In Db) (Ogg Opus Output Gain for example)
    #[serde(rename = "baseGain")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub base_gain: Option<f64>,

    /// An optional fallback gain that clients should apply when the corresponding gain value is missing. (Can be computed from the tracks or exposed as an user setting.)
    #[serde(rename = "fallbackGain")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fallback_gain: Option<f64>,
}

impl ReplayGain {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ReplayGain {
        ReplayGain {
            track_gain: None,
            album_gain: None,
            track_peak: None,
            album_peak: None,
            base_gain: None,
            fallback_gain: None,
        }
    }
}

/// Converts the ReplayGain value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ReplayGain {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            self.track_gain
                .as_ref()
                .map(|track_gain| ["trackGain".to_string(), track_gain.to_string()].join(",")),
            self.album_gain
                .as_ref()
                .map(|album_gain| ["albumGain".to_string(), album_gain.to_string()].join(",")),
            self.track_peak
                .as_ref()
                .map(|track_peak| ["trackPeak".to_string(), track_peak.to_string()].join(",")),
            self.album_peak
                .as_ref()
                .map(|album_peak| ["albumPeak".to_string(), album_peak.to_string()].join(",")),
            self.base_gain
                .as_ref()
                .map(|base_gain| ["baseGain".to_string(), base_gain.to_string()].join(",")),
            self.fallback_gain.as_ref().map(|fallback_gain| {
                ["fallbackGain".to_string(), fallback_gain.to_string()].join(",")
            }),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ReplayGain value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ReplayGain {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub track_gain: Vec<f64>,
            pub album_gain: Vec<f64>,
            pub track_peak: Vec<f64>,
            pub album_peak: Vec<f64>,
            pub base_gain: Vec<f64>,
            pub fallback_gain: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ReplayGain".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "trackGain" => intermediate_rep.track_gain.push(
                        <f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "albumGain" => intermediate_rep.album_gain.push(
                        <f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "trackPeak" => intermediate_rep.track_peak.push(
                        <f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "albumPeak" => intermediate_rep.album_peak.push(
                        <f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "baseGain" => intermediate_rep.base_gain.push(
                        <f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "fallbackGain" => intermediate_rep.fallback_gain.push(
                        <f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ReplayGain".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ReplayGain {
            track_gain: intermediate_rep.track_gain.into_iter().next(),
            album_gain: intermediate_rep.album_gain.into_iter().next(),
            track_peak: intermediate_rep.track_peak.into_iter().next(),
            album_peak: intermediate_rep.album_peak.into_iter().next(),
            base_gain: intermediate_rep.base_gain.into_iter().next(),
            fallback_gain: intermediate_rep.fallback_gain.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ReplayGain> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ReplayGain>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ReplayGain>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ReplayGain - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ReplayGain> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ReplayGain as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ReplayGain - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Scan status information.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ScanStatus {
    /// The status of the scan
    #[serde(rename = "scanning")]
    pub scanning: bool,

    /// Scanned item count
    #[serde(rename = "count")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<i32>,
}

impl ScanStatus {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(scanning: bool) -> ScanStatus {
        ScanStatus {
            scanning,
            count: None,
        }
    }
}

/// Converts the ScanStatus value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ScanStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("scanning".to_string()),
            Some(self.scanning.to_string()),
            self.count
                .as_ref()
                .map(|count| ["count".to_string(), count.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ScanStatus value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ScanStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub scanning: Vec<bool>,
            pub count: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ScanStatus".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "scanning" => intermediate_rep.scanning.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ScanStatus".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ScanStatus {
            scanning: intermediate_rep
                .scanning
                .into_iter()
                .next()
                .ok_or_else(|| "scanning missing in ScanStatus".to_string())?,
            count: intermediate_rep.count.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ScanStatus> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ScanStatus>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ScanStatus>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ScanStatus - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ScanStatus> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ScanStatus as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ScanStatus - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested `searchResult2` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Search2Response {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::Search2ResponseSubsonicResponse>,
}

impl Search2Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Search2Response {
        Search2Response {
            subsonic_response: None,
        }
    }
}

/// Converts the Search2Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Search2Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Search2Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Search2Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::Search2ResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Search2Response".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(
                        <models::Search2ResponseSubsonicResponse as std::str::FromStr>::from_str(
                            val,
                        )
                        .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Search2Response".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Search2Response {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Search2Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Search2Response>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Search2Response>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Search2Response - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Search2Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Search2Response as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Search2Response - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum Search2ResponseSubsonicResponse {
    Search2SuccessResponse(Box<models::Search2SuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for Search2ResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::Search2SuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::Search2SuccessResponse> for Search2ResponseSubsonicResponse {
    fn from(value: models::Search2SuccessResponse) -> Self {
        Self::Search2SuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for Search2ResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Search2ResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Search2ResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Search2SuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "searchResult2")]
    pub search_result2: models::SearchResult2,
}

impl Search2SuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        search_result2: models::SearchResult2,
    ) -> Search2SuccessResponse {
        Search2SuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            search_result2,
        }
    }
}

/// Converts the Search2SuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Search2SuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping searchResult2 in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Search2SuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Search2SuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub search_result2: Vec<models::SearchResult2>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Search2SuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "searchResult2" => intermediate_rep.search_result2.push(
                        <models::SearchResult2 as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Search2SuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Search2SuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in Search2SuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in Search2SuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in Search2SuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in Search2SuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in Search2SuccessResponse".to_string())?,
            search_result2: intermediate_rep
                .search_result2
                .into_iter()
                .next()
                .ok_or_else(|| "searchResult2 missing in Search2SuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Search2SuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Search2SuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Search2SuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Search2SuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Search2SuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Search2SuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Search2SuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested `searchResult3` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Search3Response {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::Search3ResponseSubsonicResponse>,
}

impl Search3Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Search3Response {
        Search3Response {
            subsonic_response: None,
        }
    }
}

/// Converts the Search3Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Search3Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Search3Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Search3Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::Search3ResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Search3Response".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(
                        <models::Search3ResponseSubsonicResponse as std::str::FromStr>::from_str(
                            val,
                        )
                        .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Search3Response".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Search3Response {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Search3Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Search3Response>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Search3Response>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Search3Response - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Search3Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Search3Response as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Search3Response - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum Search3ResponseSubsonicResponse {
    Search3SuccessResponse(Box<models::Search3SuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for Search3ResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::Search3SuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::Search3SuccessResponse> for Search3ResponseSubsonicResponse {
    fn from(value: models::Search3SuccessResponse) -> Self {
        Self::Search3SuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for Search3ResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Search3ResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Search3ResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Search3SuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "searchResult3")]
    pub search_result3: models::SearchResult3,
}

impl Search3SuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        search_result3: models::SearchResult3,
    ) -> Search3SuccessResponse {
        Search3SuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            search_result3,
        }
    }
}

/// Converts the Search3SuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Search3SuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping searchResult3 in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Search3SuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Search3SuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub search_result3: Vec<models::SearchResult3>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Search3SuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "searchResult3" => intermediate_rep.search_result3.push(
                        <models::SearchResult3 as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Search3SuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Search3SuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in Search3SuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in Search3SuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in Search3SuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in Search3SuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in Search3SuccessResponse".to_string())?,
            search_result3: intermediate_rep
                .search_result3
                .into_iter()
                .next()
                .ok_or_else(|| "searchResult3 missing in Search3SuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Search3SuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Search3SuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Search3SuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Search3SuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Search3SuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Search3SuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Search3SuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested `searchResult` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SearchResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::SearchResponseSubsonicResponse>,
}

impl SearchResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SearchResponse {
        SearchResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the SearchResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SearchResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SearchResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SearchResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::SearchResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SearchResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(
                        <models::SearchResponseSubsonicResponse as std::str::FromStr>::from_str(
                            val,
                        )
                        .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SearchResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SearchResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SearchResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SearchResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SearchResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SearchResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SearchResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SearchResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SearchResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum SearchResponseSubsonicResponse {
    SearchSuccessResponse(Box<models::SearchSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for SearchResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::SearchSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::SearchSuccessResponse> for SearchResponseSubsonicResponse {
    fn from(value: models::SearchSuccessResponse) -> Self {
        Self::SearchSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for SearchResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SearchResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SearchResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

/// searchResult2
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SearchResult2 {
    /// Starred artists
    #[serde(rename = "artist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist: Option<Vec<models::Artist>>,

    /// Starred albums
    #[serde(rename = "album")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album: Option<Vec<models::Child>>,

    /// Starred songs
    #[serde(rename = "song")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub song: Option<Vec<models::Child>>,
}

impl SearchResult2 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SearchResult2 {
        SearchResult2 {
            artist: None,
            album: None,
            song: None,
        }
    }
}

/// Converts the SearchResult2 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SearchResult2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping artist in query parameter serialization

            // Skipping album in query parameter serialization

            // Skipping song in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SearchResult2 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SearchResult2 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub artist: Vec<Vec<models::Artist>>,
            pub album: Vec<Vec<models::Child>>,
            pub song: Vec<Vec<models::Child>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SearchResult2".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "artist" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SearchResult2"
                                .to_string(),
                        )
                    }
                    "album" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SearchResult2"
                                .to_string(),
                        )
                    }
                    "song" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SearchResult2"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SearchResult2".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SearchResult2 {
            artist: intermediate_rep.artist.into_iter().next(),
            album: intermediate_rep.album.into_iter().next(),
            song: intermediate_rep.song.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SearchResult2> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SearchResult2>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SearchResult2>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SearchResult2 - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SearchResult2> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SearchResult2 as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SearchResult2 - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// searchResult3
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SearchResult3 {
    /// Matching artists
    #[serde(rename = "artist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist: Option<Vec<models::ArtistId3>>,

    /// Matching albums
    #[serde(rename = "album")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album: Option<Vec<models::AlbumId3>>,

    /// Matching songs
    #[serde(rename = "song")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub song: Option<Vec<models::Child>>,
}

impl SearchResult3 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SearchResult3 {
        SearchResult3 {
            artist: None,
            album: None,
            song: None,
        }
    }
}

/// Converts the SearchResult3 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SearchResult3 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping artist in query parameter serialization

            // Skipping album in query parameter serialization

            // Skipping song in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SearchResult3 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SearchResult3 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub artist: Vec<Vec<models::ArtistId3>>,
            pub album: Vec<Vec<models::AlbumId3>>,
            pub song: Vec<Vec<models::Child>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SearchResult3".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "artist" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SearchResult3"
                                .to_string(),
                        )
                    }
                    "album" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SearchResult3"
                                .to_string(),
                        )
                    }
                    "song" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SearchResult3"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SearchResult3".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SearchResult3 {
            artist: intermediate_rep.artist.into_iter().next(),
            album: intermediate_rep.album.into_iter().next(),
            song: intermediate_rep.song.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SearchResult3> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SearchResult3>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SearchResult3>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SearchResult3 - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SearchResult3> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SearchResult3 as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SearchResult3 - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SearchSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    /// searchResult. TODO
    #[serde(rename = "searchResult")]
    pub search_result: crate::types::Object,
}

impl SearchSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        search_result: crate::types::Object,
    ) -> SearchSuccessResponse {
        SearchSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            search_result,
        }
    }
}

/// Converts the SearchSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SearchSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping searchResult in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SearchSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SearchSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub search_result: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SearchSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "searchResult" => intermediate_rep.search_result.push(
                        <crate::types::Object as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SearchSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SearchSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in SearchSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in SearchSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in SearchSuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in SearchSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in SearchSuccessResponse".to_string())?,
            search_result: intermediate_rep
                .search_result
                .into_iter()
                .next()
                .ok_or_else(|| "searchResult missing in SearchSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SearchSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SearchSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SearchSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SearchSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SearchSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SearchSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SearchSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Share.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Share {
    /// The share Id
    #[serde(rename = "id")]
    pub id: String,

    /// The share url
    #[serde(rename = "url")]
    pub url: String,

    /// A description
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// The username
    #[serde(rename = "username")]
    pub username: String,

    /// Creation date [ISO 8601]
    #[serde(rename = "created")]
    pub created: chrono::DateTime<chrono::Utc>,

    /// Share expiration [ISO 8601]
    #[serde(rename = "expires")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires: Option<chrono::DateTime<chrono::Utc>>,

    /// Last visit [ISO 8601]
    #[serde(rename = "lastVisited")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_visited: Option<chrono::DateTime<chrono::Utc>>,

    /// Visit count
    #[serde(rename = "visitCount")]
    pub visit_count: i32,

    /// A list of share
    #[serde(rename = "entry")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entry: Option<Vec<models::Child>>,
}

impl Share {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        id: String,
        url: String,
        username: String,
        created: chrono::DateTime<chrono::Utc>,
        visit_count: i32,
    ) -> Share {
        Share {
            id,
            url,
            description: None,
            username,
            created,
            expires: None,
            last_visited: None,
            visit_count,
            entry: None,
        }
    }
}

/// Converts the Share value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Share {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("id".to_string()),
            Some(self.id.to_string()),
            Some("url".to_string()),
            Some(self.url.to_string()),
            self.description
                .as_ref()
                .map(|description| ["description".to_string(), description.to_string()].join(",")),
            Some("username".to_string()),
            Some(self.username.to_string()),
            // Skipping created in query parameter serialization

            // Skipping expires in query parameter serialization

            // Skipping lastVisited in query parameter serialization
            Some("visitCount".to_string()),
            Some(self.visit_count.to_string()),
            // Skipping entry in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Share value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Share {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub url: Vec<String>,
            pub description: Vec<String>,
            pub username: Vec<String>,
            pub created: Vec<chrono::DateTime<chrono::Utc>>,
            pub expires: Vec<chrono::DateTime<chrono::Utc>>,
            pub last_visited: Vec<chrono::DateTime<chrono::Utc>>,
            pub visit_count: Vec<i32>,
            pub entry: Vec<Vec<models::Child>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Share".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "expires" => intermediate_rep.expires.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "lastVisited" => intermediate_rep.last_visited.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "visitCount" => intermediate_rep.visit_count.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "entry" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Share"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Share".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Share {
            id: intermediate_rep
                .id
                .into_iter()
                .next()
                .ok_or_else(|| "id missing in Share".to_string())?,
            url: intermediate_rep
                .url
                .into_iter()
                .next()
                .ok_or_else(|| "url missing in Share".to_string())?,
            description: intermediate_rep.description.into_iter().next(),
            username: intermediate_rep
                .username
                .into_iter()
                .next()
                .ok_or_else(|| "username missing in Share".to_string())?,
            created: intermediate_rep
                .created
                .into_iter()
                .next()
                .ok_or_else(|| "created missing in Share".to_string())?,
            expires: intermediate_rep.expires.into_iter().next(),
            last_visited: intermediate_rep.last_visited.into_iter().next(),
            visit_count: intermediate_rep
                .visit_count
                .into_iter()
                .next()
                .ok_or_else(|| "visitCount missing in Share".to_string())?,
            entry: intermediate_rep.entry.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Share> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Share>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Share>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Share - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Share> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Share as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Share - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Shares.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Shares {
    /// A list of share
    #[serde(rename = "share")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub share: Option<Vec<models::Share>>,
}

impl Shares {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Shares {
        Shares { share: None }
    }
}

/// Converts the Shares value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Shares {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping share in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Shares value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Shares {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub share: Vec<Vec<models::Share>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Shares".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "share" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Shares"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Shares".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Shares {
            share: intermediate_rep.share.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Shares> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Shares>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Shares>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Shares - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Shares> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Shares as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Shares - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// SimilarSongs list.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SimilarSongs {
    /// List of songs
    #[serde(rename = "song")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub song: Option<Vec<models::Child>>,
}

impl SimilarSongs {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SimilarSongs {
        SimilarSongs { song: None }
    }
}

/// Converts the SimilarSongs value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SimilarSongs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping song in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SimilarSongs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SimilarSongs {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub song: Vec<Vec<models::Child>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SimilarSongs".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "song" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SimilarSongs"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SimilarSongs".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SimilarSongs {
            song: intermediate_rep.song.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SimilarSongs> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SimilarSongs>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SimilarSongs>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SimilarSongs - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SimilarSongs> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SimilarSongs as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SimilarSongs - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// SimilarSongs2 list.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SimilarSongs2 {
    /// List of songs
    #[serde(rename = "song")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub song: Option<Vec<models::Child>>,
}

impl SimilarSongs2 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SimilarSongs2 {
        SimilarSongs2 { song: None }
    }
}

/// Converts the SimilarSongs2 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SimilarSongs2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping song in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SimilarSongs2 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SimilarSongs2 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub song: Vec<Vec<models::Child>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SimilarSongs2".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "song" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SimilarSongs2"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SimilarSongs2".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SimilarSongs2 {
            song: intermediate_rep.song.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SimilarSongs2> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SimilarSongs2>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SimilarSongs2>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SimilarSongs2 - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SimilarSongs2> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SimilarSongs2 as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SimilarSongs2 - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Songs list.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Songs {
    /// List of songs
    #[serde(rename = "song")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub song: Option<Vec<models::Child>>,
}

impl Songs {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Songs {
        Songs { song: None }
    }
}

/// Converts the Songs value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Songs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping song in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Songs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Songs {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub song: Vec<Vec<models::Child>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Songs".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "song" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Songs"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Songs".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Songs {
            song: intermediate_rep.song.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Songs> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Songs>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Songs>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Songs - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Songs> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Songs as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Songs - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// starred.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Starred {
    /// Starred artists
    #[serde(rename = "artist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist: Option<Vec<models::Artist>>,

    /// Starred albums
    #[serde(rename = "album")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album: Option<Vec<models::Child>>,

    /// Starred songs
    #[serde(rename = "song")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub song: Option<Vec<models::Child>>,
}

impl Starred {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Starred {
        Starred {
            artist: None,
            album: None,
            song: None,
        }
    }
}

/// Converts the Starred value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Starred {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping artist in query parameter serialization

            // Skipping album in query parameter serialization

            // Skipping song in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Starred value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Starred {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub artist: Vec<Vec<models::Artist>>,
            pub album: Vec<Vec<models::Child>>,
            pub song: Vec<Vec<models::Child>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Starred".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "artist" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Starred"
                                .to_string(),
                        )
                    }
                    "album" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Starred"
                                .to_string(),
                        )
                    }
                    "song" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Starred"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Starred".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Starred {
            artist: intermediate_rep.artist.into_iter().next(),
            album: intermediate_rep.album.into_iter().next(),
            song: intermediate_rep.song.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Starred> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Starred>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Starred>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Starred - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Starred> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Starred as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Starred - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Starred2.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Starred2 {
    /// Starred artists
    #[serde(rename = "artist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub artist: Option<Vec<models::ArtistId3>>,

    /// Starred albums
    #[serde(rename = "album")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub album: Option<Vec<models::AlbumId3>>,

    /// Starred songs
    #[serde(rename = "song")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub song: Option<Vec<models::Child>>,
}

impl Starred2 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Starred2 {
        Starred2 {
            artist: None,
            album: None,
            song: None,
        }
    }
}

/// Converts the Starred2 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Starred2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping artist in query parameter serialization

            // Skipping album in query parameter serialization

            // Skipping song in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Starred2 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Starred2 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub artist: Vec<Vec<models::ArtistId3>>,
            pub album: Vec<Vec<models::AlbumId3>>,
            pub song: Vec<Vec<models::Child>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Starred2".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "artist" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Starred2"
                                .to_string(),
                        )
                    }
                    "album" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Starred2"
                                .to_string(),
                        )
                    }
                    "song" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Starred2"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Starred2".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Starred2 {
            artist: intermediate_rep.artist.into_iter().next(),
            album: intermediate_rep.album.into_iter().next(),
            song: intermediate_rep.song.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Starred2> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Starred2>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Starred2>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Starred2 - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Starred2> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Starred2 as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Starred2 - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A subsonic-response element with a nested `scanStatus` element on success.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StartScanResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::StartScanResponseSubsonicResponse>,
}

impl StartScanResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> StartScanResponse {
        StartScanResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the StartScanResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for StartScanResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StartScanResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StartScanResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::StartScanResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing StartScanResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(
                        <models::StartScanResponseSubsonicResponse as std::str::FromStr>::from_str(
                            val,
                        )
                        .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing StartScanResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StartScanResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<StartScanResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<StartScanResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<StartScanResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for StartScanResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<StartScanResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <StartScanResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into StartScanResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum StartScanResponseSubsonicResponse {
    StartScanSuccessResponse(Box<models::StartScanSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for StartScanResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::StartScanSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::StartScanSuccessResponse> for StartScanResponseSubsonicResponse {
    fn from(value: models::StartScanSuccessResponse) -> Self {
        Self::StartScanSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for StartScanResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StartScanResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StartScanResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StartScanSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "scanStatus")]
    pub scan_status: models::ScanStatus,
}

impl StartScanSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        scan_status: models::ScanStatus,
    ) -> StartScanSuccessResponse {
        StartScanSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            scan_status,
        }
    }
}

/// Converts the StartScanSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for StartScanSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping scanStatus in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StartScanSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StartScanSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub scan_status: Vec<models::ScanStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing StartScanSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "scanStatus" => intermediate_rep.scan_status.push(
                        <models::ScanStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing StartScanSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StartScanSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in StartScanSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in StartScanSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in StartScanSuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in StartScanSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in StartScanSuccessResponse".to_string())?,
            scan_status: intermediate_rep
                .scan_status
                .into_iter()
                .next()
                .ok_or_else(|| "scanStatus missing in StartScanSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<StartScanSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<StartScanSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<StartScanSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for StartScanSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<StartScanSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <StartScanSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into StartScanSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Structured lyrics
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StructuredLyrics {
    /// The lyrics language (ideally ISO 639). If the language is unknown (e.g. lrc file), the server must return `und` (ISO standard) or `xxx` (common value for taggers). Ideally, the server will return lang as an ISO 639 (2/3) code. However, tagged files and external lyrics can come with any value as a potential language code, so clients should take care when displaying lang.  Furthermore, there is special behavior for the value xxx. While not an ISO code, it is commonly used by taggers and other parsing software. Clients should treat xxx as not having a specified language (equivalent to the und code).
    #[serde(rename = "lang")]
    pub lang: String,

    /// True if the lyrics are synced, false otherwise
    #[serde(rename = "synced")]
    pub synced: bool,

    /// The actual lyrics. Ordered by start time (synced) or appearance order (unsynced)
    #[serde(rename = "line")]
    pub line: Vec<models::Line>,

    /// The artist name to display. This could be the localized name, or any other value
    #[serde(rename = "displayArtist")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display_artist: Option<String>,

    /// The title to display. This could be the song title (localized), or any other value
    #[serde(rename = "displayTitle")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub display_title: Option<String>,

    /// The offset to apply to all lyrics, in milliseconds. Positive means lyrics appear sooner, negative means later. If not included, the offset must be assumed to be 0
    #[serde(rename = "offset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub offset: Option<f64>,
}

impl StructuredLyrics {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(lang: String, synced: bool, line: Vec<models::Line>) -> StructuredLyrics {
        StructuredLyrics {
            lang,
            synced,
            line,
            display_artist: None,
            display_title: None,
            offset: None,
        }
    }
}

/// Converts the StructuredLyrics value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for StructuredLyrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("lang".to_string()),
            Some(self.lang.to_string()),
            Some("synced".to_string()),
            Some(self.synced.to_string()),
            // Skipping line in query parameter serialization
            self.display_artist.as_ref().map(|display_artist| {
                ["displayArtist".to_string(), display_artist.to_string()].join(",")
            }),
            self.display_title.as_ref().map(|display_title| {
                ["displayTitle".to_string(), display_title.to_string()].join(",")
            }),
            self.offset
                .as_ref()
                .map(|offset| ["offset".to_string(), offset.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StructuredLyrics value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StructuredLyrics {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub lang: Vec<String>,
            pub synced: Vec<bool>,
            pub line: Vec<Vec<models::Line>>,
            pub display_artist: Vec<String>,
            pub display_title: Vec<String>,
            pub offset: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing StructuredLyrics".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "lang" => intermediate_rep.lang.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "synced" => intermediate_rep.synced.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "line" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in StructuredLyrics"
                            .to_string(),
                    ),
                    #[allow(clippy::redundant_clone)]
                    "displayArtist" => intermediate_rep.display_artist.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "displayTitle" => intermediate_rep.display_title.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "offset" => intermediate_rep.offset.push(
                        <f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing StructuredLyrics".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StructuredLyrics {
            lang: intermediate_rep
                .lang
                .into_iter()
                .next()
                .ok_or_else(|| "lang missing in StructuredLyrics".to_string())?,
            synced: intermediate_rep
                .synced
                .into_iter()
                .next()
                .ok_or_else(|| "synced missing in StructuredLyrics".to_string())?,
            line: intermediate_rep
                .line
                .into_iter()
                .next()
                .ok_or_else(|| "line missing in StructuredLyrics".to_string())?,
            display_artist: intermediate_rep.display_artist.into_iter().next(),
            display_title: intermediate_rep.display_title.into_iter().next(),
            offset: intermediate_rep.offset.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<StructuredLyrics> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<StructuredLyrics>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<StructuredLyrics>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for StructuredLyrics - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<StructuredLyrics> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <StructuredLyrics as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into StructuredLyrics - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SubsonicBaseResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,
}

impl SubsonicBaseResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
    ) -> SubsonicBaseResponse {
        SubsonicBaseResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
        }
    }
}

/// Converts the SubsonicBaseResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SubsonicBaseResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SubsonicBaseResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SubsonicBaseResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SubsonicBaseResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SubsonicBaseResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SubsonicBaseResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in SubsonicBaseResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in SubsonicBaseResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in SubsonicBaseResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in SubsonicBaseResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SubsonicBaseResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SubsonicBaseResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SubsonicBaseResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SubsonicBaseResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SubsonicBaseResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SubsonicBaseResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SubsonicBaseResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SubsonicError {
    /// The error code. * 0: A generic error. * 10: Required parameter is missing. * 20: Incompatible Subsonic REST protocol version. Client must upgrade. * 30: Incompatible Subsonic REST protocol version. Server must upgrade. * 40: Wrong username or password. * 41: Token authentication not supported for LDAP users. * 42: Provided authentication mechanism not supported. * 43: Multiple conflicting authentication mechanisms provided. * 44: Invalid API key. * 50: User is not authorized for the given operation. * 60: The trial period for the Subsonic server is over. Please upgrade to Subsonic Premium. Visit subsonic.org for details. * 70: The requested data was not found.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "code")]
    pub code: i32,

    /// The optional error message
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,

    /// A URL (documentation, configuration, etc) which may provide additional context for the error)
    #[serde(rename = "helpUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub help_url: Option<String>,
}

impl SubsonicError {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(code: i32) -> SubsonicError {
        SubsonicError {
            code,
            message: None,
            help_url: None,
        }
    }
}

/// Converts the SubsonicError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SubsonicError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("code".to_string()),
            Some(self.code.to_string()),
            self.message
                .as_ref()
                .map(|message| ["message".to_string(), message.to_string()].join(",")),
            self.help_url
                .as_ref()
                .map(|help_url| ["helpUrl".to_string(), help_url.to_string()].join(",")),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SubsonicError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SubsonicError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<i32>,
            pub message: Vec<String>,
            pub help_url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SubsonicError".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "helpUrl" => intermediate_rep.help_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SubsonicError".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SubsonicError {
            code: intermediate_rep
                .code
                .into_iter()
                .next()
                .ok_or_else(|| "code missing in SubsonicError".to_string())?,
            message: intermediate_rep.message.into_iter().next(),
            help_url: intermediate_rep.help_url.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SubsonicError> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SubsonicError>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SubsonicError>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SubsonicError - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SubsonicError> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SubsonicError as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SubsonicError - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SubsonicFailureResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `failed`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "error")]
    pub error: models::SubsonicError,
}

impl SubsonicFailureResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
        error: models::SubsonicError,
    ) -> SubsonicFailureResponse {
        SubsonicFailureResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
            error,
        }
    }
}

/// Converts the SubsonicFailureResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SubsonicFailureResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
            // Skipping error in query parameter serialization
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SubsonicFailureResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SubsonicFailureResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
            pub error: Vec<models::SubsonicError>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SubsonicFailureResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(
                        <models::SubsonicError as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SubsonicFailureResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SubsonicFailureResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in SubsonicFailureResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in SubsonicFailureResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in SubsonicFailureResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in SubsonicFailureResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in SubsonicFailureResponse".to_string())?,
            error: intermediate_rep
                .error
                .into_iter()
                .next()
                .ok_or_else(|| "error missing in SubsonicFailureResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SubsonicFailureResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SubsonicFailureResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SubsonicFailureResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SubsonicFailureResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SubsonicFailureResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SubsonicFailureResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SubsonicFailureResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Common answer wrapper.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SubsonicResponse {
    #[serde(rename = "subsonic-response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subsonic_response: Option<models::SubsonicResponseSubsonicResponse>,
}

impl SubsonicResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SubsonicResponse {
        SubsonicResponse {
            subsonic_response: None,
        }
    }
}

/// Converts the SubsonicResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SubsonicResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping subsonic-response in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SubsonicResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub subsonic_response: Vec<models::SubsonicResponseSubsonicResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SubsonicResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "subsonic-response" => intermediate_rep.subsonic_response.push(
                        <models::SubsonicResponseSubsonicResponse as std::str::FromStr>::from_str(
                            val,
                        )
                        .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SubsonicResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SubsonicResponse {
            subsonic_response: intermediate_rep.subsonic_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SubsonicResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SubsonicResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SubsonicResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SubsonicResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SubsonicResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SubsonicResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SubsonicResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types)]
pub enum SubsonicResponseSubsonicResponse {
    SubsonicSuccessResponse(Box<models::SubsonicSuccessResponse>),
    SubsonicFailureResponse(Box<models::SubsonicFailureResponse>),
}

impl validator::Validate for SubsonicResponseSubsonicResponse {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::SubsonicSuccessResponse(x) => x.validate(),
            Self::SubsonicFailureResponse(x) => x.validate(),
        }
    }
}

impl From<models::SubsonicSuccessResponse> for SubsonicResponseSubsonicResponse {
    fn from(value: models::SubsonicSuccessResponse) -> Self {
        Self::SubsonicSuccessResponse(Box::new(value))
    }
}
impl From<models::SubsonicFailureResponse> for SubsonicResponseSubsonicResponse {
    fn from(value: models::SubsonicFailureResponse) -> Self {
        Self::SubsonicFailureResponse(Box::new(value))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SubsonicResponseSubsonicResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SubsonicResponseSubsonicResponse {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SubsonicSuccessResponse {
    /// The server supported Subsonic API version.
    #[serde(rename = "version")]
    pub version: String,

    /// The server actual name. [Ex: Navidrome or gonic]
    #[serde(rename = "type")]
    pub r#type: String,

    /// The server version.
    #[serde(rename = "serverVersion")]
    pub server_version: String,

    /// Must return true if the server support OpenSubsonic API v1
    #[serde(rename = "openSubsonic")]
    pub open_subsonic: bool,

    /// The command result. `ok`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,
}

impl SubsonicSuccessResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        version: String,
        r#type: String,
        server_version: String,
        open_subsonic: bool,
        status: String,
    ) -> SubsonicSuccessResponse {
        SubsonicSuccessResponse {
            version,
            r#type,
            server_version,
            open_subsonic,
            status,
        }
    }
}

/// Converts the SubsonicSuccessResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SubsonicSuccessResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("version".to_string()),
            Some(self.version.to_string()),
            Some("type".to_string()),
            Some(self.r#type.to_string()),
            Some("serverVersion".to_string()),
            Some(self.server_version.to_string()),
            Some("openSubsonic".to_string()),
            Some(self.open_subsonic.to_string()),
            Some("status".to_string()),
            Some(self.status.to_string()),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SubsonicSuccessResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SubsonicSuccessResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<String>,
            pub r#type: Vec<String>,
            pub server_version: Vec<String>,
            pub open_subsonic: Vec<bool>,
            pub status: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SubsonicSuccessResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serverVersion" => intermediate_rep.server_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "openSubsonic" => intermediate_rep.open_subsonic.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SubsonicSuccessResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SubsonicSuccessResponse {
            version: intermediate_rep
                .version
                .into_iter()
                .next()
                .ok_or_else(|| "version missing in SubsonicSuccessResponse".to_string())?,
            r#type: intermediate_rep
                .r#type
                .into_iter()
                .next()
                .ok_or_else(|| "type missing in SubsonicSuccessResponse".to_string())?,
            server_version: intermediate_rep
                .server_version
                .into_iter()
                .next()
                .ok_or_else(|| "serverVersion missing in SubsonicSuccessResponse".to_string())?,
            open_subsonic: intermediate_rep
                .open_subsonic
                .into_iter()
                .next()
                .ok_or_else(|| "openSubsonic missing in SubsonicSuccessResponse".to_string())?,
            status: intermediate_rep
                .status
                .into_iter()
                .next()
                .ok_or_else(|| "status missing in SubsonicSuccessResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SubsonicSuccessResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SubsonicSuccessResponse>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SubsonicSuccessResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SubsonicSuccessResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SubsonicSuccessResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SubsonicSuccessResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SubsonicSuccessResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information about an API key
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TokenInfo {
    /// Username associated with token
    #[serde(rename = "username")]
    pub username: String,
}

impl TokenInfo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(username: String) -> TokenInfo {
        TokenInfo { username }
    }
}

/// Converts the TokenInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TokenInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("username".to_string()),
            Some(self.username.to_string()),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TokenInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TokenInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TokenInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TokenInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TokenInfo {
            username: intermediate_rep
                .username
                .into_iter()
                .next()
                .ok_or_else(|| "username missing in TokenInfo".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TokenInfo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TokenInfo>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TokenInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TokenInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TokenInfo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TokenInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TokenInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// TopSongs list.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TopSongs {
    /// List of songs
    #[serde(rename = "song")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub song: Option<Vec<models::Child>>,
}

impl TopSongs {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TopSongs {
        TopSongs { song: None }
    }
}

/// Converts the TopSongs value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TopSongs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping song in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TopSongs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TopSongs {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub song: Vec<Vec<models::Child>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TopSongs".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "song" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in TopSongs"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TopSongs".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TopSongs {
            song: intermediate_rep.song.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TopSongs> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TopSongs>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TopSongs>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TopSongs - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TopSongs> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TopSongs as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TopSongs - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// user.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct User {
    /// Username
    #[serde(rename = "username")]
    pub username: String,

    /// Scrobbling enabled
    #[serde(rename = "scrobblingEnabled")]
    pub scrobbling_enabled: bool,

    #[serde(rename = "maxBitRate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_bit_rate: Option<i32>,

    /// Whether the user is an admin
    #[serde(rename = "adminRole")]
    pub admin_role: bool,

    /// Whether the user is can edit settings
    #[serde(rename = "settingsRole")]
    pub settings_role: bool,

    /// Whether the user can download
    #[serde(rename = "downloadRole")]
    pub download_role: bool,

    /// Whether the user can upload
    #[serde(rename = "uploadRole")]
    pub upload_role: bool,

    /// Whether the user can create playlists
    #[serde(rename = "playlistRole")]
    pub playlist_role: bool,

    /// Whether the user can get cover art
    #[serde(rename = "coverArtRole")]
    pub cover_art_role: bool,

    /// Whether the user can create comments
    #[serde(rename = "commentRole")]
    pub comment_role: bool,

    /// Whether the user can create/refresh podcasts
    #[serde(rename = "podcastRole")]
    pub podcast_role: bool,

    /// Whether the user can stream
    #[serde(rename = "streamRole")]
    pub stream_role: bool,

    /// Whether the user can control the jukebox
    #[serde(rename = "jukeboxRole")]
    pub jukebox_role: bool,

    /// Whether the user can create a stream
    #[serde(rename = "shareRole")]
    pub share_role: bool,

    /// Whether the user can convert videos
    #[serde(rename = "videoConversionRole")]
    pub video_conversion_role: bool,

    /// Last time the avatar was changed [ISO 8601]
    #[serde(rename = "avatarLastChanged")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub avatar_last_changed: Option<chrono::DateTime<chrono::Utc>>,

    /// Folder ID(s)
    #[serde(rename = "folder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub folder: Option<Vec<i32>>,
}

impl User {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(
        username: String,
        scrobbling_enabled: bool,
        admin_role: bool,
        settings_role: bool,
        download_role: bool,
        upload_role: bool,
        playlist_role: bool,
        cover_art_role: bool,
        comment_role: bool,
        podcast_role: bool,
        stream_role: bool,
        jukebox_role: bool,
        share_role: bool,
        video_conversion_role: bool,
    ) -> User {
        User {
            username,
            scrobbling_enabled,
            max_bit_rate: None,
            admin_role,
            settings_role,
            download_role,
            upload_role,
            playlist_role,
            cover_art_role,
            comment_role,
            podcast_role,
            stream_role,
            jukebox_role,
            share_role,
            video_conversion_role,
            avatar_last_changed: None,
            folder: None,
        }
    }
}

/// Converts the User value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for User {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            Some("username".to_string()),
            Some(self.username.to_string()),
            Some("scrobblingEnabled".to_string()),
            Some(self.scrobbling_enabled.to_string()),
            self.max_bit_rate
                .as_ref()
                .map(|max_bit_rate| ["maxBitRate".to_string(), max_bit_rate.to_string()].join(",")),
            Some("adminRole".to_string()),
            Some(self.admin_role.to_string()),
            Some("settingsRole".to_string()),
            Some(self.settings_role.to_string()),
            Some("downloadRole".to_string()),
            Some(self.download_role.to_string()),
            Some("uploadRole".to_string()),
            Some(self.upload_role.to_string()),
            Some("playlistRole".to_string()),
            Some(self.playlist_role.to_string()),
            Some("coverArtRole".to_string()),
            Some(self.cover_art_role.to_string()),
            Some("commentRole".to_string()),
            Some(self.comment_role.to_string()),
            Some("podcastRole".to_string()),
            Some(self.podcast_role.to_string()),
            Some("streamRole".to_string()),
            Some(self.stream_role.to_string()),
            Some("jukeboxRole".to_string()),
            Some(self.jukebox_role.to_string()),
            Some("shareRole".to_string()),
            Some(self.share_role.to_string()),
            Some("videoConversionRole".to_string()),
            Some(self.video_conversion_role.to_string()),
            // Skipping avatarLastChanged in query parameter serialization
            self.folder.as_ref().map(|folder| {
                [
                    "folder".to_string(),
                    folder
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a User value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for User {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub username: Vec<String>,
            pub scrobbling_enabled: Vec<bool>,
            pub max_bit_rate: Vec<i32>,
            pub admin_role: Vec<bool>,
            pub settings_role: Vec<bool>,
            pub download_role: Vec<bool>,
            pub upload_role: Vec<bool>,
            pub playlist_role: Vec<bool>,
            pub cover_art_role: Vec<bool>,
            pub comment_role: Vec<bool>,
            pub podcast_role: Vec<bool>,
            pub stream_role: Vec<bool>,
            pub jukebox_role: Vec<bool>,
            pub share_role: Vec<bool>,
            pub video_conversion_role: Vec<bool>,
            pub avatar_last_changed: Vec<chrono::DateTime<chrono::Utc>>,
            pub folder: Vec<Vec<i32>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing User".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "scrobblingEnabled" => intermediate_rep.scrobbling_enabled.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "maxBitRate" => intermediate_rep.max_bit_rate.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "adminRole" => intermediate_rep.admin_role.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "settingsRole" => intermediate_rep.settings_role.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "downloadRole" => intermediate_rep.download_role.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uploadRole" => intermediate_rep.upload_role.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "playlistRole" => intermediate_rep.playlist_role.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "coverArtRole" => intermediate_rep.cover_art_role.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "commentRole" => intermediate_rep.comment_role.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "podcastRole" => intermediate_rep.podcast_role.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "streamRole" => intermediate_rep.stream_role.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "jukeboxRole" => intermediate_rep.jukebox_role.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "shareRole" => intermediate_rep.share_role.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "videoConversionRole" => intermediate_rep.video_conversion_role.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "avatarLastChanged" => intermediate_rep.avatar_last_changed.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "folder" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in User"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing User".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(User {
            username: intermediate_rep
                .username
                .into_iter()
                .next()
                .ok_or_else(|| "username missing in User".to_string())?,
            scrobbling_enabled: intermediate_rep
                .scrobbling_enabled
                .into_iter()
                .next()
                .ok_or_else(|| "scrobblingEnabled missing in User".to_string())?,
            max_bit_rate: intermediate_rep.max_bit_rate.into_iter().next(),
            admin_role: intermediate_rep
                .admin_role
                .into_iter()
                .next()
                .ok_or_else(|| "adminRole missing in User".to_string())?,
            settings_role: intermediate_rep
                .settings_role
                .into_iter()
                .next()
                .ok_or_else(|| "settingsRole missing in User".to_string())?,
            download_role: intermediate_rep
                .download_role
                .into_iter()
                .next()
                .ok_or_else(|| "downloadRole missing in User".to_string())?,
            upload_role: intermediate_rep
                .upload_role
                .into_iter()
                .next()
                .ok_or_else(|| "uploadRole missing in User".to_string())?,
            playlist_role: intermediate_rep
                .playlist_role
                .into_iter()
                .next()
                .ok_or_else(|| "playlistRole missing in User".to_string())?,
            cover_art_role: intermediate_rep
                .cover_art_role
                .into_iter()
                .next()
                .ok_or_else(|| "coverArtRole missing in User".to_string())?,
            comment_role: intermediate_rep
                .comment_role
                .into_iter()
                .next()
                .ok_or_else(|| "commentRole missing in User".to_string())?,
            podcast_role: intermediate_rep
                .podcast_role
                .into_iter()
                .next()
                .ok_or_else(|| "podcastRole missing in User".to_string())?,
            stream_role: intermediate_rep
                .stream_role
                .into_iter()
                .next()
                .ok_or_else(|| "streamRole missing in User".to_string())?,
            jukebox_role: intermediate_rep
                .jukebox_role
                .into_iter()
                .next()
                .ok_or_else(|| "jukeboxRole missing in User".to_string())?,
            share_role: intermediate_rep
                .share_role
                .into_iter()
                .next()
                .ok_or_else(|| "shareRole missing in User".to_string())?,
            video_conversion_role: intermediate_rep
                .video_conversion_role
                .into_iter()
                .next()
                .ok_or_else(|| "videoConversionRole missing in User".to_string())?,
            avatar_last_changed: intermediate_rep.avatar_last_changed.into_iter().next(),
            folder: intermediate_rep.folder.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<User> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<User>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<User>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for User - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<User> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <User as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into User - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// users.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Users {
    /// Array of users
    #[serde(rename = "user")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user: Option<Vec<models::User>>,
}

impl Users {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Users {
        Users { user: None }
    }
}

/// Converts the Users value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Users {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping user in query parameter serialization

        ];

        write!(
            f,
            "{}",
            params.into_iter().flatten().collect::<Vec<_>>().join(",")
        )
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Users value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Users {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub user: Vec<Vec<models::User>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Users".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "user" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Users"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Users".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Users {
            user: intermediate_rep.user.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Users> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Users>> for HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Users>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Users - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Users> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Users as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Users - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}
